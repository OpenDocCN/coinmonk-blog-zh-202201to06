<html>
<head>
<title>My lesson learn in Solana Smart Contract development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在Solana智能合同开发中吸取教训</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/my-lesson-learn-in-solana-smart-contract-development-27fa361118b1?source=collection_archive---------9-----------------------#2022-03-08">https://medium.com/coinmonks/my-lesson-learn-in-solana-smart-contract-development-27fa361118b1?source=collection_archive---------9-----------------------#2022-03-08</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="39c9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jo" href="https://docs.solana.com/introduction" rel="noopener ugc nofollow" target="_blank"> Solana </a>是一个旨在提供高性能区块链的项目。其处理速度可高达每秒20万次交易(tps)，而与比特币和以太坊等其他热门区块链相比，它们的处理速度仅为15 tps左右。其极快的事务时间是由于使用了历史证明(PoH ),这为分布式系统带来了“同步时间”。“同步时间”实际上是由可验证延迟函数(VDF)产生的状态序列。有了这些时间信息，集群中的每个节点都可以在更短的时间内验证这些信息。</p><p id="8dcf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从应用的角度来看，智能合同的编程模型与其他区块链有很大不同。索拉纳智能合约是在索拉纳区块链执行的代码。与有状态的以太坊智能合约相反，Solana智能合约是无状态的，这意味着它不会在合约中存储任何数据。所有数据都存储在验证器中的某种“帐户”(程序派生的帐户)中。这就像我们的计算机应用程序将数据存储在存储系统中的文件上一样。</p><p id="0c75" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在开始任何交易之前，前端应用程序将请求系统程序为智能合约创建程序派生帐户(<code class="eh jp jq jr js b">SystemProgram.createAccountWithSeed</code>)以存储交易状态。</p><pre class="jt ju jv jw fq jx js jy jz aw ka dt"><span id="d8f7" class="kb kc ht js b fv kd ke l kf kg">const transaction = new Transaction().add(<br/>      SystemProgram.createAccountWithSeed({        <br/>                fromPubkey: payer.publicKey,        <br/>                basePubkey: payer.publicKey,        <br/>                seed: GREETING_SEED,        <br/>                newAccountPubkey: greetedPubkey,        <br/>                lamports,        <br/>                space: GREETING_SIZE,        <br/>                programId,      }),    );    <br/>await sendAndConfirmTransaction(connection, transaction, [payer]);</span></pre><p id="a2ad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，它会将程序派生的帐户地址(<code class="eh jp jq jr js b">greetedPubkey</code>)以及可选的付款人帐户地址和受益人帐户地址传递给智能合同处理器功能。</p><pre class="jt ju jv jw fq jx js jy jz aw ka dt"><span id="de2d" class="kb kc ht js b fv kd ke l kf kg">const instruction = new TransactionInstruction({    <br/>                        keys: [{pubkey: greetedPubkey, <br/>                              isSigner: false, <br/>                              isWritable: true}],    <br/>                        programId,    <br/>                        data: Buffer.from(s, 'utf-8')  });  <br/>await sendAndConfirmTransaction(    <br/>          connection,    <br/>          new Transaction().add(instruction),    <br/>          [payer],  );</span></pre><p id="54a8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所有交易逻辑将在处理器功能内执行，如从付款人账户借记、向受益人账户贷记、更新程序衍生账户中的状态。额外的指令数据(<code class="eh jp jq jr js b">data: Buffer.from(s, ‘utf-8’)</code>)也可以从前端应用程序传递到函数参数<code class="eh jp jq jr js b">_instruction_data</code>中显示的处理器函数。</p><p id="debc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下面是Rust中的智能合同处理器函数定义</p><pre class="jt ju jv jw fq jx js jy jz aw ka dt"><span id="ad5a" class="kb kc ht js b fv kd ke l kf kg">pub fn process_instruction(    <br/>    program_id: &amp;Pubkey, // Public key program loaded<br/>    accounts: &amp;[AccountInfo], // The account array storing the state<br/>    _instruction_data: &amp;[u8], // addition instruction data <br/>) -&gt; ProgramResult {</span></pre><p id="fb08" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">智能合约可以用编程语言——Rust开发，前端app可以用Web3.0 API用typescript开发。</p><p id="2eb5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这里，我试图分享我在开发一个简单的智能合同方面的学习经验，但我发现它最终并不那么简单。</p><p id="f298" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，我下载了<a class="ae jo" href="https://github.com/solana-labs/example-helloworld/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"> hello-world示例</a>，并按照自述文件上的说明进行操作。hello-world的例子非常简单。每次调用智能协定时，它都会增加一个计数器。计数器存储在程序状态帐户的整数变量中。之后，前端应用程序可以读取递增后的计数器值。</p><p id="0675" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来，基于hello-world示例，我在状态变量中使用“String”而不是integer。然而，有一些挑战，我面对的只是一点点变化。</p><p id="aef2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当typescript前端应用程序发送创建状态帐户的请求时，它需要指定大小。帐户一旦创建，就不能调整大小。状态变量中的所有数据将以二进制格式序列化并写入帐户。typescript前端通过添加每个状态变量(即字符串类型变量)的内存大小来计算大小。然后智能合约函数将读取数据并反序列化到内存中。但是我发现typescript的字符串变量实现和Rust不一样。所以帐户的大小与Rust中的变量大小不匹配，这导致了反序列化中的错误。最终，我通过将字符串转换为固定长度的字节数组来解决它，这样大小就可以正确计算并相互匹配。</p><p id="6d88" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下面是在Rust中表示字符串变量的字节数组的结构。</p><pre class="jt ju jv jw fq jx js jy jz aw ka dt"><span id="6f38" class="kb kc ht js b fv kd ke l kf kg">const SIZE: usize = 512;</span><span id="86c8" class="kb kc ht js b fv kh ke l kf kg">#[derive(BorshSerialize, BorshDeserialize, Debug)]<br/>pub struct GreetingAccount {    <br/>    pub _field1: [u8; SIZE],<br/>}</span></pre><p id="89ab" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">注意:指令(<code class="eh jp jq jr js b">#[derive(BorshSerialize, BorshDeserialize, Debug)]</code>)是让<code class="eh jp jq jr js b">BorshSerialize</code>和<code class="eh jp jq jr js b">BorshDerialize</code>应用于自定义结构类型<code class="eh jp jq jr js b">GreetingAccount</code>。</p><p id="5637" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下面是字节数组struct的类型脚本代码，账户存储数组的空间可以通过<code class="eh jp jq jr js b">borsh.serialize( GreetingSchema, new GreetingAccount(),).length;</code>计算出来</p><pre class="jt ju jv jw fq jx js jy jz aw ka dt"><span id="badc" class="kb kc ht js b fv kd ke l kf kg">class GreetingAccount {  <br/>    jsonstring = new Uint8Array(SIZE);  <br/>    constructor(fields: {jsonstring: Uint8Array} <br/>| undefined = undefined) {    <br/>          if (fields) {      <br/>              this.jsonstring = new Uint8Array(fields.jsonstring); <br/>              console.log("get string",fields.jsonstring);    <br/>          }<br/>  }}</span><span id="048b" class="kb kc ht js b fv kh ke l kf kg">/** * Borsh schema definition for greeting accounts */<br/>const GreetingSchema = new Map([  <br/>[GreetingAccount, <br/>{kind: 'struct', fields: [['jsonstring',[SIZE]] ]}]<br/>]);</span><span id="5118" class="kb kc ht js b fv kh ke l kf kg">borsh.serialize(  GreetingSchema,  new GreetingAccount(),).length;</span></pre><p id="f3fd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来，我需要解决定长限制。在实践中，字符串长度会随着时间的推移而变化，我将数组大小设置为一个足够大的值，并用0位填充字节数组。字符串字符字节将被写入字节数组，其余字节为零位。我们可以通过读取字节并截断尾随的零字节来将其转换回字符串。</p><p id="6f3e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下面是用零填充字节数组的Rust代码。</p><pre class="jt ju jv jw fq jx js jy jz aw ka dt"><span id="4f37" class="kb kc ht js b fv kd ke l kf kg">fn fill_from_str(mut bytes: &amp;mut [u8], s: &amp;[u8]) {<br/>    bytes.write(s).unwrap();<br/>}</span><span id="9e93" class="kb kc ht js b fv kh ke l kf kg">let new_b = // new string data in byte array<br/>    <br/>let n = new_b.len();    <br/>let mut bytes: [u8; SIZE] = [0; SIZE];    <br/>if n &gt;= SIZE {<br/>   new_account._field1.clone_from_slice(&amp;new_b[0..SIZE]);    <br/>} else {        <br/>   fill_from_str(&amp;mut bytes,new_b );<br/>   new_account._field1.clone_from_slice(&amp;bytes[0..SIZE]);    <br/>}</span></pre><p id="3426" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">一开始，我想将<code class="eh jp jq jr js b">SIZE</code>设置为一个大值，然而，我发现当我将其设置为大于512的值时，<code class="eh jp jq jr js b">borsh</code>序列化/反序列化库会抛出错误。似乎库函数对数组长度有一些限制。另一个限制是每个计划状态帐户必须小于10 MB，尽管我们可以将多个帐户传递给智能合同处理器。</p><p id="46fb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下面是序列化/反序列化的代码。<code class="eh jp jq jr js b">try_from_slice</code>是将账户数据反序列化为强类型结构。然后新更新的结构<code class="eh jp jq jr js b">new_account</code>将<code class="eh jp jq jr js b">serialize</code>放入账户数据中。</p><pre class="jt ju jv jw fq jx js jy jz aw ka dt"><span id="a1f8" class="kb kc ht js b fv kd ke l kf kg">// Deserialize the account data into the struct type variables.</span><span id="cec0" class="kb kc ht js b fv kh ke l kf kg">let mut greeting_account =<br/>        GreetingAccount::try_from_slice(&amp;account.data.borrow())?;</span><span id="7d08" class="kb kc ht js b fv kh ke l kf kg">// Serialize new string into the account data <br/>    <br/>new_account.serialize(&amp;mut &amp;mut account.data.borrow_mut()[..])?;</span></pre><p id="049b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下面是在智能合约更新字符串变量后反序列化帐户数据的typescript应用程序。</p><pre class="jt ju jv jw fq jx js jy jz aw ka dt"><span id="ad50" class="kb kc ht js b fv kd ke l kf kg">const accountInfo = await connection.getAccountInfo(greetedPubkey);<br/>const greeting =<br/> borsh.deserialize(GreetingSchema,GreetingAccount,accountInfo.data);   console.log( Buffer.from(greeting.jsonstring.buffer).toString());</span></pre><p id="0e68" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，我分享一些我学到的有用的调试工具。这里是日志记录功能，让您检查日志中的参数数据。如果智能合约抛出任何错误，日志将显示在前端应用程序事务提交调用中。</p><pre class="jt ju jv jw fq jx js jy jz aw ka dt"><span id="a188" class="kb kc ht js b fv kd ke l kf kg">sol_log_params(accounts, _instruction_data);    sol_log_slice(&amp;account.data.borrow());</span></pre><p id="e7c4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">帐户数据可以通过Solana cli显示。</p><pre class="jt ju jv jw fq jx js jy jz aw ka dt"><span id="5599" class="kb kc ht js b fv kd ke l kf kg">solana account &lt;account pub key address&gt;</span></pre><p id="4f9c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jo" href="https://github.com/iwasnothing/solana-smart-contract/blob/main/src/program-rust/src/lib.rs" rel="noopener ugc nofollow" target="_blank"> Rust智能合约</a>和<a class="ae jo" href="https://github.com/iwasnothing/solana-smart-contract/blob/main/src/client/json_contract.ts" rel="noopener ugc nofollow" target="_blank">前端打字稿app </a>的完整代码可以在我的<a class="ae jo" href="https://github.com/iwasnothing/solana-smart-contract" rel="noopener ugc nofollow" target="_blank"> Git </a>中找到。</p></div></div>    
</body>
</html>