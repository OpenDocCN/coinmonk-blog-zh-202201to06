<html>
<head>
<title>DO YOU KNOW THE REFERENCE TYPES IN SOLIDITY?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你知道SOLIDITY中的引用类型吗？</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/do-you-know-the-reference-types-in-solidity-7a4821ed7937?source=collection_archive---------9-----------------------#2022-03-26">https://medium.com/coinmonks/do-you-know-the-reference-types-in-solidity-7a4821ed7937?source=collection_archive---------9-----------------------#2022-03-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/ea41c8d0ab60189b1dd7e2aa5ba97aa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dodqDGVmPFFWtFaY07Ddow.png"/></div></div></figure><div class=""/><p id="bb10" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">正如我们在我的第二篇文章中了解到的，Solidity有不同的数据类型，分为两类，即:引用类型和值类型。在这篇文章中，我们将集中讨论solidity中的引用类型部分。</p><h1 id="831b" class="jz ka ie bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated"><strong class="ak">参考类型</strong></h1><p id="6163" class="pw-post-body-paragraph jb jc ie jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">参考类型顾名思义即<em class="lc">所指。R </em>引用类型不直接将数据存储到变量中，而是存储数据的位置(从该位置引用数据)。如果使用引用类型，则必须始终显式提供存储该类型的数据区域:</p><ul class=""><li id="fdff" class="ld le ie jd b je jf ji jj jm lf jq lg ju lh jy li lj lk ll dt translated">内存——其生存期仅限于外部函数调用，</li><li id="aced" class="ld le ie jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">存储——存储状态变量的位置，其生命期限于合同的生命期，</li><li id="3070" class="ld le ie jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">包含函数参数的特殊数据位置。</li></ul><p id="3405" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这种情况下，使用引用类型，两个不同的变量可以引用同一个位置；一个变量的任何变化都会影响到另一个变量；因此，值类型需要非常小心地处理。值类型和引用类型之间的显著区别是数据位置。</p><h2 id="470e" class="lr ka ie bd kb ls lt lu kf lv lw lx kj jm ly lz kn jq ma mb kr ju mc md kv me dt translated">数据位置和分配行为</h2><p id="6f87" class="pw-post-body-paragraph jb jc ie jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">数据位置不仅与数据的持久性相关，还与赋值的语义相关:</p><ul class=""><li id="88b1" class="ld le ie jd b je jf ji jj jm lf jq lg ju lh jy li lj lk ll dt translated">在<code class="eh mf mg mh mi b">storage</code>和<code class="eh mf mg mh mi b">memory</code>(或来自<code class="eh mf mg mh mi b">calldata</code>)之间的分配总是创建一个独立的副本。</li><li id="da77" class="ld le ie jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">从<code class="eh mf mg mh mi b">memory</code>到<code class="eh mf mg mh mi b">memory</code>的分配仅创建参考。这意味着对一个内存变量的更改在引用相同数据的所有其他内存变量中也是可见的。</li><li id="a0ca" class="ld le ie jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">从<code class="eh mf mg mh mi b">storage</code>到本地存储变量的赋值也只分配一个引用。</li><li id="d803" class="ld le ie jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">所有其他分配给<code class="eh mf mg mh mi b">storage</code>的任务总是复制。这种情况的例子是对状态变量或存储结构类型的局部变量成员的赋值，即使局部变量本身只是一个引用。</li></ul><p id="fac4" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">引用类型由以下内容组成:</p><ul class=""><li id="3c61" class="ld le ie jd b je jf ji jj jm lf jq lg ju lh jy li lj lk ll dt translated">排列</li><li id="4b56" class="ld le ie jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">结构</li><li id="12f4" class="ld le ie jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated">绘图</li></ul><blockquote class="mj mk ml"><p id="4dac" class="jb jc lc jd b je jf jg jh ji jj jk jl mm jn jo jp mn jr js jt mo jv jw jx jy hm dt translated">数组和结构有额外的数据位置，指定数据(变量值)应该存储在哪里。</p></blockquote><h2 id="7b52" class="lr ka ie bd kb ls lt lu kf lv lw lx kj jm ly lz kn jq ma mb kr ju mc md kv me dt translated"><strong class="ak">数组</strong></h2><p id="75a7" class="pw-post-body-paragraph jb jc ie jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">数组<strong class="jd if"> </strong>是<strong class="jd if"> </strong>一组相同数据类型的元素，其中每个元素都有一个称为index的特定位置。Solidity中的数组可以是动态的(即它可以被修改或改变)或固定大小的(即它是固定的/不能被改变)。</p><p id="9a36" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">固定大小数组</strong></p><p id="1dc7" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">固定大小数组在声明时具有预定义的大小。例如，一个固定大小为5且元素类型为uint的数组被写成，</p><pre class="mp mq mr ms fq mt mi mu mv aw mw dt"><span id="5930" class="lr ka ie mi b fv mx my l mz na">uint[5] arrayName;</span></pre><p id="2f5b" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当我们声明一个数组时，它不会初始化；我们必须用一个新的关键字来初始化它。然而，在Solidity中，你不能对固定大小的数组使用new关键字；相反，它们可以内联初始化。</p><pre class="mp mq mr ms fq mt mi mu mv aw mw dt"><span id="a802" class="lr ka ie mi b fv mx my l mz na">uint[5] marks  = [uint(50), 60,70,80,90];</span></pre><figure class="mp mq mr ms fq hv"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="e005" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">动态数组</strong></p><p id="8cb5" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">动态数组在声明时没有预定义的大小；大小将在运行时确定。</p><pre class="mp mq mr ms fq mt mi mu mv aw mw dt"><span id="4b25" class="lr ka ie mi b fv mx my l mz na">uint[] arrayName;</span></pre><p id="916b" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">可以用“new”关键字或inline初始化动态数组。</p><pre class="mp mq mr ms fq mt mi mu mv aw mw dt"><span id="6026" class="lr ka ie mi b fv mx my l mz na">uint[5] mathMarks = [uint(50), 60,70,80,90];</span><span id="f3be" class="lr ka ie mi b fv nd my l mz na"><strong class="mi if">int</strong>[] scienceMarks = <strong class="mi if">new</strong> <strong class="mi if">int</strong>[](5);</span></pre><figure class="mp mq mr ms fq hv"><div class="bz el l di"><div class="nb nc l"/></div></figure><h2 id="8422" class="lr ka ie bd kb ls lt lu kf lv lw lx kj jm ly lz kn jq ma mb kr ju mc md kv me dt translated">结构</h2><p id="8312" class="pw-post-body-paragraph jb jc ie jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">结构允许您将数据分组在一起。Solidity提供了一种以结构形式定义新类型的方法，如下例所示:</p><figure class="mp mq mr ms fq hv"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="a1c8" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该协定不提供结构协定的全部功能，但它包含理解结构所必需的基本概念。结构类型可以在映射和数组中使用，它们本身可以包含映射和数组。</p><p id="48fc" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">尽管结构本身可以是映射成员的值类型，或者可以包含其类型的动态大小数组，但结构不可能包含其自身类型的成员。这个限制是必要的，因为结构的大小必须是有限的。</p><h2 id="dc93" class="lr ka ie bd kb ls lt lu kf lv lw lx kj jm ly lz kn jq ma mb kr ju mc md kv me dt translated">绘图</h2><p id="d815" class="pw-post-body-paragraph jb jc ie jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">映射就像python中的字典，它允许高效的查找。比如:我们来看看Rachael是否包含在下面的数组中；</p><pre class="mp mq mr ms fq mt mi mu mv aw mw dt"><span id="d35a" class="lr ka ie mi b fv mx my l mz na">[Serah, Esther, Eve];<br/>[Serah=true, Esther=true, Eve=true]; //which means that rachael is not included.</span></pre><p id="0282" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在数组中，我们必须经过3次查找，但是在映射中，我们只需要一次查找就可以得到想要的结果。</p><p id="6d27" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">映射类型使用语法<code class="eh mf mg mh mi b">mapping(KeyType =&gt; ValueType)</code>，映射类型的变量使用语法<code class="eh mf mg mh mi b">mapping(KeyType =&gt; ValueType) VariableName</code>声明。<code class="eh mf mg mh mi b">KeyType</code>可以是任何内置值类型、<code class="eh mf mg mh mi b">bytes</code>、<code class="eh mf mg mh mi b">string</code>，或者任何契约或枚举类型。</p><p id="de45" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在下面的例子中，<code class="eh mf mg mh mi b">Mapping</code>契约定义了一个公共<code class="eh mf mg mh mi b">balances</code>映射，键类型为<code class="eh mf mg mh mi b">address</code>，值类型为<code class="eh mf mg mh mi b">uint</code>，将以太坊地址映射到一个无符号整数值。</p><figure class="mp mq mr ms fq hv"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="3414" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">感谢阅读！</strong></p><blockquote class="ne"><p id="db29" class="nf ng ie bd nh ni nj nk nl nm nn jy ek translated">加入Coinmonks <a class="ae no" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae no" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="1293" class="jz ka ie bd kb kc kd ke kf kg kh ki kj kk np km kn ko nq kq kr ks nr ku kv kw dt translated">另外，阅读</h1><ul class=""><li id="7d9b" class="ld le ie jd b je kx ji ky jm ns jq nt ju nu jy li lj lk ll dt translated"><a class="ae no" href="https://coincodecap.com/free-crypto-signals" rel="noopener ugc nofollow" target="_blank">最佳免费加密信号</a> | <a class="ae no" rel="noopener" href="/coinmonks/yobit-review-175464162c62"> YoBit评论</a> | <a class="ae no" rel="noopener" href="/coinmonks/bitbns-review-38256a07e161"> Bitbns评论</a></li><li id="8f82" class="ld le ie jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae no" rel="noopener" href="/coinmonks/okex-review-6b369304110f"> OKEx回顾</a> | <a class="ae no" rel="noopener" href="/coinmonks/kucoin-trading-bot-automate-your-trades-8cf0ca2138e0"> Kucoin交易机器人</a> | <a class="ae no" rel="noopener" href="/coinmonks/futures-trading-bots-5a282ccee3f5">期货交易机器人</a></li><li id="541b" class="ld le ie jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae no" href="https://coincodecap.com/ascendex-staking" rel="noopener ugc nofollow" target="_blank">AscendEx Staking</a>|<a class="ae no" href="https://coincodecap.com/bot-ocean-review" rel="noopener ugc nofollow" target="_blank">Bot Ocean Review</a>|<a class="ae no" href="https://coincodecap.com/bitcoin-wallets-india" rel="noopener ugc nofollow" target="_blank">最佳比特币钱包</a></li><li id="20e6" class="ld le ie jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae no" href="https://coincodecap.com/huobi-review" rel="noopener ugc nofollow" target="_blank">霍比审核</a> | <a class="ae no" href="https://coincodecap.com/okex-margin-trading" rel="noopener ugc nofollow" target="_blank"> OKEx保证金交易</a> | <a class="ae no" href="https://coincodecap.com/futures-trading" rel="noopener ugc nofollow" target="_blank">期货交易</a></li><li id="4070" class="ld le ie jd b je lm ji ln jm lo jq lp ju lq jy li lj lk ll dt translated"><a class="ae no" href="https://coincodecap.com/coinbase-staking" rel="noopener ugc nofollow" target="_blank">比特币基地跑马圈地</a> | <a class="ae no" rel="noopener" href="/coinmonks/hotbit-review-cd5bec41dafb"> Hotbit评论</a> | <a class="ae no" href="https://coincodecap.com/kucoin-review" rel="noopener ugc nofollow" target="_blank"> KuCoin评论</a></li></ul></div></div>    
</body>
</html>