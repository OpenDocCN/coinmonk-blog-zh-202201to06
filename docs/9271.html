<html>
<head>
<title>Multi-tier NFTs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多层NFTs</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/multi-tier-nfts-5a5b693774ae?source=collection_archive---------0-----------------------#2022-06-24">https://medium.com/coinmonks/multi-tier-nfts-5a5b693774ae?source=collection_archive---------0-----------------------#2022-06-24</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="448d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您是否曾想过，是否有可能在同一个NFT项目中创建不同价格和象征性供应的层级？几周前，我和一些朋友正在为我们正在进行的一个基于公用事业的NFT项目集思广益。NFTs将作为我们服务的一种订阅，所以我们很快意识到拥有不同的层级将是有益的，就像你拥有不同的订阅级别一样。本质上，会有更多更便宜、更容易获得的代币，也会有更少的更稀有、更昂贵的代币。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff jo"><img src="../Images/8490dd26babcf1c70c78d3a7a3fa9eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*R8PIW7ZJ2r50Q17i8Mjdlg.png"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Tiers in a pyramid</figcaption></figure><p id="9aba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">每一层都有不同的价值，比如价格和供应量，从一开始就有效地“强化”了它们的稀有性。作为一个额外的要求，应该可以在任何时候从任何层铸造令牌，只需在契约调用中指定即可。</p><p id="c83b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这个想法与NFT项目中的传统做法相反，在传统项目中，所有代币通常有1个铸造价格，或者在铸造了X个代币后价格会发生变化的顺序定价结构。这最后一个例子有点类似，但仍然不同于我们试图实现的，因为事实上每一层只能在前一层完成后铸造。</p><p id="d16f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">作为一名开发人员，我立即开始思考这样的功能在代码中会是什么样子。我的直觉告诉我，构建这样一个智能合同应该很容易，可能已经有人这么做了。令我惊讶的是，我在网上找不到任何好的解决方案，所以我决定写我自己的，这就是我今天想与你分享的。</p><h1 id="2f72" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">智能合同</h1><p id="6b30" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">我用Solidity编写了smartcontract，因为它是最容易使用和广泛使用的区块链编程语言。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff ld"><img src="../Images/6d310bcd26bcb813f5bad8d69fc4ebac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*Do-s2IXv0cv9_gNIB-jHkQ.png"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Smartcontract definition and state variables</figcaption></figure><p id="5e9a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们首先指定solidity编译器版本，并导入NFT项目所需的两个基本接口，ERC721和Ownable。第一个状态变量<em class="le">saleisaictive</em>是一个布尔值，它只是指示这个智能合同的销售是否活跃，或者换句话说，是否允许人们制造NFT，没有什么新的。</p><p id="e495" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">有趣的部分开始于<strong class="is hu"> <em class="le">层</em> </strong>结构的定义，在这里我们将存储层特定的属性。每个<strong class="is hu"> <em class="le">层</em> </strong>将有:</p><ul class=""><li id="d7fb" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln dt translated"><strong class="is hu">价格:</strong>该层的价格</li><li id="3fac" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">总共制造了多少枚这一等级的代币</li><li id="6971" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">这一层可以铸造多少枚代币</li><li id="e334" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated"><strong class="is hu"> startingIndex </strong>:该层从哪个tokenID开始</li><li id="73f7" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated"><strong class="is hu"> mintsPerAddress </strong>:允许每个地址为该层制造多少个mints</li></ul><p id="c5aa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来，我们创建一个嵌套映射，其中我们将保存一个地址为特定层进行了多少次mints的信息。第一个索引将指向相应的层，第二个索引指向该层的地址的造币数。</p><p id="d4ec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来是另一个映射，<strong class="is hu">层，</strong>层，它将简单地保存我们刚刚描述的所有数据，并在<strong class="is hu">层进行索引。</strong></p><p id="8d09" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，我们有基本和令牌URI变量，这将允许我们将特定的URIs与每个令牌ID相关联。这些将指向分布式文件系统，如IPFS，它将保存该令牌的元数据。</p><p id="0684" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">那么我们的构造函数会是什么样子呢？</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff lt"><img src="../Images/aca6d5058a5c27b0f8233dc980ac11ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NTMwu-Y0ED1QnLS0U8XDBQ.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Constructor</figcaption></figure><p id="fae9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将名称和符号指定为构造函数中的参数，然后硬编码每个层，并将其添加到层映射中。对于这个示例项目，我们采用3层系统，其中</p><ol class=""><li id="21d6" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn ly ll lm ln dt translated">第0层的最大供应量为300，成本为0.42乙醚</li><li id="0ec8" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn ly ll lm ln dt translated">第1层的最大供应量为100，成本为0.6乙醚</li><li id="9b3d" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn ly ll lm ln dt translated">第二层的最大供应量是20，消耗0.9以太</li></ol><p id="059b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们现在准备检查mint函数。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff lz"><img src="../Images/d3901ee77d2aa707d74152772f1f9dec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*roifNyo8sGW13pwJGXVf-g.png"/></div></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Mint function</figcaption></figure><p id="cb45" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将遵循通常的<a class="ae ma" href="https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu">检查效果交互</strong> </a> <strong class="is hu"> </strong>模式<strong class="is hu"> </strong>因此我们首先断言mint函数的所有要求都已满足。在这种情况下，我们检查以下需求</p><ul class=""><li id="aeae" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln dt translated">销售活跃</li><li id="0f18" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">尚未达到最大供应等级</li><li id="1ab5" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">交易价值足以铸造该层</li><li id="a79e" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">进行交易的地址没有超过该层的每个地址的最大硬币数量。</li></ul><p id="9433" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">注意，这些需求都依赖于被指定为mint函数的参数的层。</p><p id="ca33" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">检查完成后，我们可以继续效果。我们根据指定层级的发件人地址更新薄荷糖的数量，并且我们还更新层级总供应量。在最后一步之前，我们将当前的总供应值保存在一个变量中，以便能够在<em class="le"> _safeMint </em>方法中指定tokenId，这将是我们唯一的交互。</p><h1 id="8cbe" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">试验</h1><p id="d590" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">为了确保我们的smartcontract满足我们的初始需求，我们可以用python编写一些测试。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/d10109d67f39240aa3c9aefdc6b44102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*mnO18SpcjrbP_Xqe6ANNTg.png"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Single mint test</figcaption></figure><p id="f7ab" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最基本的测试包括铸造一个令牌，并断言一些我们期望以后得到的值。我们从翻转销售状态开始，以确保销售是活动的。然后，我们通过提供0.42 ether从最低层创建一个令牌，正如在我们的构造函数中为第0层指定的那样。完成这些之后，我们可以对智能合同的状态有一些预期</p><ul class=""><li id="4e86" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln dt translated">自然，铸造1个代币的账户余额应该是1</li><li id="a92e" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">第0层的总供应量应为1，因为该层仅铸造了1个令牌</li><li id="f364" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">第1层和第2层的总供应量应为0，因为没有从这些层铸造令牌</li><li id="e6e5" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">最后，ID为0的令牌的所有者应该是刚刚从第0层生成令牌的同一帐户，因为我们指定该层应该从索引0开始</li></ul><blockquote class="mc md me"><p id="0497" class="iq ir le is b it iu iv iw ix iy iz ja mf jc jd je mg jg jh ji mh jk jl jm jn hm dt translated">交易新手？试试<a class="ae ma" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae ma" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote><p id="e055" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这很简单！现在是一个稍微复杂一点的测试，多个账户铸造多个代币</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff mi"><img src="../Images/e8208d168e60f8e401b2661b3bbecc9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*SuHAT2TsDiWZwvZN-Enfvg.png"/></div><figcaption class="jw jx fg fe ff jy jz bd b be z ek">Multiple mint test</figcaption></figure><p id="46ed" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这里，我们有一个帐户从第0层和第1层铸造令牌，而另一个帐户铸造第1层和第2层。同样，我们可以预期:</p><ul class=""><li id="a52f" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln dt translated">两个账户都应该有2英镑的余额，因为他们都铸造了2枚代币</li><li id="9e4d" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">第0层和第2层的总供应量应为1，而第1层的总供应量应为2</li><li id="c443" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">令牌id 0和300的所有者应该是帐户0，而id 301和400的所有者应该是帐户1。同样，这是基于构造函数中定义的起始索引</li></ul><p id="ed67" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">显然，这两个测试本身并不是决定性的，但很好地表明了我们的smartcontract的行为符合我们的设计。</p><h1 id="0def" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated"><strong class="ak">问题</strong></h1><p id="f112" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">在ERC721 smartcontract中设置层似乎确实很容易，但它也有两个主要缺点:</p><ul class=""><li id="ce63" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln dt translated">合同中的层级结构使得NFT项目不可能有通常的抽奖式抽奖。铸造代币的用户总是可以检查他们将要铸造的代币的id是什么，这样就没有了惊喜的成分。大多数项目中的随机性是通过在任意索引处开始造币厂而引入的，这在我们设计该合同的方式中是不可能的。</li><li id="172d" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">另一个缺点是，分层结构要求我们随时指定生成的令牌Id。这使得它与优化的NFT接口不兼容，如<a class="ae ma" href="https://www.erc721a.org/" rel="noopener ugc nofollow" target="_blank"> ERC721A </a>，因此铸造多个令牌的gas优化必须手动完成。</li></ul><p id="2235" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">感谢您花时间阅读我的帖子，我希望它在某些方面对您有用！如果你想查看完整的源代码，这里有一个资源库的链接:<a class="ae ma" href="https://github.com/filipkny/TieredNFT" rel="noopener ugc nofollow" target="_blank">https://github.com/filipkny/TieredNFT</a></p><p id="1cd1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你想在推特上关注我:<a class="ae ma" href="https://twitter.com/cryptowski1337" rel="noopener ugc nofollow" target="_blank">https://twitter.com/cryptowski1337</a></p></div></div>    
</body>
</html>