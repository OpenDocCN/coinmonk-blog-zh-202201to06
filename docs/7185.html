<html>
<head>
<title>Merkle Tree, a simple explanation and implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Merkle树，简单的解释和实现</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/merkle-tree-a-simple-explanation-and-implementation-48903442bc08?source=collection_archive---------2-----------------------#2022-05-21">https://medium.com/coinmonks/merkle-tree-a-simple-explanation-and-implementation-48903442bc08?source=collection_archive---------2-----------------------#2022-05-21</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><h1 id="8250" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">Merkle树，简单的解释和实现</h1><p id="070a" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">本文的目的是对Merkle树及其实现有一个基本但完整的理解。<br/>由于我找不到一篇以简单的方式介绍Merkle树创建、Merkle根、Merkle证明和验证实现的文章，我决定实现一个基本的解决方案，并用我的发现创建这篇文章，与社区分享。</p><h1 id="7cbd" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">Merkle树</h1><p id="0ee2" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">Merkle树是散列的树数据结构(通常是二叉树),其中每个叶节点包含数据块的散列(例如:区块链中的事务散列),每个父节点包含由其子节点的散列的串联和散列产生的散列。</p><p id="6c1f" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">该树用于以有效的方式验证和展示叶节点的散列是根节点的散列的一部分，因为我们只需要该树的一小组散列来执行该验证。</p><p id="90ef" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">这种数据结构通常用于分布式系统，如比特币和其他区块链，以一种轻量级、高效和快速的方式验证交易哈希是否属于块头的Merkle根。</p><p id="a19e" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">在比特币中使用Merkle Tree/Root/Proof允许实现简单支付验证(SPV)，这是轻量级客户端检查交易是否实际上是块的一部分的一种方式，而无需客户端下载整个块或整个区块链。<br/>通过仅拥有带有Merkle root的块头、它想要验证的交易以及从可信比特币节点获得的Merkle证明结构，它可以尝试重建Merkle root哈希并验证交易。</p><p id="20e5" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">Ralph Merkle在1979年申请了哈希树的专利，后来以他的名字命名。</p><blockquote class="kr ks kt"><p id="3015" class="jo jp ku jq b jr km jt ju jv kn jx jy kv ko kb kc kw kp kf kg kx kq kj kk kl hm dt translated">交易新手？尝试<a class="ae ky" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae ky" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote><p id="4c03" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated"><strong class="jq hu">Merkle树的例子</strong></p><p id="52ea" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">从哈希列表中:</p><pre class="kz la lb lc fq ld le lf lg aw lh dt"><span id="2401" class="li ir ht le b fv lj lk l ll lm">[95cd, 709b, 27ca, 1f3c, 41b6, a8c0, d20a, 281b, df74, 3e81, 3ebc]</span></pre><p id="f288" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">它的Merkle树应该是这样的:</p><figure class="kz la lb lc fq lo fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff ln"><img src="../Images/5f7064370ee2ec9b3136b3462324a9fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1bjRDU0LBR__tllJaEfyGA.jpeg"/></div></div></figure><p id="aa4a" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">(这4个字符的散列简称为长散列，即64个字符的散列，将在本文后面显示)</p><p id="3ecc" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">注意最后一个散列<code class="eh lv lw lx le b">3ebc</code>是如何被复制并添加到列表末尾的。这是需要的，以便能够将其与自身连接并散列它，因为我们成对散列，如果散列列表长度是奇数，那么我们复制它并将其添加到列表的末尾，以使散列列表是偶数。同样的情况也发生在<code class="eh lv lw lx le b">fcc1</code>身上。<br/>树的每一层被称为一个散列表。</p><p id="5ff1" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated"><strong class="jq hu">墨角根</strong></p><p id="f92a" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">Merkle根是树的根节点。在上面的例子中，它是带有<code class="eh lv lw lx le b"><strong class="jq hu">da07</strong></code>散列的节点。</p><p id="7f16" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated"><strong class="jq hu"> Merkle校样</strong></p><p id="57a6" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">Merkle证明(也称为Merkle路径)是这样一种结构，其保存了能够通过仅用该信息重新创建Merkle根来证明散列属于Merkle根所需的最少散列/树分支节点。</p><p id="029b" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">例如:</p><figure class="kz la lb lc fq lo fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff ly"><img src="../Images/80d74816e643d93a71c75719fe72e582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2njhwo1GT1OyeiDFynWqJw.jpeg"/></div></div></figure><p id="c431" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">如果我们有兴趣验证散列<code class="eh lv lw lx le b"><em class="ku">41b6</em></code>是否真的包含在Merkle根(<code class="eh lv lw lx le b"><strong class="jq hu">da07</strong></code>)中，那么我们只需要散列的颜色:</p><pre class="kz la lb lc fq ld le lf lg aw lh dt"><span id="5fc8" class="li ir ht le b fv lj lk l ll lm">[41b6, a8c0, 1013, b5fb, f94a]</span></pre><p id="5806" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">有了<code class="eh lv lw lx le b">41b6</code>，我们需要<code class="eh lv lw lx le b">a8c0</code>来重建<code class="eh lv lw lx le b">8fca</code>。<br/>有了<code class="eh lv lw lx le b">8fca</code>，我们需要<code class="eh lv lw lx le b">1013</code>来重构<code class="eh lv lw lx le b">87fd</code>。<br/>有了<code class="eh lv lw lx le b">87fd</code>，我们需要<code class="eh lv lw lx le b">b5fb</code>来重构<code class="eh lv lw lx le b">7460</code>。<br/>使用<code class="eh lv lw lx le b">7460</code>我们需要<code class="eh lv lw lx le b">f94a</code>来重建<code class="eh lv lw lx le b"><strong class="jq hu">da07</strong></code>，即Merkle根。</p><p id="b147" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">如果在将我们的散列(<code class="eh lv lw lx le b"><em class="ku">41b6</em></code>)应用于Merkle证明之后，我们得到了预期的<code class="eh lv lw lx le b"><strong class="jq hu">da07</strong></code> Merkle根，那么我们知道我们的散列是Merkle根的一部分。</p><p id="015a" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">在这种情况下，对于11个散列，我们只需要4个散列，以及我们的散列<code class="eh lv lw lx le b"><em class="ku">41b6</em></code>就能够重建Merkle根<code class="eh lv lw lx le b"><strong class="jq hu">da07</strong></code>。</p><p id="b22f" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">有了这些信息，我们注意到一个模式，我们可以确定我们只需要大约log(n)个散列就能够检查一个散列是否属于某个Merkle根，这是非常有效的，而不是必须对它们全部进行散列或者让所有的散列来验证这一点。</p><p id="bb00" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">例如，如果比特币中的一个块有大约1000次交易，我们只需要从一个可信的比特币节点检索大约10次交易散列的Merkle证明，而不是具有1000次交易的整个块。</p><p id="c601" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">当我们在散列之前创建和使用Merkle证明时，我们需要记住散列的连接顺序:</p><figure class="kz la lb lc fq lo fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff ly"><img src="../Images/80d74816e643d93a71c75719fe72e582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2njhwo1GT1OyeiDFynWqJw.jpeg"/></div></div></figure><p id="dc5d" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated"><code class="eh lv lw lx le b"><em class="ku">41b6</em></code>需要与<code class="eh lv lw lx le b">a8c0</code>串接，<code class="eh lv lw lx le b">41b6</code>在左侧，<code class="eh lv lw lx le b">a8c0</code>在右侧:</p><figure class="kz la lb lc fq lo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="330c" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">因为<code class="eh lv lw lx le b">41b6</code>是左孩子，<code class="eh lv lw lx le b">a8c0</code>是右孩子。</p><p id="eee7" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">从先前的连接和散列得到的散列<code class="eh lv lw lx le b">8fca</code>需要与<code class="eh lv lw lx le b">1013</code>、<code class="eh lv lw lx le b">8fca</code>连接，在左侧，<code class="eh lv lw lx le b">1013</code>在右侧，因为<code class="eh lv lw lx le b">8fca</code>是左孩子，<code class="eh lv lw lx le b">1013</code>是右孩子。</p><p id="6908" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">由于<code class="eh lv lw lx le b">87fd</code>是一个右孩子而<code class="eh lv lw lx le b">b5fb</code>是一个左孩子，所以从先前的连接和散列得到的散列<code class="eh lv lw lx le b">87fd</code>需要与<code class="eh lv lw lx le b">b5fb</code>连接，其中<code class="eh lv lw lx le b">87fd</code>在右侧而<code class="eh lv lw lx le b">b5fb</code>在左侧。</p><p id="9913" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">由于<code class="eh lv lw lx le b">7460</code>是一个左孩子而<code class="eh lv lw lx le b">f94a</code>是一个右孩子，所以从之前的连接和散列得到的散列<code class="eh lv lw lx le b">7460</code>需要与<code class="eh lv lw lx le b">f94a</code>连接，<code class="eh lv lw lx le b">7460</code>在左侧，<code class="eh lv lw lx le b">f94a</code>在右侧。</p><p id="0e6a" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">我们需要在Merkle证明结构中指定每个节点散列应该连接的方向:</p><figure class="kz la lb lc fq lo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="0063" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">连接顺序如下:</p><pre class="kz la lb lc fq ld le lf lg aw lh dt"><span id="6674" class="li ir ht le b fv lj lk l ll lm">41b6 + a8c0 =&gt; <!-- -->8fca<br/>8fca + 1013 =&gt; 87fd<br/>b5fb + 87fd =&gt; 7460<br/>7460 + f94a =&gt; <strong class="le hu">da07</strong></span></pre><p id="196a" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">有了这个，我们的Merkle证明是完整的，并准备转移和使用。</p><h1 id="d979" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">基本实现</h1><p id="109d" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">像比特币一样的区块链使用Merkle树来检查交易是否属于块头中的Merkle根。每个使用Merkle树结构的软件都可以自由地使用他们认为合适的任何实现。</p><p id="e9df" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">例如，比特币在散列之前，首先将串联散列转换为二进制。<br/>比特币也使用双sha256哈希，类似于:</p><figure class="kz la lb lc fq lo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="238e" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">我们将使我们的实现尽可能简单，只是试图容易地看到和理解这个概念，只是最低限度的。</p><p id="f868" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">我们的实现将在nodejs中。</p><p id="f768" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">我们将使用<code class="eh lv lw lx le b">sha256</code>来散列我们的散列的连接。因此，我们将有64个字符哈希。</p><p id="7f2d" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">每个函数都有一些文档来帮助阐明它做什么。</p><p id="a263" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">你可以在这里找到完整的代码<a class="ae ky" href="https://github.com/jeremythen/simple-merkle-tree-implementation/blob/main/index.js" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="9cd7" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">首先，我们导入<code class="eh lv lw lx le b">crypto</code>模块:</p><figure class="kz la lb lc fq lo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="60d0" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">定义几个方向常数:</p><figure class="kz la lb lc fq lo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="31bf" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">定义要使用的随机sha256哈希列表:</p><figure class="kz la lb lc fq lo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="cecc" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">定义一个实用函数来帮助我们用加密模块抽象sha256哈希:</p><figure class="kz la lb lc fq lo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="f4aa" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">定义一个效用函数来计算叶节点是左子节点还是右子节点:</p><figure class="kz la lb lc fq lo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="8914" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">定义一个实用函数来检查哈希列表的长度是否为奇数，如果是，复制最后一个哈希并将其添加到哈希列表的末尾:</p><figure class="kz la lb lc fq lo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="dcf8" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">定义将接收散列列表并递归计算和返回Merkle根的函数:</p><figure class="kz la lb lc fq lo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="aa5b" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">我们可以通过使用哈希列表调用<code class="eh lv lw lx le b">generateMerkleRoot</code>来测试这段代码:</p><figure class="kz la lb lc fq lo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="1f62" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">这将打印:</p><pre class="kz la lb lc fq ld le lf lg aw lh dt"><span id="2462" class="li ir ht le b fv lj lk l ll lm">merkleRoot: 68e6cdf0cae7fb8eef39cc899c8882e34dd1727a2d08f2303811886949c539e6</span></pre><p id="a9e8" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">现在让我们生成Merkle树:</p><figure class="kz la lb lc fq lo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="c705" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">我们可以通过使用哈希函数调用这个函数来尝试一下:</p><figure class="kz la lb lc fq lo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="2f27" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">这将长类似于:</p><figure class="kz la lb lc fq lo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="a783" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">现在让我们生成Merkle证明结构:</p><figure class="kz la lb lc fq lo"><div class="bz el l di"><div class="lz ma l"/></div></figure><figure class="kz la lb lc fq lo fe ff paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="fe ff mb"><img src="../Images/54e36367fa9545db7a21812c87f5e6b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Pl5Rfi6aZxgqHpJP53ZxQ.jpeg"/></div></div></figure><p id="c936" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">例如，如果我们想找到<code class="eh lv lw lx le b">41b6</code>的父节点，我们首先需要知道它的索引。我们知道<code class="eh lv lw lx le b">41b6</code>的指数是4，所以如果除以4 / 2，对结果进行四舍五入，就可以求出它的父代:4 / 2 = &gt; 2。所以，2在下一级<code class="eh lv lw lx le b">41b6</code>的父节点的索引中。</p><p id="6b52" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">如果我们想找到<code class="eh lv lw lx le b">a8c0</code>的父节点，我们做同样的事情。它的索引是5，所以5 / 2 = &gt; 2(用Math.floor向下舍入)。然后我们看到<code class="eh lv lw lx le b">41b6</code>和<code class="eh lv lw lx le b">a8c0</code>共享同一个父节点。</p><p id="e5f4" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">这同样适用于查找树中任何节点的所有父节点，但根节点除外，因为它没有父节点。</p><p id="13a4" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">让我们用一个散列和散列列表来调用函数:</p><figure class="kz la lb lc fq lo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="f3e5" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">它记录了:</p><figure class="kz la lb lc fq lo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="4f8c" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">现在，让我们添加一个函数，通过从Merkle证明结构重建Merkle根来验证散列是否是Merkle根的一部分:</p><figure class="kz la lb lc fq lo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="a847" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">让我们调用它，并对照我们期望的Merkle根检查它的结果:</p><figure class="kz la lb lc fq lo"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="0be0" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">这将记录:</p><pre class="kz la lb lc fq ld le lf lg aw lh dt"><span id="1b87" class="li ir ht le b fv lj lk l ll lm">merkleRootFromMerkleProof:  68e6cdf0cae7fb8eef39cc899c8882e34dd1727a2d08f2303811886949c539e6<br/>merkleRootFromMerkleProof === merkleRoot:  true</span></pre><p id="b622" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">很好。</p><p id="052e" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">点击此处查看完整代码:</p><div class="mc md fm fo me mf"><a href="https://github.com/jeremythen/simple-merkle-tree-implementation/blob/main/index.js" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab ej"><div class="mh ab mi cl cj mj"><h2 class="bd hu fv z el mk eo ep ml er et hs dt translated">main Jeremy then/simple-merkle-tree-implementation/index . js</h2><div class="mm l"><h3 class="bd b fv z el mk eo ep ml er et ek translated">此文件包含双向Unicode文本，其解释或编译可能与下面显示的不同…</h3></div><div class="mn l"><p class="bd b gc z el mk eo ep ml er et ek translated">github.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt lt mf"/></div></div></a></div><p id="78a4" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">更多区块链相关话题请关注我。</p><p id="5592" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated">参考资料:</p><p id="3896" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hm dt translated"><a class="ae ky" href="https://learnmeabitcoin.com/technical/merkle-root" rel="noopener ugc nofollow" target="_blank">https://learnmeabitcoin.com/technical/merkle-root</a>T9<a class="ae ky" href="https://en.wikipedia.org/wiki/Merkle_tree" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Merkle_tree</a></p></div></div>    
</body>
</html>