<html>
<head>
<title>Under the Hood with Solidity Reference Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有实度参考类型的引擎盖下</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/under-the-hood-with-solidity-reference-types-16b3e4e3559f?source=collection_archive---------11-----------------------#2022-03-03">https://medium.com/coinmonks/under-the-hood-with-solidity-reference-types-16b3e4e3559f?source=collection_archive---------11-----------------------#2022-03-03</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/2bcb8ddcab4c8f68c4c8d219ec3d8bf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GCSJeasnV8chLiJid15z3w.jpeg"/></div></div></figure><p id="14f9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">引用类型…这到底是什么意思？😏</p><p id="730e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">引用类型是一个代码对象，它不直接存储在创建它的地方，而是充当一种指向存储在其他地方的值的指针。</p><p id="e636" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们从不同的角度来看它，称它为<strong class="jd hu"> <em class="jz">别名</em> </strong>，这只是你引用你正在创建引用的对象的另一个名字。</p><p id="7c14" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一个非常贴切的例子是你给朋友起的昵称。这个人还是老样子，只是名字不同。</p><p id="e49d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在Solidity中，与我们在上一篇关于值类型的<a class="ae ka" rel="noopener" href="/@sandraifeoma22/the-nitty-gritty-of-value-types-in-solidity-9f557f146ebc">文章中讨论的值类型存储自己的数据不同，引用类型不直接将数据存储到变量中，而是存储数据的位置。引用类型的值可以通过多个不同的名称来修改。当使用引用类型时，我们总是必须明确地提供数据区域或<strong class="jd hu">数据位置，也就是存储类型的地方。</strong></a></p><p id="229c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> <em class="jz">数据位置… </em> </strong></p><p id="0c52" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以在3个数据位置存储引用类型:</p><ul class=""><li id="df91" class="kb kc ht jd b je jf ji jj jm kd jq ke ju kf jy kg kh ki kj dt translated"><code class="eh kk kl km kn b">memory </code> —其生存期仅限于外部函数调用</li><li id="1ca9" class="kb kc ht jd b je ko ji kp jm kq jq kr ju ks jy kg kh ki kj dt translated"><code class="eh kk kl km kn b">storage </code> —存储状态变量的位置，有效期限于合同的有效期</li><li id="a79e" class="kb kc ht jd b je ko ji kp jm kq jq kr ju ks jy kg kh ki kj dt translated"><code class="eh kk kl km kn b">calldata </code> —是一个特殊的数据位置，不可修改，不持久，包含函数参数。它有类似于<code class="eh kk kl km kn b">memory</code>的行为模式</li></ul><p id="3da4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">solidity中的参照类型包括以下内容:</p><ul class=""><li id="432e" class="kb kc ht jd b je jf ji jj jm kd jq ke ju kf jy kg kh ki kj dt translated">数组</li><li id="1fc6" class="kb kc ht jd b je ko ji kp jm kq jq kr ju ks jy kg kh ki kj dt translated">结构</li><li id="b8ed" class="kb kc ht jd b je ko ji kp jm kq jq kr ju ks jy kg kh ki kj dt translated">映射</li></ul><p id="dac9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> <em class="jz">阵列</em> … </strong></p><p id="c90b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">数组是一个容器，包含一组相同数据类型的元素，如整数或字符串。数组的每个元素都有一个称为索引的特定位置，可以用。数组有不同的大小:</p><ul class=""><li id="eba9" class="kb kc ht jd b je jf ji jj jm kd jq ke ju kf jy kg kh ki kj dt translated">固定大小的数组</li><li id="7a38" class="kb kc ht jd b je ko ji kp jm kq jq kr ju ks jy kg kh ki kj dt translated">动态数组</li></ul><p id="20d2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">固定大小数组</strong>是在创建和/或分配数组时确定其大小或长度的数组。例如，一个固定大小的数组<code class="eh kk kl km kn b">5 </code>和元素类型<code class="eh kk kl km kn b">uint </code>被写成，</p><pre class="kt ku kv kw fq kx kn ky kz aw la dt"><span id="9e2f" class="lb lc ht kn b fv ld le l lf lg">uint[5] myFixedArray;</span></pre><p id="151c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">动态数组</strong>是一种随机存取、可变大小的列表数据结构，允许添加或删除元素。动态数组的大小不是在声明时预先确定的。例如，动态大小的数组被写成，</p><pre class="kt ku kv kw fq kx kn ky kz aw la dt"><span id="ffde" class="lb lc ht kn b fv ld le l lf lg">uint[] myDynamicArray;</span></pre><p id="f037" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们还应该提到一些特殊的数组，它们是<code class="eh kk kl km kn b">bytes </code>和<code class="eh kk kl km kn b">strings</code>。<code class="eh kk kl km kn b">bytes</code>类型类似于<code class="eh kk kl km kn b">bytes1[]</code>，但是它被紧密地打包在调用数据和内存中。<code class="eh kk kl km kn b">string</code>等于<code class="eh kk kl km kn b">bytes</code>，但不允许长度或索引访问。一般来说，使用<code class="eh kk kl km kn b">bytes</code>表示任意长度的原始字节数据，使用<code class="eh kk kl km kn b">string</code>表示任意长度的字符串(UTF-8)数据。如果可以将长度限制在一定的字节数，那么总是使用值类型<code class="eh kk kl km kn b">bytes1</code>到<code class="eh kk kl km kn b">bytes32</code>中的一种，因为它们便宜得多。</p><p id="d0e3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="jz">现在让我们了解一些数组成员</em> …</p><ul class=""><li id="7cca" class="kb kc ht jd b je jf ji jj jm kd jq ke ju kf jy kg kh ki kj dt translated"><code class="eh kk kl km kn b">length</code>-<code class="eh kk kl km kn b">length</code>成员用于获取数组中元素的数量。对于内存数组，长度是固定的和动态的，这意味着一旦创建了内存数组，它就可以依赖于运行时参数。</li><li id="2ed3" class="kb kc ht jd b je ko ji kp jm kq jq kr ju ks jy kg kh ki kj dt translated"><code class="eh kk kl km kn b">push</code> -在动态存储数组和字节(非字符串)的末尾追加一个元素。新添加的元素是零初始化的。</li><li id="5ebc" class="kb kc ht jd b je ko ji kp jm kq jq kr ju ks jy kg kh ki kj dt translated"><code class="eh kk kl km kn b">pop</code>删除动态存储数组末尾的元素和字节(不是字符串)。</li></ul><p id="c300" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="jz">好的</em>😀<em class="jz">…关于数组的信息已经足够了。你可以在</em>  <em class="jz">这里了解更多关于solidity </em> <a class="ae ka" href="https://docs.soliditylang.org/en/v0.8.11/types.html" rel="noopener ugc nofollow" target="_blank"> <em class="jz">中的数组。让我们来了解一下什么是结构😎🎯<em class="jz"> … </em></em></a></p><p id="eeda" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> <em class="jz">结构</em> … </strong></p><p id="dccc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一般来说，structs用来表示某个东西的记录。在可靠性方面，structs允许用户以结构的形式创建自己的数据类型。它们用于将相关数据分组在一起。结构可以包含值类型和引用类型，但不能包含自身类型的成员。</p><p id="45b3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">例如，假设您想要跟踪您的朋友，您可能想要跟踪以下属性:</p><ul class=""><li id="67ac" class="kb kc ht jd b je jf ji jj jm kd jq ke ju kf jy kg kh ki kj dt translated">名字</li><li id="4c97" class="kb kc ht jd b je ko ji kp jm kq jq kr ju ks jy kg kh ki kj dt translated">年龄</li><li id="d479" class="kb kc ht jd b je ko ji kp jm kq jq kr ju ks jy kg kh ki kj dt translated">电子邮件</li><li id="22d5" class="kb kc ht jd b je ko ji kp jm kq jq kr ju ks jy kg kh ki kj dt translated">工作</li></ul><p id="6242" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以用这样的结构来表示朋友的记录，</p><pre class="kt ku kv kw fq kx kn ky kz aw la dt"><span id="39e2" class="lb lc ht kn b fv ld le l lf lg">struct Friend {</span><span id="255c" class="lb lc ht kn b fv lh le l lf lg">     string name;</span><span id="c5b1" class="lb lc ht kn b fv lh le l lf lg">     uint256 age;</span><span id="3e38" class="lb lc ht kn b fv lh le l lf lg">     string email;</span><span id="2507" class="lb lc ht kn b fv lh le l lf lg">     string job;</span><span id="4cc4" class="lb lc ht kn b fv lh le l lf lg">}</span></pre><p id="b4b1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这里有一个简单的合同来获取一个朋友的记录，</p><figure class="kt ku kv kw fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff li"><img src="../Images/a87820bccc91c40ac1eb15b6bd83cb88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xVEbpPiN3j0RtW0g8JELMQ.png"/></div></div></figure><p id="e690" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们先睹为快...</p><p id="8333" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> <em class="jz">映射… </em> </strong></p><p id="accd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">映射用于以键值对格式存储数据或信息。<code class="eh kk kl km kn b"><strong class="jd hu">key type</strong></code>可以是任何内置类型、字节、字符串或任何契约或枚举类型，但不能是引用类型。<code class="eh kk kl km kn b"><strong class="jd hu">value type</strong></code>可以是任何类型，包括引用类型，如映射、数组和结构。</p><p id="317c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">关于映射，我们需要注意一些事情..</p><ul class=""><li id="1ac6" class="kb kc ht jd b je jf ji jj jm kd jq ke ju kf jy kg kh ki kj dt translated">存储是映射可以拥有的唯一数据位置。</li><li id="458a" class="kb kc ht jd b je ko ji kp jm kq jq kr ju ks jy kg kh ki kj dt translated">状态变量允许映射为函数中的存储引用类型。</li><li id="a281" class="kb kc ht jd b je ko ji kp jm kq jq kr ju ks jy kg kh ki kj dt translated">映射没有设置键或值的概念，也没有长度。</li><li id="8cd3" class="kb kc ht jd b je ko ji kp jm kq jq kr ju ks jy kg kh ki kj dt translated">映射通常用于将唯一的以太坊地址链接到相关联的值类型</li></ul><p id="acc0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">映射类型的变量可以声明为，</p><pre class="kt ku kv kw fq kx kn ky kz aw la dt"><span id="5d9f" class="lb lc ht kn b fv ld le l lf lg">mapping(_KeyType =&gt; _ValueType) _VariableName</span></pre><p id="56ba" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">用实际变量名、键类型和值类型声明映射变量的一个更明确的例子是这样写的:</p><pre class="kt ku kv kw fq kx kn ky kz aw la dt"><span id="40e5" class="lb lc ht kn b fv ld le l lf lg">mapping(address =&gt; uint) public myBalances;</span></pre><p id="825f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在下面使用映射存储和接收用户信息的例子中，我们可以看看映射是如何工作的:</p><figure class="kt ku kv kw fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lj"><img src="../Images/325f057dbef6241a5c778e2288031bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-2C4SkGqUG1oK3tUt-peg.png"/></div></div></figure><p id="eeb6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kk kl km kn b">MappingExample</code>契约定义了一个公共<code class="eh kk kl km kn b">myBalances </code>映射，键类型为<code class="eh kk kl km kn b">address</code>，值类型为<code class="eh kk kl km kn b">uint</code>，将以太坊地址映射为一个无符号整数值，我们检索了存储在地址键上的余额值。</p><p id="2157" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">结论</strong>:</p><p id="bce0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这篇文章中，我们学习了solidity中不同的引用类型，如数组、结构和映射。</p><p id="3942" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">按键参考</strong></p><p id="84e3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><a class="ae ka" href="https://docs.soliditylang.org/en/v0.8.11/types.html" rel="noopener ugc nofollow" target="_blank">https://docs.soliditylang.org/en/v0.8.11/types.html</a></p></div></div>    
</body>
</html>