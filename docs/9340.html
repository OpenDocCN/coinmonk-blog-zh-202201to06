<html>
<head>
<title>Learning Solidity (Everything You Need To Know)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习可靠性(你需要知道的一切)</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/730d-solidity-language-q2-2022-ea968098179?source=collection_archive---------8-----------------------#2022-06-25">https://medium.com/coinmonks/730d-solidity-language-q2-2022-ea968098179?source=collection_archive---------8-----------------------#2022-06-25</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="c91e" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">Solidity编程语言介绍</h2></div><h2 id="d71d" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">#计算机科学#区块链#以太坊#可靠性</h2><figure class="kh ki kj kk fq kl fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff kg"><img src="../Images/8acdd459def539ae33c4e2f3f304438e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XMALxoWpPfd03LIq"/></div></div><figcaption class="ks kt fg fe ff ku kv bd b be z ek">Photo by <a class="ae kw" href="https://unsplash.com/@urielsc26?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Uriel SC</a> on <a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl kx ky hb kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hm hn ho hp hq"><h1 id="3334" class="le jj ht bd jk lf lg lh jo li lj lk js iz ll ja jw jc lm jd ka jf ln jg ke lo dt translated">介绍</h1><p id="630c" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated"><strong class="lr hu"> Solidity </strong>是一个<strong class="lr hu">面向对象</strong>、<strong class="lr hu">静态类型</strong>、<strong class="lr hu">高级语言</strong>，用于在<strong class="lr hu"> EVM </strong>(以太坊虚拟机)内实现<strong class="lr hu">智能合约</strong>。在其特性中，支持<strong class="lr hu">继承</strong>、<strong class="lr hu"> ABI </strong>(应用二进制接口)<strong class="lr hu">基础库</strong>、&amp; <strong class="lr hu">复杂类型</strong>。</p><h1 id="4997" class="le jj ht bd jk lf mi lh jo li mj lk js iz mk ja jw jc ml jd ka jf mm jg ke lo dt translated">杂注</h1><p id="f9b7" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated"><code class="eh mn mo mp mq b">pragma</code>关键字用于通知编译器solidity文件的<strong class="lr hu">版本要求</strong>。因为这个指令是本地的，所以用solidity编写的每个文件都必须声明自己的pragma语句。</p><pre class="kh ki kj kk fq mr mq ms mt aw mu dt"><span id="b5a2" class="ji jj ht mq b fv mv mw l mx my">pragma solidity ^X.X.X;</span></pre><h1 id="ce37" class="le jj ht bd jk lf mi lh jo li mj lk js iz mk ja jw jc ml jd ka jf mm jg ke lo dt translated">进口</h1><p id="d4c0" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated"><code class="eh mn mo mp mq b">import</code>关键字用于<strong class="lr hu">导入报表</strong>。这将指定的<code class="eh mn mo mp mq b">filepath</code>中的所有全局符号导入到当前的全局范围中。</p><p id="80ea" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">还可以使用一个<code class="eh mn mo mp mq b">symbolName</code>来引用这些导入的元素，而不会挤占名称空间。</p><pre class="kh ki kj kk fq mr mq ms mt aw mu dt"><span id="0c76" class="ji jj ht mq b fv mv mw l mx my">import "filename" as symbolName;</span></pre><h1 id="0b8e" class="le jj ht bd jk lf mi lh jo li mj lk js iz mk ja jw jc ml jd ka jf mm jg ke lo dt translated">契约</h1><p id="c344" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated">可靠性<strong class="lr hu">契约</strong>类似于面向对象语言中的<strong class="lr hu">类</strong>。</p><p id="8c74" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><code class="eh mn mo mp mq b">contract</code>关键字用于声明合同。</p><p id="a2dd" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">契约可以声明<strong class="lr hu">状态变量</strong>，<strong class="lr hu">函数</strong>，<strong class="lr hu">函数修饰符</strong>，<strong class="lr hu">事件</strong>，<strong class="lr hu">错误</strong>，<strong class="lr hu">结构类型</strong>和<strong class="lr hu">枚举类型</strong>。它们还可以有一个<strong class="lr hu">构造函数</strong>，这个函数只被调用一次<strong class="lr hu"/>:当契约最初被保存到EVM中时。</p><p id="6ae6" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">下面是合同的基本结构</p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="nf ng l"/></div></figure><h1 id="90fb" class="le jj ht bd jk lf mi lh jo li mj lk js iz mk ja jw jc ml jd ka jf mm jg ke lo dt translated">遗产</h1><p id="fdd5" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated">Solidity通过<strong class="lr hu">多重继承</strong>支持<strong class="lr hu">多态</strong>，允许契约从<strong class="lr hu">基础契约</strong>和** <strong class="lr hu">接口</strong>继承可见成员。</p><p id="a754" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><code class="eh mn mo mp mq b">is</code>关键字用于声明继承，从最基本到最派生列出。</p><p id="b43b" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">基本构造函数按照<strong class="lr hu">线性化规则</strong>执行，并要求<strong class="lr hu">继承契约满足其参数</strong>。这些构造函数可以在继承列表中调用，或者作为构造函数中的修饰符。</p><p id="ad09" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><em class="ne">这里有一个多基数的合同:</em></p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="nf ng l"/></div></figure><p id="f5f2" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><code class="eh mn mo mp mq b">super</code>关键字可以用于<strong class="lr hu">以<strong class="lr hu">非声明</strong>的方式访问继承的成员</strong>。</p><p id="f9f1" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">当用于调用函数时，编译器将按照与声明相反的顺序在继承的契约链中搜索匹配的函数签名。</p><p id="d966" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><em class="ne">这里有一个使用超级清理的函数:</em></p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="nf ng l"/></div></figure><h1 id="c2b1" class="le jj ht bd jk lf mi lh jo li mj lk js iz mk ja jw jc ml jd ka jf mm jg ke lo dt translated">摘要</h1><p id="d72e" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated">Solidity支持抽象，允许创建抽象契约。</p><p id="8034" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><code class="eh mn mo mp mq b">abstract</code>关键字用于声明<strong class="lr hu">抽象契约</strong>。</p><p id="77ac" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">如果一个契约<strong class="lr hu">声明或继承了一个未实现的函数</strong>，以及如果它<strong class="lr hu">不满足其基础构造函数</strong>，则该契约需要被<strong class="lr hu">标记为抽象的</strong>。</p><p id="7c13" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><em class="ne">这里是一个抽象契约，有一个未实现的功能:</em></p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="nf ng l"/></div></figure><h1 id="ece9" class="le jj ht bd jk lf mi lh jo li mj lk js iz mk ja jw jc ml jd ka jf mm jg ke lo dt translated">功能</h1><p id="8c21" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated">坚固性支持标准功能。</p><p id="60fd" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><code class="eh mn mo mp mq b">function</code>关键字用于声明函数。</p><p id="7e98" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><em class="ne">下面是函数的基本结构:</em></p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="nf ng l"/></div></figure><p id="d1c5" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">Solidity支持函数<strong class="lr hu">重载</strong>，但是由于<strong class="lr hu"> ABI编码器</strong>的原因，应该小心外部函数类型。</p><h1 id="ddbf" class="le jj ht bd jk lf mi lh jo li mj lk js iz mk ja jw jc ml jd ka jf mm jg ke lo dt translated">最重要的</h1><p id="4067" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated">坚固性支持<strong class="lr hu">覆盖</strong>，这是<strong class="lr hu">多态</strong>的一个特性。</p><p id="6221" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><code class="eh mn mo mp mq b">virtual</code> &amp; <code class="eh mn mo mp mq b">override</code>关键字是<strong class="lr hu">可覆盖&amp;被覆盖函数</strong>各自的标签。</p><p id="3966" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">覆盖函数只能改变<code class="eh mn mo mp mq b">external</code> - &gt; <code class="eh mn mo mp mq b">public</code>的可见性修饰符，而可变性只能改变更严格的修饰符(<code class="eh mn mo mp mq b">nonpayable</code>-&gt;-<code class="eh mn mo mp mq b">view</code>-&gt;<code class="eh mn mo mp mq b">pure</code>)。</p><p id="8f51" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">对于多重继承，重写函数的最派生的基协定必须显式重写具有相同函数签名的所有父协定。此外，如果一个契约从多个(不相关的)基础继承了相同的功能，则适用相同的要求。</p><p id="2a8c" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><em class="ne">下面是一个被覆盖函数的例子:</em></p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="nf ng l"/></div></figure><h1 id="6e31" class="le jj ht bd jk lf mi lh jo li mj lk js iz mk ja jw jc ml jd ka jf mm jg ke lo dt translated">支付功能</h1><p id="7c24" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated">一个契约最多可以有一个receive函数，使用<code class="eh mn mo mp mq b">receive() external payable { … }</code>声明(没有<code class="eh mn mo mp mq b">function</code>关键字)。这个函数不能有参数，不能返回任何东西，必须有<code class="eh mn mo mp mq b">external</code>可见性和<code class="eh mn mo mp mq b">payable</code>状态可变性。它可以是虚拟的，可以重写，可以有修饰符。</p><blockquote class="nh ni nj"><p id="2647" class="lp lq ne lr b ls mz iu lu lv na ix lx nk nb lz ma nl nc mc md nm nd mf mg mh hm dt translated"><strong class="lr hu"> ⚠️Warning: </strong>接收功能只能依靠2300气体</p></blockquote><h1 id="089e" class="le jj ht bd jk lf mi lh jo li mj lk js iz mk ja jw jc ml jd ka jf mm jg ke lo dt translated">后备功能</h1><p id="c013" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated">一个契约最多可以有一个使用<code class="eh mn mo mp mq b">fallback () external payable</code>或<code class="eh mn mo mp mq b">fallback (bytes calldata _input) external payable returns (bytes memory _output)</code>声明的<code class="eh mn mo mp mq b">fallback</code>函数(两者都没有<code class="eh mn mo mp mq b">function</code>关键字)。该功能必须具有<code class="eh mn mo mp mq b">external</code>可见性。它也可以是虚拟的，可以重写并可以有修饰符。</p><blockquote class="nh ni nj"><p id="de1a" class="lp lq ne lr b ls mz iu lu lv na ix lx nk nb lz ma nl nc mc md nm nd mf mg mh hm dt translated"><strong class="lr hu"> ⚠️Warning: </strong>这个回退功能只能依靠2300气</p></blockquote><p id="84e1" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><strong class="lr hu">功能修饰符</strong></p><p id="6320" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">Solidity支持<strong class="lr hu">修饰符</strong>，允许以声明方式改变函数的行为。它们类似于面向对象编程中的<strong class="lr hu">装饰模式</strong>。</p><p id="d912" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><code class="eh mn mo mp mq b">modify</code>关键字用于声明一个<strong class="lr hu">函数修饰符</strong>。</p><p id="0a3c" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">符号用于引用函数体，允许修饰符在可执行代码中包装函数。</p><p id="8c49" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><em class="ne">下面是修饰语的基本结构:</em></p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="nf ng l"/></div></figure><p id="52fb" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><em class="ne">下面是一个使用modifies的函数:</em></p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="nf ng l"/></div></figure><p id="9be4" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">修饰符可以通过遵循与函数重写相同的规则来重写。</p><h1 id="fb40" class="le jj ht bd jk lf mi lh jo li mj lk js iz mk ja jw jc ml jd ka jf mm jg ke lo dt translated">接口</h1><p id="80be" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated">坚固性支持<strong class="lr hu">接口</strong>。接口可以保存<strong class="lr hu">函数签名</strong>、<strong class="lr hu">结构类型</strong>、&amp;、<strong class="lr hu">枚举类型</strong>。</p><p id="bd9a" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><code class="eh mn mo mp mq b">interface</code>关键字用于声明一个接口。</p><p id="afdb" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">接口内声明的所有函数必须是<code class="eh mn mo mp mq b">external</code>。</p><p id="9094" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">默认情况下，所有函数都被隐式标记为<code class="eh mn mo mp mq b">virtual</code>，首次实现时不需要显式的<code class="eh mn mo mp mq b">override</code>。</p><p id="f335" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><em class="ne">这是一个界面的基本结构:</em></p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="nf ng l"/></div></figure><p id="6272" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">通过遵循与协定继承相同的规则，接口可以从其他接口继承。</p><h1 id="6b88" class="le jj ht bd jk lf mi lh jo li mj lk js iz mk ja jw jc ml jd ka jf mm jg ke lo dt translated">结构体</h1><p id="1335" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated">坚固性提供了一种将<strong class="lr hu">复合类型</strong>定义为<strong class="lr hu">定制类型</strong>的方法。</p><p id="bec7" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><code class="eh mn mo mp mq b">struct</code>关键字用于声明一个结构。</p><p id="cdc7" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">复杂类型中对结构类型的所有局部引用都必须标记为<code class="eh mn mo mp mq b">storage</code>。这存储了一个引用，该引用允许将结构成员赋值保持为状态。</p><p id="30a7" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><em class="ne">这里是一个struct的基本结构:</em></p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="nf ng l"/></div></figure><h1 id="b2d2" class="le jj ht bd jk lf mi lh jo li mj lk js iz mk ja jw jc ml jd ka jf mm jg ke lo dt translated">事件</h1><p id="f352" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated">Solidity通过事件支持<strong class="lr hu">日志</strong>。所有<strong class="lr hu">发出的事件</strong>都存储在区块链内的<strong class="lr hu">事务日志</strong>中。</p><p id="3ddf" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><code class="eh mn mo mp mq b">event</code> &amp; <code class="eh mn mo mp mq b">emit</code>关键字分别用于<strong class="lr hu">声明事件和</strong>发出事件。</p><p id="af0b" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><code class="eh mn mo mp mq b">index</code>关键字允许用主题记录事件<strong class="lr hu">。所有不带index属性的参数都作为日志数据的一部分进行ABI编码。</strong></p><p id="ab40" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">默认情况下，事件的签名被散列化并成为一个主题。这可以通过用关键字<code class="eh mn mo mp mq b">anonymous</code>声明事件来防止。匿名事件能够索引四个参数，而不是三个。</p><blockquote class="nh ni nj"><p id="2add" class="lp lq ne lr b ls mz iu lu lv na ix lx nk nb lz ma nl nc mc md nm nd mf mg mh hm dt translated"><strong class="lr hu"> ✏️指出:</strong>事件的成本与数据量成线性比例。</p></blockquote><p id="1223" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><em class="ne">下面是一个事件的基本结构:</em></p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="nf ng l"/></div></figure><h1 id="62d6" class="le jj ht bd jk lf mi lh jo li mj lk js iz mk ja jw jc ml jd ka jf mm jg ke lo dt translated">错误</h1><p id="872f" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated">坚固性在还原状态的同时抛出错误。</p><p id="be3d" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><code class="eh mn mo mp mq b">error</code>关键字用于<strong class="lr hu">声明错误</strong>，而<code class="eh mn mo mp mq b">revert()</code>函数用于<strong class="lr hu">传递错误，同时恢复状态</strong>。错误无法被捕获，除非它们是从外部调用中抛出的。</p><p id="c8f5" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><code class="eh mn mo mp mq b">require()</code>函数可用于评估一个条件，因为它在出错时隐式使用<code class="eh mn mo mp mq b">revert()</code>。</p><p id="56eb" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><em class="ne">下面是一个错误的基本结构:</em></p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="nf ng l"/></div></figure><h1 id="a018" class="le jj ht bd jk lf mi lh jo li mj lk js iz mk ja jw jc ml jd ka jf mm jg ke lo dt translated">修饰语</h1><p id="ed11" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated"><strong class="lr hu">修饰符</strong>是修改变量和函数的<strong class="lr hu">可见性&amp;可变性</strong>的特殊关键字。</p><h2 id="8e88" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">能见度</h2><p id="d1c3" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated">Solidity有两类函数调用:<strong class="lr hu">内部</strong> &amp; <strong class="lr hu">外部</strong>。内部呼叫是在合同内部进行的。<strong class="lr hu">外部调用</strong>，然而<strong class="lr hu">直接调用EVM</strong>并依赖<strong class="lr hu"> ABI编码</strong>。</p><p id="9165" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">四个可用的可见性修饰符是:<code class="eh mn mo mp mq b">external</code>、<code class="eh mn mo mp mq b">public</code>、<code class="eh mn mo mp mq b">internal</code>、&amp;、<code class="eh mn mo mp mq b">private</code>:</p><blockquote class="nh ni nj"><p id="7be6" class="lp lq ne lr b ls mz iu lu lv na ix lx nk nb lz ma nl nc mc md nm nd mf mg mh hm dt translated">✏️ <strong class="lr hu">注意:</strong>外部函数比公共函数便宜</p></blockquote><ul class=""><li id="4f97" class="nn no ht lr b ls mz lv na jt np jx nq kb nr mh ns nt nu nv dt translated"><code class="eh mn mo mp mq b">external</code>函数是契约接口的一部分，也就是说只能外部调用。</li><li id="e68d" class="nn no ht lr b ls nw lv nx jt ny jx nz kb oa mh ns nt nu nv dt translated"><code class="eh mn mo mp mq b">public</code>函数&amp;变量是契约接口的一部分，可以在内部或外部调用。此外，getter函数是为所有用这个修饰符声明的状态变量自动创建的。</li><li id="d2cb" class="nn no ht lr b ls nw lv nx jt ny jx nz kb oa mh ns nt nu nv dt translated"><code class="eh mn mo mp mq b">internal</code>函数&amp;变量只能从契约或派生契约中调用。</li><li id="0dda" class="nn no ht lr b ls nw lv nx jt ny jx nz kb oa mh ns nt nu nv dt translated"><code class="eh mn mo mp mq b">private</code>函数&amp;变量仅在封装契约中可见。</li></ul><h1 id="2d34" class="le jj ht bd jk lf mi lh jo li mj lk js iz mk ja jw jc ml jd ka jf mm jg ke lo dt translated">易变性</h1><p id="d9bb" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated"><code class="eh mn mo mp mq b">constant</code>或<code class="eh mn mo mp mq b">immutable</code>关键字可以用于更严格的<strong class="lr hu">变量可变性</strong>需求。</p><blockquote class="nh ni nj"><p id="4dbd" class="lp lq ne lr b ls mz iu lu lv na ix lx nk nb lz ma nl nc mc md nm nd mf mg mh hm dt translated">✏️注意:这些限制性的修饰语比常规的状态变量要便宜</p></blockquote><ul class=""><li id="e86a" class="nn no ht lr b ls mz lv na jt np jx nq kb nr mh ns nt nu nv dt translated"><code class="eh mn mo mp mq b">constant</code>变量在声明时要求直接赋值。</li><li id="adf5" class="nn no ht lr b ls nw lv nx jt ny jx nz kb oa mh ns nt nu nv dt translated"><code class="eh mn mo mp mq b">immutable</code>变量需要在编译时赋值。</li></ul><h2 id="43ed" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">功能可变性</h2><p id="fb6a" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated"><code class="eh mn mo mp mq b">view</code>和<code class="eh mn mo mp mq b">pure</code>关键字可用于防止功能<strong class="lr hu">读取</strong>或<strong class="lr hu">修改</strong>状态。</p><ul class=""><li id="e6eb" class="nn no ht lr b ls mz lv na jt np jx nq kb nr mh ns nt nu nv dt translated"><code class="eh mn mo mp mq b">view</code>函数不能修改状态，但可以读取状态。</li><li id="64cd" class="nn no ht lr b ls nw lv nx jt ny jx nz kb oa mh ns nt nu nv dt translated"><code class="eh mn mo mp mq b">pure</code>功能不能从状态中读取或写入。</li></ul><h1 id="fa2a" class="le jj ht bd jk lf mi lh jo li mj lk js iz mk ja jw jc ml jd ka jf mm jg ke lo dt translated">类型</h1><p id="5148" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated">Solidity有一个<strong class="lr hu">静态类型的</strong>系统，而<strong class="lr hu">不支持空性</strong>。所有类型，无论是<strong class="lr hu">初等</strong>还是<strong class="lr hu">复杂</strong>，都可以归为三类之一:<strong class="lr hu">值</strong>、<strong class="lr hu">引用</strong>、&amp; <strong class="lr hu">映射</strong>。</p><h2 id="e441" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">值类型</h2><p id="6a71" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated">一个<strong class="lr hu">值类型</strong>是一个<strong class="lr hu">不会保持引用</strong>的类型。该类型在被赋值时被<strong class="lr hu">传递，而不是共享一个引用。</strong></p><p id="44b4" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">值类型类似于其他语言中的<strong class="lr hu">原始类型</strong>。</p><p id="9d40" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><em class="ne">这里有一些值类型:</em></p><p id="8eb9" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><code class="eh mn mo mp mq b">bool</code>、<code class="eh mn mo mp mq b">int</code>、<code class="eh mn mo mp mq b">uint</code>、<code class="eh mn mo mp mq b">string</code>、<code class="eh mn mo mp mq b">address</code>、<code class="eh mn mo mp mq b">bytes1</code>……<code class="eh mn mo mp mq b">bytes32</code>、&amp;、<code class="eh mn mo mp mq b">enum</code>。</p><h2 id="64d1" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">参考类型</h2><p id="9c5f" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated">一个<strong class="lr hu">引用类型</strong>使用一个<strong class="lr hu">引用</strong>到<strong class="lr hu">间接表示一个值</strong>。这些值可以分配给<strong class="lr hu">多个引用</strong>，使得这些值可以从不同的名称空间进行修改。</p><p id="d247" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">引用类型包括<strong class="lr hu">结构</strong>，<strong class="lr hu">数组</strong>，&amp; <strong class="lr hu">映射</strong>。</p><p id="9a98" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">使用时，<strong class="lr hu">引用类型</strong>总是伴随着<strong class="lr hu">位置说明符</strong>来指示数据存储的位置。这样的说明符有三种:<code class="eh mn mo mp mq b">calldata</code>、<code class="eh mn mo mp mq b">memory</code>、&amp;、<code class="eh mn mo mp mq b">storage</code>。</p><ul class=""><li id="e52f" class="nn no ht lr b ls mz lv na jt np jx nq kb nr mh ns nt nu nv dt translated"><code class="eh mn mo mp mq b">calldata</code>指定函数参数的临时数据位置。</li><li id="db47" class="nn no ht lr b ls nw lv nx jt ny jx nz kb oa mh ns nt nu nv dt translated"><code class="eh mn mo mp mq b">memory</code>指定外部调用存储器的临时数据位置。</li><li id="e5d8" class="nn no ht lr b ls nw lv nx jt ny jx nz kb oa mh ns nt nu nv dt translated"><code class="eh mn mo mp mq b">storage</code>指定状态变量的永久数据位置。</li></ul><h2 id="8454" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">映射类型</h2><p id="fbf2" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated"><strong class="lr hu">映射类型</strong>的功能类似于<strong class="lr hu">散列表</strong>、<strong class="lr hu">映射键值对</strong>。键类型可以是任何内置值类型，其中值类型可以是任何实体类型。</p><p id="a58a" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">映射类型使用语法<code class="eh mn mo mp mq b">mapping(KeyType =&gt; ValueType)</code>。</p><p id="8e4a" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">访问映射类型中的值需要明确的键知识，因为所有键都存储为一个<code class="eh mn mo mp mq b">keccak256</code>散列。这使得价值转储不可能，除非事先知道关键知识。</p><p id="9ef7" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated">映射调用只有<code class="eh mn mo mp mq b">storage</code>的数据位置。</p><p id="96fa" class="pw-post-body-paragraph lp lq ht lr b ls mz iu lu lv na ix lx jt nb lz ma jx nc mc md kb nd mf mg mh hm dt translated"><em class="ne">这里有一个正在使用的映射类型:</em></p><figure class="kh ki kj kk fq kl"><div class="bz el l di"><div class="nf ng l"/></div></figure></div><div class="ab cl kx ky hb kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="hm hn ho hp hq"><h1 id="9176" class="le jj ht bd jk lf lg lh jo li lj lk js iz ll ja jw jc lm jd ka jf ln jg ke lo dt translated">就是这样！</h1><p id="5ae2" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated">正如我在我的页面上所说的，这些是我个人笔记本上的笔记。如果有任何明显的错误，请随时留下评论，以便我可以修复它们。还有，如果有你想从我这里看到的内容，请告诉我！</p><h2 id="99f1" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">资源</h2><p id="0907" class="pw-post-body-paragraph lp lq ht lr b ls lt iu lu lv lw ix lx jt ly lz ma jx mb mc md kb me mf mg mh hm dt translated">Solidity的文件:【https://docs.soliditylang.org/en/v0.8.15/ T21】</p></div></div>    
</body>
</html>