<html>
<head>
<title>An Intro To Near Dapp Development With Rust, WASM, Parcel and React -Part 1.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust，WASM，Parcel和React的近Dapp开发介绍-第1部分。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/an-intro-to-near-dapp-development-with-rust-wasm-parcel-and-react-part-1-e500a3abc597?source=collection_archive---------3-----------------------#2022-03-09">https://medium.com/coinmonks/an-intro-to-near-dapp-development-with-rust-wasm-parcel-and-react-part-1-e500a3abc597?source=collection_archive---------3-----------------------#2022-03-09</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/5cb09fda422012defc275bb408cc8020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PshID33DzhVzihyRDWXicg.jpeg"/></div></div></figure><div class=""/><p id="2da7" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">本文将通过一个简单的、功能性的、从头到尾的例子分三部分向现有的Web3开发人员介绍Near协议。</p><p id="8f65" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">本教程第1部分和第2部分的完整代码库可以在</strong> <a class="ae jz" href="https://github.com/Panasthetik/near-starter-app" rel="noopener ugc nofollow" target="_blank"> <strong class="jd if">这里</strong> </a> <strong class="jd if">找到。</strong></p><p id="8dfd" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果你来自以太坊甚至索拉纳，那么从现在(2022年3月)开始，有一件事几乎与众不同，那就是没有很多最近的教程来开发一个具有可升级模板的基本的、全功能的应用程序——前端、后端和单元测试。</p><p id="727e" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">此外，我认为协议的契约是用Rust或AssemblyScript(然后编译成WASM)编写的，这一事实倾向于阻止潜在的开发者直接进入。</p><p id="1a13" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后——在我看来，在各种新闻文章和报道以及像本文这样的开发人员教程中，近区块链和底层令牌都没有得到充分的体现。</p><p id="b5f9" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我希望通过这篇文章来帮助缓解这些问题，使Near协议更容易为新的创作者所接受，同时也帮助潜在用户了解一些使Near成为一个令人敬畏、有趣、快速、鼓舞人心、具有巨大潜力的区块链的许多事情。所以让我们开始吧！</p><p id="2e2f" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">基础知识。</strong></p><p id="fa9c" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，为了让我们对Near的介绍更容易，本教程直接假设了一些事情:</p><ol class=""><li id="18b6" class="ka kb ie jd b je jf ji jj jm kc jq kd ju ke jy kf kg kh ki dt translated">你已经在以太坊，EVM或者第二层链，或者索拉纳或者类似的平台上进行了初步开发，并且拥有开发工具的经验，比如松露，安全帽，锚或者铸造。</li><li id="dc99" class="ka kb ie jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">您运行的是Linux或MacOS，并且安装了Rust，包括最新的稳定版本、Cargo package manager和Rust extension/analyzer for VSCode(本文将使用vs code)。</li><li id="7508" class="ka kb ie jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">Node.js应安装在14 . 19 . 0–17 . 1 . 0版本，并且您的NPM至少是8.3.0以上版本</li><li id="d294" class="ka kb ie jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">您熟悉智能合同部署、汽油费、钱包账户、交易浏览器等。—基本的区块链原语。</li><li id="2fdb" class="ka kb ie jd b je kj ji kk jm kl jq km ju kn jy kf kg kh ki dt translated">最后——尽管基本的Rust很有帮助，React的经验也很棒，但要理解这个例子和所有东西是如何交互的，你不需要在专家水平上了解任何一个。</li></ol><p id="3819" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">设置我们的Near Testnet钱包。</strong></p><p id="a128" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们要看的第一件事是在Near Testnet上创建一个钱包/帐户，并获取一些测试Near令牌以部署在网络上。你可以去<a class="ae jz" href="http://wallet.testnet.near.org" rel="noopener ugc nofollow" target="_blank">这里</a>了解如何做到这一点，因为它非常类似于其他钱包(MetaMask，SolFlare):</p><div class="hs ht fm fo hu ko"><a href="https://wallet.testnet.near.org" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab ej"><div class="kq ab kr cl cj ks"><h2 class="bd if fv z el kt eo ep ku er et id dt translated">近钱包</h2><div class="kv l"><h3 class="bd b fv z el kt eo ep ku er et ek translated">编辑描述</h3></div><div class="kw l"><p class="bd b gc z el kt eo ep ku er et ek translated">wallet.testnet.near.org</p></div></div></div></a></div><p id="bfbc" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">与Near already的一个有趣的区别是，Near帐户地址显示为人类可读的文本(例如:“myaccount.testnet”表示测试，或者“myaccount.near”表示mainnet)。只要您建议的名称尚未被采用，您就可以创造性地使用这些帐户名称。此外，无需保留单独的类似ENS的名称(。ETH)或。SOL like on Solana —有了Near，您就拥有了开箱即用的能力，您部署的合同可以直接映射到您选择的地址！！</p><figure class="kx ky kz la fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/58764f3ac747e0f4b463b486595e5845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kNwH1NSC19B0sOZXbOW9Cw.jpeg"/></div></div></figure><p id="b712" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当我们在链上实际部署智能合同时，我们将选择子账户名称作为包含合同地址的最佳实践，如下所示:</p><p id="a003" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">contract.myaccount.testnet(用于测试)</p><p id="8ebe" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">contract.myaccount.near(用于mainnet)</p><p id="cf90" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">关于Near需要注意的一点是，每个子地址只能部署一个智能合约，这可以保持有序，并且可以升级(我们将在本系列的后面看到如何升级或替换合约)。</p><p id="6437" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一旦我们创建了近测帐户，我们应该有一个样本近测令牌余额开始，这将有助于我们的下一步。</p><figure class="kx ky kz la fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/2a790503d26d42bf67678dc61c84826b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WnuGpoxVljnQoTwQe4FWlw.jpeg"/></div></div></figure><p id="7da6" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">建立我们的环境。</p><p id="350a" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">开始组织我们的开发环境的最佳方式是使用NPM安装Near CLI，如下所示:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="c1c8" class="lg lh ie lc b fv li lj l lk ll">npm install near-cli</span></pre><p id="53ed" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">正确安装后，您应该能够在终端中验证当前版本，如下所示:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="ac11" class="lg lh ie lc b fv li lj l lk ll">near --version</span></pre><p id="ee45" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来，使用Near CLI，我们将使用以下内容登录Near Testnet:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="bc54" class="lg lh ie lc b fv li lj l lk ll">near login</span></pre><p id="fa7d" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当我们运行这个程序时，应该会弹出一个浏览器屏幕，指示在“rpc.testnet.near.org”上的登录请求，它应该(如果您正确地打开了您的near帐户)要求您批准登录事务。</p><figure class="kx ky kz la fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/14a5cd2e3191c49e2cd50cd7f5a418fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_Jq_f8NBDZSoIPxN6FuPw.jpeg"/></div></div></figure><p id="126c" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">批准后，您将看到一个屏幕，指示您登录成功，现在您可以关闭浏览器窗口并返回到VSCode终端。在终端中，有一条清晰的消息，表明您已使用指定的登录到近CLI。测试网络地址:</p><figure class="kx ky kz la fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/d96167336b29a2ca25848bb5777c425d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GPzqTTe_6fYW4G9N9geW-A.jpeg"/></div></div></figure><p id="5d5c" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">太好了！我们有一个安装了CLI的Near wallet帐户(myaccount.testnet ),我们已经登录到Near testnet，现在我们准备在VSCode中启动一个包含我们的项目目录的新项目。</p><p id="58ff" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="lm">注意:虽然已经有一个NPX包来创建一个包含Rust或AssemblyScript starter kits(带React)的近似样板文件，但在本教程中，我已经通过消除JavaScript测试方法和避免诸如Webpack、Babel、Jest、Nodemon、ShellJS和其他一些节点依赖来简化这个过程。我认为在某些情况下，这些并不总是开箱即用，我们可以避免花时间诊断JS/NPM错误，而是专注于我们的近部署。</em></p><p id="3309" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="lm">对于我们的近智能合同，我们将从头开始创建这个项目，并用Rust编写单元测试。在第3部分的后面，我们将使用最新的包并专门对前端做出反应。我希望这种方法能让新的Near开发人员稍微轻松一点。</em></p><p id="3b43" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，在您的VSCode终端中，我们将开始创建一个新目录，如下所示:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="dd16" class="lg lh ie lc b fv li lj l lk ll">mkdir near-starter-dapp</span><span id="96a1" class="lg lh ie lc b fv ln lj l lk ll">cd near-starter-dapp</span></pre><p id="3b31" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这个主目录中，让我们创建一个名为“contract”的文件夹，其中包含我们的Rust代码和编译文件，如下所示:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="880e" class="lg lh ie lc b fv li lj l lk ll">mkdir contract </span><span id="8b00" class="lg lh ie lc b fv ln lj l lk ll">cd contract</span></pre><p id="c492" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这个“合同”目录中，我们需要做两件事——使用Cargo初始化一个新的Rust项目，并在编译到WASM之前编写一些有用的脚本来构建和测试我们的Rust代码。</p><p id="63bd" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在“合同”中，输入以下内容:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="2b6f" class="lg lh ie lc b fv li lj l lk ll">cargo init --lib</span></pre><p id="fbfe" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">正如我们所看到的，这创建了一个空的Rust项目，并为我们提供了开始编写智能契约所需的目录。“src”文件夹包含Rust文件，而“cargo.toml”将为我们的项目指定一些需求和依赖项。</p><p id="5a84" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在我们继续我们的Rust代码之前，有一件重要的事情我们需要添加到我们的Rust配置中，以便能够正确地编译我们的合同，这就是部署的WASM目标。在终端中输入以下内容:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="6454" class="lg lh ie lc b fv li lj l lk ll">rustup target add wasm32-unknown-unknown</span></pre><p id="4b20" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一旦我们这样做了，我们的目录就准备好了，让我们创建一些简单的shell脚本，我们将需要在这个“契约”目录中执行简单的构建和测试终端操作。我们将创建以下脚本:</p><p id="3522" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">build.sh</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="00e7" class="lg lh ie lc b fv li lj l lk ll">#!/bin/bash</span><span id="d37f" class="lg lh ie lc b fv ln lj l lk ll">set -e</span><span id="38e7" class="lg lh ie lc b fv ln lj l lk ll">RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release</span><span id="b063" class="lg lh ie lc b fv ln lj l lk ll">cp target/wasm32-unknown-unknown/release/*.wasm ./res/</span></pre><p id="280c" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">build .蝙蝠</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="1c6c" class="lg lh ie lc b fv li lj l lk ll">cargo build --target wasm32-unknown-unknown --release</span><span id="6191" class="lg lh ie lc b fv ln lj l lk ll">copy target\wasm32-unknown-unknown\release\*.wasm res</span></pre><p id="4261" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">测试. sh</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="373a" class="lg lh ie lc b fv li lj l lk ll">#!/bin/bash</span><span id="5d4e" class="lg lh ie lc b fv ln lj l lk ll">set -e</span><span id="ea34" class="lg lh ie lc b fv ln lj l lk ll">cargo test -- --nocapture</span></pre><p id="bed0" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">创建这些脚本后，我们的“合同”目录应该如下所示:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="59fd" class="lg lh ie lc b fv li lj l lk ll">contract--|<br/>          |src<br/>          |build.sh<br/>          |build.bat<br/>          |test.sh<br/>          |cargo.toml<br/>          |cargo.lock</span></pre><p id="f727" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们现在不担心cargo.lock文件，但是我们想用下面的代码编辑<strong class="jd if"> cargo.toml </strong>文件:</p><figure class="kx ky kz la fq hv"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="2d6c" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">设置好这个目录结构后，让我们在“contracts”文件夹中创建最后一个目录:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="7870" class="lg lh ie lc b fv li lj l lk ll">mkdir res</span></pre><p id="f179" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们最终的“合同”目录结构是:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="1db6" class="lg lh ie lc b fv li lj l lk ll">contract--|<br/>          |src<br/>          |build.sh<br/>          |build.bat<br/>          |test.sh<br/>          |cargo.toml<br/>          |cargo.lock<br/>          |res</span></pre><p id="21ec" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们的Rust环境已经设置好了，我们已经准备好为Near编写智能合约了！</p><p id="9e62" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">开始我们近乎智能的合同</strong></p><p id="3e68" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们检查一下主“contracts”文件夹中的“src”目录。</p><p id="2da6" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在内部，有一个名为“lib.rs”的starter Rust文件—在VSCode中打开该文件，让我们简单地看一下:</p><figure class="kx ky kz la fq hv"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="610c" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">目前所做的只是运行一个简单的测试函数，如果我们现在运行我们的“test.sh”脚本(从我们的“contract”文件夹根目录)，文件会被快速编译并测试，终端中的结果如下:</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="ef21" class="lg lh ie lc b fv li lj l lk ll">running 1 test<br/>test tests::it_works ... ok</span></pre><p id="c787" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，我们想把我们的“lib.rs”文件和<strong class="jd if">完全</strong>用下面的代码覆盖它:</p><figure class="kx ky kz la fq hv"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="2f65" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">关于我们的“活动”合同的一些想法和解释。</p><p id="20b0" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，这是相当多的代码，因为这主要不是一个Rust教程，我将把它留给开发人员来研究每个导入、结构和函数在这个文件中做什么。</p><p id="8f6e" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">关于Rust宏和Near SDK的重要一点是——就像索拉纳、埃尔隆德和其他基于Rust的区块链一样，SDK处理大量的抽象(这意味着它“包装”并大大简化了您的代码)。如果我们在低级Rust中输入上面的代码所做的一切，我们将有更多的代码要写，这对于入职来说将更加令人生畏。</p><p id="68c6" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">简单总结一下我们的智能合同正在做的事情，这个项目创建了一个简单的应用程序，用于列出建议的活动，包括标题、描述和建议的预算。任何人都可以使用他们的Near wallet登录该应用程序来创建这些活动，然后任何人登录该应用程序也可以对列出的拟议活动进行投票。</p><p id="3b47" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们将在创建前端时研究一些细节，并在部署时对底层功能提出改进建议。</p><p id="ae04" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">但是首先，让我们向我们的项目添加两个Rust文件，这样我们就有必要的箱子和模型(常量/实用函数)来补充我们的主应用程序文件。</p><p id="86fd" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，我们将创建一个名为“utils.rs”的文件，并用以下内容保存它:</p><figure class="kx ky kz la fq hv"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="1803" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来，我们创建一个文件“models.rs ”,并在其中保存以下内容:</p><figure class="kx ky kz la fq hv"><div class="bz el l di"><div class="lo lp l"/></div></figure><p id="b478" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们的“models.rs”文件包含一些重要的结构(主要是“Event”结构及其实现块)以导入到我们的主“lib.rs”文件中。这些可以在以后添加，这取决于我们可能希望在我们的整体合同中体现的其他内容(例如日历、进度、财务或成员目录结构)。</p><p id="b5f5" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">“utils.rs”文件旨在包含一些用于各种单位转换的核心变量、常量和函数。像“models.rs”一样，这个文件也可以在以后引入新功能时进行修改。现在，这个文件只包含两个通用函数来帮助承诺和序列化。</p><p id="6eaf" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">完成这三个文件后，它们都在“src”目录中，并准备好进行初步的“构建”,以查看我们的项目是否可以编译并准备好进行测试和部署。</p><p id="a2ae" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在Cargo中建立智能合同并确保其编译。</p><p id="833e" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在“contract”的根目录下，运行“build.sh”脚本，如下所示(这种方法在Mac和Linux之间会有所延迟——在Linux中，您不需要在终端命令前使用“bash ”,在Mac上，您的操作如下所示) :</p><pre class="kx ky kz la fq lb lc ld le aw lf dt"><span id="f31d" class="lg lh ie lc b fv li lj l lk ll">bash ./build.sh</span></pre><p id="57b9" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在短暂等待Cargo下载板条箱、安装所有Rust依赖项、编译和组装所有东西之后，我们的“合同”目录中应该会有一些新东西。</p><p id="229f" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，您会注意到一个新创建的“目标”文件夹。这是随Cargo package manager提供的标准Rust build文件夹，它使输出文件的组织变得简单明了。在这个“目标”文件夹中是我们的Rust应用程序的初步构建(二进制文件)，其中一个构建在一个特殊的“wasm32-unknown-unknown”文件夹中。</p><p id="5a6e" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，我们可以忽略“目标”中的这些文件，因为我们想要的近区块链是我们专门复制(使用我们的“build.bat”脚本自动化)到我们的<strong class="jd if"> <em class="lm">其他</em> </strong>构建目录的WASM文件——一个名为“res”的文件。</p><p id="1ae1" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在“res”中，我们看到一个文件“<strong class="jd if"> near_starter_dapp.wasm </strong>”，这是我们最终需要在near上部署的文件。为了方便起见，我们实际上是从“target”中复制这个文件的，所以我们不必在每次进行更改和重新编译时深入挖掘目标/构建目录的几个层次来找到这个文件。</p><p id="da7f" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if"><em class="lm">Rust</em></strong><em class="lm">中的错误消息提示:您可能已经完成了初步构建(显示已完成)，但您仍然会在终端中看到许多警告(用黄色强调)。别担心，我们仍然成功地编制了我们的合同！如果有任何“红色”警告，您会看到更严重的错误，项目将不会编译，直到解决。目前，这完全没问题:</em></p><figure class="kx ky kz la fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/d808e72936c4f8270b0ced01e55b99c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_y_WYo1bl11jnK9K9oc9Yg.jpeg"/></div></div></figure><p id="4372" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="lm">随着我们使用Rust的最新稳定版本推进我们的项目，Cargo package manager和rustc编译器将努力告诉您什么是优化的、最新的和正确的代码。一些警告将与我们在“cargo.toml”中指定的Near SDK版本相关，而另一些则与稍旧的语法或Rust版本本身有关。</em></p><p id="7d8b" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">我们教程的下一步，第1部分结束。</strong></p><p id="e3c5" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">本例不涉及太多的技术细节—我们使用了Near SDK版本3的一些方法/宏，而其他的(用于下一章的测试)将使用Near SDK版本4的一个新的、改进的“VMContext”构建器(一个测试模拟环境宏),该版本目前仍在开发中。对于我们在“cargo.toml”中指出的整体情况，我们可以在整个教程中保持SDK版本为“4.0.0-pre.4 ”,而不必降级到大多数教程中使用的早期版本。</p><p id="0185" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">说到测试，为什么不现在就在Rust中写几个单元测试，在我们最终的WASM构建之前运行，这样我们就知道它做了需要做的事情？</p><p id="a7d5" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">幸运的是，用Rust编写我们的测试非常容易，当然，一旦单元测试被添加到我们的主契约文件(lib.rs)中，我们已经在我们的“契约”根上准备好了测试脚本(test.sh)。此外，出于多种原因，最好用我们用来编写合同的本地语言(在我们的例子中是Rust)来编写我们的测试，这样我们就可以从Cargo和编译器早期了解我们的代码是否正确运行，或者我们需要在将它编译到我们在WASM的“发布”文件中以进行合同部署之前对其进行调整。</p><p id="1804" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">在本教程的下一部分中，我们将编写一些Rust单元测试，根据我们的智能契约运行它们，在Near-CLI中创建一个部署子帐户，将我们的契约部署到Near Testnet，并且在我们继续第三部分中的React前端集成之前，实际上能够在控制台中与它进行交互。</strong></p><p id="8ed3" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">我希望您喜欢这个向像您一样的新开发人员介绍Near协议的三部分系列的第一部分！</strong></p><p id="6259" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">感谢您的阅读，下次再见……—Panasthetik。</p><p id="8132" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">资源:</strong></p><div class="hs ht fm fo hu ko"><a href="https://docs.near.org/docs/develop/basics/getting-started" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab ej"><div class="kq ab kr cl cj ks"><h2 class="bd if fv z el kt eo ep ku er et id dt translated">开始使用|靠近文档</h2><div class="kv l"><h3 class="bd b fv z el kt eo ep ku er et ek translated">NEAR平台上的开发分为两个主要类别:这里是对您…</h3></div><div class="kw l"><p class="bd b gc z el kt eo ep ku er et ek translated">docs.near.org</p></div></div></div></a></div><div class="hs ht fm fo hu ko"><a href="https://docs.rs/near-sdk/latest/near_sdk/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab ej"><div class="kq ab kr cl cj ks"><h2 class="bd if fv z el kt eo ep ku er et id dt translated">near_sdk - Rust</h2><div class="kv l"><h3 class="bd b fv z el kt eo ep ku er et ek translated">智能合约可用的env区块链特定方法。这是一个包装器，围绕着一个低级…</h3></div><div class="kw l"><p class="bd b gc z el kt eo ep ku er et ek translated">文件</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv ia ko"/></div></div></a></div><div class="hs ht fm fo hu ko"><a href="https://www.rust-lang.org/" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab ej"><div class="kq ab kr cl cj ks"><h2 class="bd if fv z el kt eo ep ku er et id dt translated">锈</h2><div class="kv l"><h3 class="bd b fv z el kt eo ep ku er et ek translated">Rust速度惊人，内存效率高:没有运行时或垃圾收集器，它可以支持关键性能…</h3></div><div class="kw l"><p class="bd b gc z el kt eo ep ku er et ek translated">www.rust-lang.org</p></div></div><div class="lq l"><div class="lw l ls lt lu lq lv ia ko"/></div></div></a></div></div></div>    
</body>
</html>