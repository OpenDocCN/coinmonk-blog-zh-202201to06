<html>
<head>
<title>Blockchain’s Role in Web 3.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">区块链在Web 3.0中的作用</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/blockchains-role-in-web-3-0-36ff53affbef?source=collection_archive---------36-----------------------#2022-04-06">https://medium.com/coinmonks/blockchains-role-in-web-3-0-36ff53affbef?source=collection_archive---------36-----------------------#2022-04-06</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="a662" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我最近有机会参加了在Solana bootcamp上开发的Chainlink，这只是对在Solana上开发dapps(去中心化应用程序)的一个小小的了解。幸运的是，我在Flatiron的时间帮助我理解了编程语言的核心概念及其功能，这有助于我理解Rust以及代码如何与索拉纳区块链本身进行交互。参加这个研讨会让我看到了“幕后”发生的事情，这是投资加密货币本身永远做不到的。这反过来帮助我发现了区块链理工学院在革新我们今天做事方式方面的潜力。</p><p id="3774" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">Web 3.0简介</strong></p><p id="1530" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Web 3.0绝对是我们这些天经常看到的一个词，并且最近已经成为许多人迷恋的时髦词。Web 3.0的一个包罗万象的定义是消除互联网上的中间人。在深入研究区块链技术和什么是Web 3.0之前，我们必须先回顾一下互联网诞生的历史和它的目的。互联网的开端始于Web 1.0，当时Web被视为一种民主化信息访问的方式，但不幸的是，它对如何与静态页面交互设置了许多限制。因此，Web 2.0是由谷歌、脸书、亚马逊、Twitter和大型科技公司领导创建的，使互联网更容易连接和在线交易。电子商务和社交媒体让其他人有机会将他们的平台扩展到更广泛的受众。然而，许多批评者认为这些公司现在积聚了太多的权力，由此产生了Web 3.0这个术语。Web 3.0的理念是拥有一个分散的系统，在这个系统中，个人可以控制自己的数据，并能够使用一个单独的个性化帐户在不同的平台上来回移动，在区块链上创建所有活动的个人记录。这将引入一个利用AI(人工智能)、IOT(物联网)和区块链技术的自主开放的互联网。</p><p id="c86c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">那么，区块链在Web 3.0中的角色是什么？通过其在对等网络中促进多份数据存储的能力和在网络中验证者之间达成一致的要求，区块链协议是真正的Web 3.0的主干。最重要的是，它能够使两个陌生人通过智能合同达成协议，并通过互联网结算交易，从而消除了对中介的需求。我现在将深入我对区块链基础设施的理解，并帮助我的读者一瞥客户与区块链互动的代码，以及这一切是如何开创性的。</p><p id="954e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">区块链基础设施</strong></p><p id="745a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当客户通过dapps或分散式交换机与区块链上的特定合同地址进行交互时，他或她总是首先将他们的数字钱包连接到启动该过程的应用程序本身。从那里，客户机的请求与网络中的验证器节点进行交互。验证器节点利用RPC(远程过程调用)来读取特定块的先前散列，并且当所有节点验证事务时，授予在区块链自身上创建块的批准。这一步有助于验证之前的交易和当前的交易，以保证数据块本身没有被可疑行为者篡改。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff jo"><img src="../Images/fdd8964969cd3c16f40de963730b5d71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8tOUG4NN0vTnYzPv.png"/></div></div></figure><p id="e2c4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">很多人想知道为什么使用RPC而不是更常用的REST API方法。REST APIs有时可能会失败，尤其是在大型应用程序中，这就是为什么RPC更常用于内部通信。然而，使用RPC胜过REST APIs的最大原因是由于区块链的不变性组件。REST APIs支持CRUD(创建、读取、更新、删除)操作；然而，验证器在与区块链交互时不需要update和delete方法，只需要GET和POST。这种更简单的方法有助于简化应用程序与区块链的交互。</p><p id="0fab" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">样本交互</strong></p><p id="e42d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">既然我们已经看到了基础设施的概述，我们可以看看与区块链交互的幕后代码。<strong class="is hu">免责声明:</strong>以下示例是Chainlink/Solana训练营期间提供的示例代码。所有的工作都是在一个使用索拉纳CLI的本地索拉纳集群上完成的，并被用作与索拉纳区块链交互的模型。显示的合同和钱包地址不是现有地址。</p><p id="ab0d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">会议期间使用的示例是创建我们自己的令牌，因为这是大多数人在谈到区块链时所熟悉的。我们从本地化服务器开始，然后在一个Rust文件中，我们调用我们想要发生的指令。</p><pre class="jp jq jr js fq ka kb kc kd aw ke dt"><span id="7789" class="kf kg ht kb b fv kh ki l kj kk">use borsh::{BorshDeserialize, BorshSerialize};</span><span id="93f6" class="kf kg ht kb b fv kl ki l kj kk">#[derive(BorshSerialize, BorshDeserialize, Debug, Clone)]</span><span id="ad4a" class="kf kg ht kb b fv kl ki l kj kk">pub enum TokenInstruction {</span><span id="662f" class="kf kg ht kb b fv kl ki l kj kk">CreateToken,</span><span id="c400" class="kf kg ht kb b fv kl ki l kj kk">CreateTokenAccount,</span><span id="7e46" class="kf kg ht kb b fv kl ki l kj kk">Mint { amount: u64 },</span><span id="6692" class="kf kg ht kb b fv kl ki l kj kk">Transfer { amount: u64 },</span><span id="4a09" class="kf kg ht kb b fv kl ki l kj kk">}</span></pre><p id="f746" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这种情况下，Borsh用于散列，主要用于安全关键项目行业，因为它优先考虑一致性、速度和严格的规范。它的Serialize/Deserialize方法用于将数据结构转换成字节，主要用于与RPC和客户机交互的过程中。</p><p id="0c0c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来的步骤是定义将存储在程序中的数据，该数据被分为两个结构，一个是定义标题级信息的“令牌”标题级，另一个是定义令牌帐户信息的“令牌帐户”结构。从那里，编译器被告知使用来自Borsh库的信息以及我们传递的指令和帐户信息。</p><pre class="jp jq jr js fq ka kb kc kd aw ke dt"><span id="35b9" class="kf kg ht kb b fv kh ki l kj kk">use borsh::{BorshDeserialize};<br/>use solana_program::{<br/>   account_info::{next_account_info, AccountInfo},<br/>   entrypoint::ProgramResult,<br/>   msg,<br/>   program_error::ProgramError,<br/>   pubkey::Pubkey,<br/>};<br/><br/>use crate::instruction::TokenInstruction;<br/>use crate::state::{Token, TokenAccount};<br/><br/>pub struct Processor {}<br/><br/>impl Processor {<br/>   pub fn process_instruction(<br/>       _program_id: &amp;Pubkey,<br/>       accounts: &amp;[AccountInfo],<br/>       instruction_data: &amp;[u8],<br/>   ) -&gt; ProgramResult {<br/>       let instruction = TokenInstruction::try_from_slice(instruction_data)<br/>           .map_err(|_| ProgramError::InvalidInstructionData)?;<br/>       let accounts_iter = &amp;mut accounts.iter();<br/>       msg!("Instruction: {:?}",instruction);<br/>       match instruction {<br/>           TokenInstruction::CreateToken =&gt; {<br/>               msg!("Instruction: Create Token");<br/><br/>           }<br/>           TokenInstruction::CreateTokenAccount =&gt; {<br/>               msg!("Instruction: Create Token Account");<br/><br/>           }<br/>           TokenInstruction::Mint { amount } =&gt; {<br/>               msg!("Instruction: Mint");<br/><br/>           }<br/>           TokenInstruction::Transfer { amount } =&gt; {<br/>               msg!("Instruction: Transfer");<br/>           }<br/>       }<br/>       Ok(())<br/>   }<br/>}</span></pre><p id="1b0d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">注:</strong> Crate是编译器。帐户信息存储我们想要维护令牌所有权的帐户的信息。</p><p id="e682" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从这里开始，我们传递我们希望每个函数做的事情。</p><p id="9279" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">总之，我们将首先为我们指定的帐户创建一个新令牌，同时指定一个“令牌授权”帐户(铸造或创建新令牌的权限等)。然后，我们指定令牌的具体细节，例如提供并保存所有者帐户，以便能够访问令牌授权帐户。</p><p id="8bc4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">完成此步骤后，我们将指定哪个帐户想要接收铸造的令牌，即所有者帐户和令牌颁发机构帐户。代码逻辑将验证它是尝试铸造令牌的令牌授权帐户，否则它将返回错误。一旦支票通过，代币账户的总供应量将随着目标接收者的余额而增加。</p><p id="dd3d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">逻辑的最后一部分是验证令牌可以在帐户之间转移。为此，我们必须核实“转出”账户和“转入”账户，并确认“转出”账户持有足够的资金。我们的逻辑还将验证“发件人”帐户的所有者已经签署了交易，同时还将检查“收件人”帐户是否与我们输入的收件人帐户相匹配。如果都检查通过，两个账户的余额将被更新和保存。</p><p id="20ca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">说明部分的最终代码块应该如下所示:</p><pre class="jp jq jr js fq ka kb kc kd aw ke dt"><span id="e1f3" class="kf kg ht kb b fv kh ki l kj kk">match instruction {</span><span id="50b8" class="kf kg ht kb b fv kl ki l kj kk">TokenInstruction::CreateToken =&gt; {</span><span id="696b" class="kf kg ht kb b fv kl ki l kj kk">msg!("Instruction: Create Token");</span><span id="8467" class="kf kg ht kb b fv kl ki l kj kk">//get account info for master token account</span><span id="35ad" class="kf kg ht kb b fv kl ki l kj kk">let token_master_account = next_account_info(accounts_iter)?;</span><span id="f5c4" class="kf kg ht kb b fv kl ki l kj kk">let token_authority = next_account_info(accounts_iter)?;</span><span id="3098" class="kf kg ht kb b fv kl ki l kj kk">let mut token = Token::load_unchecked(token_master_account)?;</span><span id="319f" class="kf kg ht kb b fv kl ki l kj kk">//set default values and save master token account</span><span id="9a96" class="kf kg ht kb b fv kl ki l kj kk">token.authority = *token_authority.key;</span><span id="4cd8" class="kf kg ht kb b fv kl ki l kj kk">token.supply = 0;</span><span id="c790" class="kf kg ht kb b fv kl ki l kj kk">token.save(token_master_account)?</span><span id="a953" class="kf kg ht kb b fv kl ki l kj kk">}</span><span id="bfdb" class="kf kg ht kb b fv kl ki l kj kk">TokenInstruction::CreateTokenAccount =&gt; {</span><span id="67a0" class="kf kg ht kb b fv kl ki l kj kk">msg!("Instruction: Create Token Account");</span><span id="f73a" class="kf kg ht kb b fv kl ki l kj kk">//get account info for master token account and token account to be created</span><span id="c22e" class="kf kg ht kb b fv kl ki l kj kk">let token_account_acct = next_account_info(accounts_iter)?;</span><span id="e423" class="kf kg ht kb b fv kl ki l kj kk">let token_master_account = next_account_info(accounts_iter)?;</span><span id="c6de" class="kf kg ht kb b fv kl ki l kj kk">let owner = next_account_info(accounts_iter)?;</span><span id="dd69" class="kf kg ht kb b fv kl ki l kj kk">let mut token_account = TokenAccount::load_unchecked(token_account_acct)?;</span><span id="f215" class="kf kg ht kb b fv kl ki l kj kk">//set default values and save token account</span><span id="1767" class="kf kg ht kb b fv kl ki l kj kk">token_account.owner = *owner.key;</span><span id="7b4b" class="kf kg ht kb b fv kl ki l kj kk">token_account.token = *token_master_account.key;</span><span id="192d" class="kf kg ht kb b fv kl ki l kj kk">token_account.amount = 0;</span><span id="4cdd" class="kf kg ht kb b fv kl ki l kj kk">token_account.save(token_account_acct)?</span><span id="84d4" class="kf kg ht kb b fv kl ki l kj kk">}</span><span id="77df" class="kf kg ht kb b fv kl ki l kj kk">TokenInstruction::Mint { amount } =&gt; {</span><span id="25fe" class="kf kg ht kb b fv kl ki l kj kk">msg!("Instruction: Mint");</span><span id="ec79" class="kf kg ht kb b fv kl ki l kj kk">//get account info for master token account and token account to mint to</span><span id="c28c" class="kf kg ht kb b fv kl ki l kj kk">let token_account_acct = next_account_info(accounts_iter)?;</span><span id="c492" class="kf kg ht kb b fv kl ki l kj kk">let token_master_account = next_account_info(accounts_iter)?;</span><span id="7bb4" class="kf kg ht kb b fv kl ki l kj kk">let mut token_account = TokenAccount::load(token_account_acct)?;</span><span id="fcc5" class="kf kg ht kb b fv kl ki l kj kk">let mut token = Token::load(token_master_account)?;</span><span id="c2a8" class="kf kg ht kb b fv kl ki l kj kk">//basic validation, ensure its the master token authority trying to mint</span><span id="7915" class="kf kg ht kb b fv kl ki l kj kk">let token_authority = next_account_info(accounts_iter)?;</span><span id="8c68" class="kf kg ht kb b fv kl ki l kj kk">if !token_authority.is_signer {</span><span id="99f3" class="kf kg ht kb b fv kl ki l kj kk">msg!("Only the token owner can mint tokens");</span><span id="ba70" class="kf kg ht kb b fv kl ki l kj kk">return Err(ProgramError::MissingRequiredSignature);</span><span id="49fb" class="kf kg ht kb b fv kl ki l kj kk">}</span><span id="994a" class="kf kg ht kb b fv kl ki l kj kk">//update total supply of the master token, and update balance of token account that received the mint</span><span id="6b12" class="kf kg ht kb b fv kl ki l kj kk">token.supply += amount;</span><span id="2fb8" class="kf kg ht kb b fv kl ki l kj kk">token_account.amount += amount;</span><span id="1066" class="kf kg ht kb b fv kl ki l kj kk">//save updated contents of both accounts</span><span id="082d" class="kf kg ht kb b fv kl ki l kj kk">token_account.save(token_account_acct)?;</span><span id="e4c5" class="kf kg ht kb b fv kl ki l kj kk">token.save(token_master_account)?;</span><span id="5404" class="kf kg ht kb b fv kl ki l kj kk">}</span><span id="7d4a" class="kf kg ht kb b fv kl ki l kj kk">TokenInstruction::Transfer { amount } =&gt; {</span><span id="d2c6" class="kf kg ht kb b fv kl ki l kj kk">msg!("Instruction: Transfer");</span><span id="5d5a" class="kf kg ht kb b fv kl ki l kj kk">//get account info for from and to token accounts, as well as master token account</span><span id="2817" class="kf kg ht kb b fv kl ki l kj kk">let from_token_acct = next_account_info(accounts_iter)?;</span><span id="6ffd" class="kf kg ht kb b fv kl ki l kj kk">let to_token_acct = next_account_info(accounts_iter)?;</span><span id="2377" class="kf kg ht kb b fv kl ki l kj kk">let owner = next_account_info(accounts_iter)?;</span><span id="7977" class="kf kg ht kb b fv kl ki l kj kk">let mut src_token_account = TokenAccount::load(from_token_acct)?;</span><span id="185b" class="kf kg ht kb b fv kl ki l kj kk">let mut dst_token_account = TokenAccount::load(to_token_acct)?;</span><span id="5ffc" class="kf kg ht kb b fv kl ki l kj kk">//basic validation, ensure sender has enough funds</span><span id="4c09" class="kf kg ht kb b fv kl ki l kj kk">if src_token_account.amount &lt;= amount {</span><span id="d20a" class="kf kg ht kb b fv kl ki l kj kk">msg!("Not enough tokens to transfer");</span><span id="0a41" class="kf kg ht kb b fv kl ki l kj kk">return Err(ProgramError::InsufficientFunds);</span><span id="27b5" class="kf kg ht kb b fv kl ki l kj kk">}</span><span id="f5ce" class="kf kg ht kb b fv kl ki l kj kk">//ensure the owner of the from account is the one signing the transaction</span><span id="c713" class="kf kg ht kb b fv kl ki l kj kk">if !owner.is_signer {</span><span id="3de1" class="kf kg ht kb b fv kl ki l kj kk">msg!("Not the token owner signing the transaction");</span><span id="5b67" class="kf kg ht kb b fv kl ki l kj kk">return Err(ProgramError::MissingRequiredSignature);</span><span id="ac82" class="kf kg ht kb b fv kl ki l kj kk">}</span><span id="a995" class="kf kg ht kb b fv kl ki l kj kk">//ensure the owner passed in is the actual owner of the token account</span><span id="d7c2" class="kf kg ht kb b fv kl ki l kj kk">if !(src_token_account.owner == *owner.key) {</span><span id="8606" class="kf kg ht kb b fv kl ki l kj kk">msg!("Not the token account owner signing the transaction");</span><span id="9d12" class="kf kg ht kb b fv kl ki l kj kk">return Err(ProgramError::MissingRequiredSignature);</span><span id="2b90" class="kf kg ht kb b fv kl ki l kj kk">}</span><span id="cab7" class="kf kg ht kb b fv kl ki l kj kk">//update values in from and to accounts, then save new contents of both accounts</span><span id="46a2" class="kf kg ht kb b fv kl ki l kj kk">src_token_account.amount -= amount;</span><span id="d16e" class="kf kg ht kb b fv kl ki l kj kk">dst_token_account.amount += amount;</span><span id="a209" class="kf kg ht kb b fv kl ki l kj kk">src_token_account.save(from_token_acct)?;</span><span id="779c" class="kf kg ht kb b fv kl ki l kj kk">dst_token_account.save(to_token_acct)?;</span><span id="d8ac" class="kf kg ht kb b fv kl ki l kj kk">}</span></pre><p id="a343" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">一旦我们部署了客户端代码，我们应该在Solana CLI中看到，我们应该看到一个成功完成的交易，以及令牌名称、新生成的余额和两个帐户之间的转帐。</p><p id="617a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">回顾与思考</strong></p><p id="08f9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这篇博客最终肯定比我预期的要长，但当谈到区块链技术及其自动化我们今天做事方式的能力时，真的有太多东西要解开。我希望我写的下一篇博客能够联系到oracles如何与链一起工作，将真实世界的信息与来自智能契约的查询联系起来。如果我想让其他人从中吸取什么的话，那就是区块链技术仍然是一个不断发展的领域，它对去中心化有利有弊，但最终有潜力帮助每个人作为一个社会共同发展。</p><blockquote class="km"><p id="6cbe" class="kn ko ht bd kp kq kr ks kt ku kv jn ek translated">加入Coinmonks <a class="ae kw" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae kw" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="61ce" class="kx kg ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">另外，阅读</h1><ul class=""><li id="850e" class="lu lv ht is b it lw ix lx jb ly jf lz jj ma jn mb mc md me dt translated"><a class="ae kw" rel="noopener" href="/coinmonks/localbitcoins-review-6cc001c6ed56">本地比特币评论</a> | <a class="ae kw" href="https://coincodecap.com/cryptocurrency-savings-accounts" rel="noopener ugc nofollow" target="_blank">加密货币储蓄账户</a></li><li id="4e83" class="lu lv ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated"><a class="ae kw" href="https://coincodecap.com/margin-trading" rel="noopener ugc nofollow" target="_blank">什么是融资融券交易</a> | <a class="ae kw" href="https://coincodecap.com/dca" rel="noopener ugc nofollow" target="_blank">美元成本平均法</a></li><li id="afd7" class="lu lv ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated"><a class="ae kw" href="https://coincodecap.com/uphold-card-review" rel="noopener ugc nofollow" target="_blank">拥护卡审核</a> | <a class="ae kw" href="https://coincodecap.com/trust-wallet-vs-metamask" rel="noopener ugc nofollow" target="_blank">信任钱包vs MetaMask </a></li><li id="5400" class="lu lv ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated"><a class="ae kw" href="https://coincodecap.com/exness-review" rel="noopener ugc nofollow" target="_blank"> Exness评测</a>|<a class="ae kw" href="https://coincodecap.com/bingbon-vs-bitget-vs-moonxbt" rel="noopener ugc nofollow" target="_blank">moon xbt Vs bit get Vs Bingbon</a></li><li id="3eec" class="lu lv ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated"><a class="ae kw" href="https://coincodecap.com/passive-income-crypto-lending" rel="noopener ugc nofollow" target="_blank">如何开始通过加密贷款赚取被动收入</a></li></ul></div></div>    
</body>
</html>