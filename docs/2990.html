<html>
<head>
<title>ABI encode and decode using solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用可靠性ABI编码和解码</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/abi-encode-and-decode-using-solidity-2d372a03e110?source=collection_archive---------1-----------------------#2022-03-21">https://medium.com/coinmonks/abi-encode-and-decode-using-solidity-2d372a03e110?source=collection_archive---------1-----------------------#2022-03-21</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/8123e4cea228a6317ddaabc6e20b7ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YBdRXVbZ8_scWc0Z79Hr9g.jpeg"/></div></div></figure><p id="91d9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">智能契约基本上由状态变量和函数组成。一些函数是私有的，只能从契约内部访问，但是许多函数是公共的，可以从契约外部访问。也就是说，应用程序(和人员)可以向契约发送数据，也可以从契约中检索数据。</p><p id="170f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要向契约发送数据，我们需要以契约可以读取的方式发送数据。也就是说，它们需要被编码。以太坊虚拟机(EVM)的实现定义了如何执行这种编码的规则。规范的细节可以在这里找到<a class="ae jz" href="https://docs.soliditylang.org/en/v0.8.13/abi-spec.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="5f88" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在本文中，我们将学习一些编码规则，以及如何使用solidity来编码和解码必须作为函数参数发送的数据。</p><h1 id="99f5" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">使用abi.encode()编码函数的参数</h1><p id="5931" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">Solidity有一个名为<strong class="jd hu"> abi </strong>的全局变量，它有一个编码方法，所以我们可以用它来编码任何函数的参数。让我们从一个简单的例子开始。假设我们有以下函数</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="1e03" class="lm kb ht li b fv ln lo l lp lq">function myFunction(address _myAddress, uint _myNumber)...</span></pre><p id="8961" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们只对函数的参数编码感兴趣，即一个地址和一个整数。我们可以使用remix创建一个函数来实现这个功能。</p><figure class="ld le lf lg fq iu fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/d439093019c4773c7e6f0ec10aeb2c39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*Af0iTZfXX0qUSb0K2VszNg.png"/></div></figure><p id="637c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">部署这个契约，调用函数<strong class="jd hu"> encode(…) </strong>，使用以下地址和无符号整数的值:(0x 5b 38 da 6a 701 c 568545 DCF CB 03 fcb 875 f 56 bed DC 4，127)，我们得到结果</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="829b" class="lm kb ht li b fv ln lo l lp lq">0x0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4000000000000000000000000000000000000000000000000000000000000007f</span></pre><p id="c2cf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对结果的快速分析表明，它有64个字节。这是因为编码是以32字节的倍数进行的:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="05f6" class="lm kb ht li b fv ln lo l lp lq">0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4<br/>000000000000000000000000000000000000000000000000000000000000007f</span></pre><p id="1d83" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">前32个字节包含地址(20个字节)，其他32个字节包含整数7f。编码总是十六进制，十六进制的7f是127。</p><h1 id="972e" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">使用abi.decode()解码函数的参数</h1><p id="e6de" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">现在让我们用实度来解码一个函数的参数。请注意，没有必要标识我们正在处理的函数，因为它的签名将在编码的参数之前。让问题变得复杂一点，让我们使用动态变量作为参数。</p><p id="fb33" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们使用下面的契约来解码一个值元组:string、uint和string。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="f7a1" class="lm kb ht li b fv ln lo l lp lq">contract Encode {</span><span id="fbe1" class="lm kb ht li b fv ls lo l lp lq">function encode(string memory _string1, uint _uint, string memory _string2) public pure returns (bytes memory) {<br/>        return (abi.encode(_string1, _uint, _string2));<br/>    }</span><span id="3c67" class="lm kb ht li b fv ls lo l lp lq">function decode(bytes memory data) public pure returns (string memory _str1, uint _number, string memory _str2) {<br/>        (_str1, _number, _str2) = abi.decode(data, (string, uint, string));            <br/>    }</span><span id="3df1" class="lm kb ht li b fv ls lo l lp lq">}</span></pre><p id="6936" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">部署，然后用以下参数调用函数<strong class="jd hu">encode(…)</strong>(joo，3，Paulo)，我们得到以下返回:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="902e" class="lm kb ht li b fv ln lo l lp lq">0x0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000054a6fc3a36f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000055061756c6f000000000000000000000000000000000000000000000000000000</span></pre><p id="e2d7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">你可能会期望返回96字节(3 x 32)，因为我们有3个变量。但是，3个变量中有2个是动态的，动态变量的编码就没那么简单了。让我把上面的值分成32字节的数据块。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="4b35" class="lm kb ht li b fv ln lo l lp lq">0000000000000000000000000000000000000000000000000000000000000060<br/>0000000000000000000000000000000000000000000000000000000000000003<br/>00000000000000000000000000000000000000000000000000000000000000a0<br/>0000000000000000000000000000000000000000000000000000000000000005<br/>4a6fc3a36f000000000000000000000000000000000000000000000000000000<br/>0000000000000000000000000000000000000000000000000000000000000005<br/>5061756c6f000000000000000000000000000000000000000000000000000000</span></pre><p id="71ba" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我将快速解释一下在字符串的情况下编码是如何完成的。第一行引用第一个变量，第二行引用第二个变量，第三行引用第三个变量。因为第二个变量的类型是value，所以我们可以在第二行中直接检索它的值<em class="lt"> 3 </em>。</p><p id="9e1a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在变量类型<em class="lt">字符串</em>的情况下，包含在第一行中的数据是关于第一个字符串的信息。本例中，数据十六进制为<em class="lt"> 60 </em>，十进制为<em class="lt"> 96 </em>。但这意味着什么呢？这意味着关于第一个字符串的信息是在从数据开始的96个字节之后找到的。</p><p id="b135" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在92个字节之后，32个字节的块有一个数字:5。这是字符串占用的字节数，从下一行开始，utf-8编码:<em class="lt"> 4a6fc3a36f。从十六进制转换到UTF-8，我们检索到单词‘joo’(碰巧是我的名字)。</em></p><p id="0991" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">按照相同的模式，可以检索a0字节之后的第三个字符串，也就是从数据开始处算起的160字节之后。它说它也有5个字节，它的值是<em class="lt"> 5061756c6f，</em>UTF 8编码的‘Paulo’(也是我的名字，真巧！).</p><p id="7687" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">既然你已经看到了如何手动操作，让我们看看如何通过solidity来操作。使用我们在契约中编写的函数<strong class="jd hu">decode(bytes memory data)</strong>，可以检索编码信息:</p><figure class="ld le lf lg fq iu fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/92dc99ac17f970210ee867ced5b7d450.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*Qtgs3b2mJcIGNTCgq7opTw.png"/></div></figure><p id="167e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">其他库也可以用来对变量进行编码和解码，比如<a class="ae jz" href="https://web3js.readthedocs.io/en/v1.7.1/web3-eth-abi.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jd hu"> web3.eth.abi </strong> </a>。目前也有一个在线网站可以用于此，<a class="ae jz" href="http://abi.hashex.org/" rel="noopener ugc nofollow" target="_blank">abi.hashex.org/</a>。</p><p id="985c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><blockquote class="lv"><p id="14ed" class="lw lx ht bd ly lz ma mb mc md me jy ek translated">加入Coinmonks <a class="ae jz" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jz" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="0e46" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx dt translated">另外，阅读</h1><ul class=""><li id="1824" class="mi mj ht jd b je ky ji kz jm mk jq ml ju mm jy mn mo mp mq dt translated"><a class="ae jz" href="https://coincodecap.com/bybit-binance-moonxbt" rel="noopener ugc nofollow" target="_blank"> Bybit vs币安</a>|<a class="ae jz" rel="noopener" href="/coinmonks/stealthex-review-396c67309988">stealth x回顾</a> | <a class="ae jz" href="https://coincodecap.com/probit-review" rel="noopener ugc nofollow" target="_blank"> Probit回顾</a></li><li id="898a" class="mi mj ht jd b je mr ji ms jm mt jq mu ju mv jy mn mo mp mq dt translated"><a class="ae jz" href="https://coincodecap.com/blockchain-courses" rel="noopener ugc nofollow" target="_blank">顶级付费加密货币和区块链课程</a></li><li id="1380" class="mi mj ht jd b je mr ji ms jm mt jq mu ju mv jy mn mo mp mq dt translated"><a class="ae jz" href="https://coincodecap.com/cbet-casino-review" rel="noopener ugc nofollow" target="_blank"> CBET回顾</a> | <a class="ae jz" href="https://coincodecap.com/kucoin-vs-coinbase" rel="noopener ugc nofollow" target="_blank">库币vs比特币基地</a> | <a class="ae jz" href="https://coincodecap.com/bybit-vs-coinbase" rel="noopener ugc nofollow" target="_blank">拜比特vs比特币基地</a></li><li id="9f68" class="mi mj ht jd b je mr ji ms jm mt jq mu ju mv jy mn mo mp mq dt translated"><a class="ae jz" href="https://coincodecap.com/how-to-buy-cryptocurrency-in-canada" rel="noopener ugc nofollow" target="_blank">如何在加拿大购买加密货币？</a></li><li id="2f70" class="mi mj ht jd b je mr ji ms jm mt jq mu ju mv jy mn mo mp mq dt translated"><a class="ae jz" href="https://coincodecap.com/bored-ape-yacht-club-bayc-review" rel="noopener ugc nofollow" target="_blank">百无聊赖的猿游艇俱乐部(BAYC)评论</a></li></ul></div></div>    
</body>
</html>