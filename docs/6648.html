<html>
<head>
<title>Diving deeper into Cellframe: Key generation performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入研究Cellframe:关键一代性能</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/diving-deeper-into-cellframe-key-generation-performance-36ed1efb0715?source=collection_archive---------18-----------------------#2022-05-12">https://medium.com/coinmonks/diving-deeper-into-cellframe-key-generation-performance-36ed1efb0715?source=collection_archive---------18-----------------------#2022-05-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/f8ab52a6d15160ea4e098684e4047092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AogOHQzF6Pr2NDUZ.png"/></div></figure><p id="ec6e" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">是时候写另一篇文章了！</p><p id="862f" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我决定在Cellframe节点上对“现代”CPU和Raspberry Pi 3B+在密钥生成和Base64解码方面进行性能比较。</p><p id="4071" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">Cellframe中的Python SDK使用对C函数的直接调用来生成密钥和进行Base64解码操作，因此它在任何CPU上都应该相对较快，但是Raspberry Pi如何处理这样的任务呢？</p><p id="0ab8" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">好吧，让我们试试这个，找出答案！</p><p id="6c1d" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu"> <em class="jv">本文仅用于测试目的，并未给出Cellframe节点真实性能的任何“真实”数据。</em> </strong></p><p id="2ff8" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我们走吧！</p></div><div class="ab cl jw jx hb jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hm hn ho hp hq"><h2 id="a9c6" class="kd ke ht bd kf kg kh ki kj kk kl km kn ji ko kp kq jm kr ks kt jq ku kv kw kx dt translated">关于单元格框架</h2><p id="a8df" class="pw-post-body-paragraph ix iy ht iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju hm dt translated">Cellframe是一个雄心勃勃的第三代区块链项目，很少有人(包括我)已经开始谈论它是下一个波尔卡多特或草间弥生。</p><p id="25b8" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">然而，这个项目更加面向服务，并且与Polkadot/Kusama相比具有一些优势(例如，后量子加密、2级分片、P2P跨链操作)。</p><p id="d400" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">Cellframe是用C写的(这将使它快速和可移植)，目前它有一个C和Python的SDK。将来会有更多受支持的语言出现。</p><p id="7788" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我真的推荐访问他们的网站(<a class="ae ld" href="https://cellframe.net/" rel="noopener ugc nofollow" target="_blank">https://cellframe.net</a>)并阅读他们的白皮书！</p></div><div class="ab cl jw jx hb jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hm hn ho hp hq"><h2 id="02e5" class="kd ke ht bd kf kg kh ki kj kk kl km kn ji ko kp kq jm kr ks kt jq ku kv kw kx dt translated">密钥生成器插件</h2><p id="102f" class="pw-post-body-paragraph ix iy ht iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju hm dt translated">首先，我们显然想为Cellframe开发一个插件，它可以自动生成密钥并执行Base64解码操作。让我们做一个名为<code class="eh le lf lg lh b">generatekeys</code>的插件。</p><figure class="lj lk ll lm fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff li"><img src="../Images/58df95bc9b54b830cc2ae20e59e7d7e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y3iK7Tl1csNvczDXJu7vyQ.png"/></div></div></figure><p id="3bbe" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">接下来我决定查看一下<a class="ae ld" href="https://wiki.cellframe.net" rel="noopener ugc nofollow" target="_blank"> Cellframe Wiki </a>，看看有什么方法可以完成这样的任务。</p><p id="c66c" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><code class="eh le lf lg lh b">DAP.Crypto</code>模块看起来是一个复杂的选择。它有一个方法<code class="eh le lf lg lh b">Algo.generateNewKey()</code>和<code class="eh le lf lg lh b">Algo.decodeBase64()</code>那就是我要找的！</p><p id="f398" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><code class="eh le lf lg lh b">generateNewKey()</code>方法允许我们从0-16的数字中选择我想要创建的键类型:</p><pre class="lj lk ll lm fq lr lh ls lt aw lu dt"><span id="3a9b" class="kd ke ht lh b fv lv lw l lx ly">0 -&gt; DAP.Crypto.CryptoKeyType.DAP_ENC_KEY_TYPE_IAES()</span><span id="d607" class="kd ke ht lh b fv lz lw l lx ly">1 -&gt; DAP.Crypto.CryptoKeyType.DAP_ENC_KEY_TYPE_OAES()</span><span id="8d20" class="kd ke ht lh b fv lz lw l lx ly">2 -&gt; DAP.Crypto.CryptoKeyType.DAP_ENC_KEY_TYPE_RLWE_NEWHOPE()</span><span id="2ea7" class="kd ke ht lh b fv lz lw l lx ly">3 -&gt; DAP.Crypto.CryptoKeyType.DAP_ENC_KEY_TYPE_SIDH_CLN16()</span><span id="8fb5" class="kd ke ht lh b fv lz lw l lx ly">4 -&gt; DAP.Crypto.CryptoKeyType.DAP_ENC_KEY_TYPE_DEFEO()</span><span id="b1e1" class="kd ke ht lh b fv lz lw l lx ly">5 -&gt; DAP.Crypto.CryptoKeyType.DAP_ENC_KEY_TYPE_MSRLN()</span><span id="23c9" class="kd ke ht lh b fv lz lw l lx ly">6 -&gt; DAP.Crypto.CryptoKeyType.DAP_ENC_KEY_TYPE_MSRLN16()</span><span id="b8b8" class="kd ke ht lh b fv lz lw l lx ly">7 -&gt; DAP.Crypto.CryptoKeyType.DAP_ENC_KEY_TYPE_RLWE_BCNS15()</span><span id="b898" class="kd ke ht lh b fv lz lw l lx ly">8 -&gt; DAP.Crypto.CryptoKeyType.DAP_ENC_KEY_TYPE_LWE_FRODO()</span><span id="a6d9" class="kd ke ht lh b fv lz lw l lx ly">9 -&gt; DAP.Crypto.CryptoKeyType.DAP_ENC_KEY_TYPE_SIDH_IQC_REF()</span><span id="aab0" class="kd ke ht lh b fv lz lw l lx ly">10 -&gt; DAP.Crypto.CryptoKeyType.DAP_ENC_KEY_TYPE_CODE_MCBITS()</span><span id="167a" class="kd ke ht lh b fv lz lw l lx ly">11 -&gt; DAP.Crypto.CryptoKeyType.DAP_ENC_KEY_TYPE_NTRU()</span><span id="adec" class="kd ke ht lh b fv lz lw l lx ly">12 -&gt; DAP.Crypto.CryptoKeyType.DAP_ENC_KEY_TYPE_MLWE_KYBER()</span><span id="4297" class="kd ke ht lh b fv lz lw l lx ly">13 -&gt; DAP.Crypto.CryptoKeyType.DAP_ENC_KEY_TYPE_SIG_PICNIC()</span><span id="2ad2" class="kd ke ht lh b fv lz lw l lx ly">14 -&gt; DAP.Crypto.CryptoKeyType.DAP_ENC_KEY_TYPE_SIG_BLISS()</span><span id="ebb1" class="kd ke ht lh b fv lz lw l lx ly">15 -&gt; DAP.Crypto.CryptoKeyType.DAP_ENC_KEY_TYPE_SIG_TESLA()</span><span id="319e" class="kd ke ht lh b fv lz lw l lx ly">16 -&gt; DAP.Crypto.CryptoKeyType.DAP_ENC_KEY_TYPE_SIG_DILITHIUM()</span></pre><p id="00b7" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">从这个列表中，我决定用<code class="eh le lf lg lh b">DAP_ENC_KEY_TYPE_BLISS</code>。</p><p id="c015" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">对于Base64操作，<code class="eh le lf lg lh b">Algo.decodeBase64()</code>方法接受一个简单的字符串作为输入，所以我们将使用它进行测试。</p><p id="af0b" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">所以经过一番思考，我想到了这个:</p><figure class="lj lk ll lm fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff ma"><img src="../Images/c5577032ed8df43295b36eb286dcd9a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t2IWqW0YWks09HrkeTMxzw.png"/></div></div></figure><p id="058d" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在，我刚刚在笔记本电脑上启动了Cellframe node，并检查了生成500个新的BLISS key对象和执行500次Base64解码操作需要多少毫秒:</p><pre class="lj lk ll lm fq lr lh ls lt aw lu dt"><span id="703f" class="kd ke ht lh b fv lv lw l lx ly">It took 0.01 seconds to generate 500 keys and to do 500 of decodeBase64 operations</span></pre><p id="7f8d" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">嗯，好吧。那这个数目太小了。让我们生成稍微多一点。10000把钥匙应该足够了:</p><figure class="lj lk ll lm fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff ma"><img src="../Images/80a293af376c35b369ac11c912b5536f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*47FcZL2pESZxMnjxuYc45Q.png"/></div></div></figure><pre class="lj lk ll lm fq lr lh ls lt aw lu dt"><span id="7d17" class="kd ke ht lh b fv lv lw l lx ly">It took 0.30 seconds to generate 10000 keys and to do 10000 of decodeBase64 operations</span></pre><p id="f4a9" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在看起来稍微好一点。0.30秒在我的笔记本电脑上生成10000个新密钥。</p><p id="e455" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在我决定测试这个插件在3B+上能运行多长时间。运行这个插件给了我以下结果:</p><pre class="lj lk ll lm fq lr lh ls lt aw lu dt"><span id="3d05" class="kd ke ht lh b fv lv lw l lx ly">It took 2.88 seconds to generate 10000 keys and to do 10000 of decodeBase64 operations</span></pre><p id="a662" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">因此，在Raspberry Pi 3B+上生成10000个关键对象的结果大约是2.9秒。这比我的旧笔记本电脑大约慢10倍😆。</p><p id="eb8e" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">实际上我很惊讶它“仅仅”慢了10倍。我本以为老款树莓派的性能会低得多。</p><h2 id="ce09" class="kd ke ht bd kf kg kh ki kj kk kl km kn ji ko kp kq jm kr ks kt jq ku kv kw kx dt translated">那么穿线呢？</h2><p id="d2a3" class="pw-post-body-paragraph ix iy ht iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju hm dt translated">我还决定测试一下，如果我添加一个单独的线程来完成这项工作，是否会改善Raspberry Pi的结果:</p><figure class="lj lk ll lm fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff ma"><img src="../Images/718aa97944e1d9ab67d5ee0a8ec7e6c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NZpEdp4Yp72NFADtupUPMQ.png"/></div></div></figure><p id="df5e" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在我的笔记本电脑上进行的第一次测试给出了以下结果:</p><pre class="lj lk ll lm fq lr lh ls lt aw lu dt"><span id="f94f" class="kd ke ht lh b fv lv lw l lx ly">It took 0.24 seconds to generate 10000 keys and to do 10000 of decodeBase64 operations</span></pre><p id="4220" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这比没有线程时快了0.06秒。让我们看看树莓派对此是怎么说的:</p><pre class="lj lk ll lm fq lr lh ls lt aw lu dt"><span id="02ff" class="kd ke ht lh b fv lv lw l lx ly">It took 2.63 seconds to generate 10000 keys and to do 10000 of decodeBase64 operations</span></pre><p id="fdc1" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">快了0.25秒。我想不值得。</p><h2 id="bd2a" class="kd ke ht bd kf kg kh ki kj kk kl km kn ji ko kp kq jm kr ks kt jq ku kv kw kx dt translated">结论</h2><p id="0c0d" class="pw-post-body-paragraph ix iy ht iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju hm dt translated">正如我提到的，这篇文章只是为了测试，让我研究强大的Cellframe Python SDK。</p><p id="3066" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">可能有多种更好的方法来进行这些测试，但我只向您展示了一种方法😉。</p><p id="4044" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">正如我在之前的基准测试文章中提到的:当我们让Cellframe节点运行在比树莓派快4倍的现代手机上时，它将改变整个区块链行业的游戏规则！</p><p id="80d2" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">顺便说一下，我试图生成一百万个密钥，并进行一百万次Base64解码操作。当我在运行测试的同时写这篇文章时，我的Raspberry Pi仍然处于冻结状态(已经15分钟了)。</p><figure class="lj lk ll lm fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mb"><img src="../Images/5ef26d787942b57e5ccd6a6b25d78ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mpzyz_lXxlVtQ1jpOXLcrg.png"/></div></div><figcaption class="mc md fg fe ff me mf bd b be z ek">Can’t login 😢</figcaption></figure><h2 id="fa20" class="kd ke ht bd kf kg kh ki kj kk kl km kn ji ko kp kq jm kr ks kt jq ku kv kw kx dt translated">对Cellframe上的建筑感兴趣吗？</h2><p id="d20c" class="pw-post-body-paragraph ix iy ht iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju hm dt translated">加入他们的发展电报渠道:<a class="ae ld" href="https://t.me/cellframe_dev_en" rel="noopener ugc nofollow" target="_blank">https://t.me/cellframe_dev_en</a></p><p id="3cc2" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">如果您有任何问题或对区块链的未来感兴趣，也可以联系我:</p><p id="9e78" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">电报:</strong>@ CELLgainz<br/>T5】推特: @CELLgainz</p></div></div>    
</body>
</html>