<html>
<head>
<title>The difference between bytecode and deployed bytecode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">字节码和部署的字节码之间的区别</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/the-difference-between-bytecode-and-deployed-bytecode-64594db723df?source=collection_archive---------2-----------------------#2022-04-18">https://medium.com/coinmonks/the-difference-between-bytecode-and-deployed-bytecode-64594db723df?source=collection_archive---------2-----------------------#2022-04-18</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/e6062d2fb20a3e9326cf3e587f96cb1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8oRytujDaqSfSjYpX3D8jA.jpeg"/></div></div></figure><p id="9cc1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果您检查Remix或Truffle生成的JSON文件，在编译智能合约时，您会注意到它包含两种不同的字节码:字节码和部署的字节码。其他IDE可能会对这些字节码中的一个使用不同的名称。</p><p id="77e8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">其中之一，通常称为字节码，是将被发送到网络用于创建智能契约的二进制代码。另一个是部署的字节码，是存储在区块链上的二进制代码，每次调用契约时都会执行。</p><p id="6328" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这样，字节码将比部署的字节码有更多的字节。(被调用的)字节码是初始代码和部署的字节码的连接。我们先看这个，然后解释初始代码的用途。</p><h1 id="dda9" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">字节码和部署的字节码</h1><p id="bac9" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">让我们使用一个简单的契约，如下所示:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="81a2" class="ll ka ht lh b fv lm ln l lo lp">pragma solidity ^0.8.7;  </span><span id="a55f" class="ll ka ht lh b fv lq ln l lo lp">contract TestBytecode {      </span><span id="834b" class="ll ka ht lh b fv lq ln l lo lp">   uint public valor;      </span><span id="23b4" class="ll ka ht lh b fv lq ln l lo lp">   constructor() {         <br/>      valor = 3;     <br/>   }       </span><span id="99cf" class="ll ka ht lh b fv lq ln l lo lp">   function setValor(uint _valor) public {         <br/>      valor = _valor;     <br/>   }  <br/>}</span></pre><p id="6ad1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">契约的唯一目的是存储一个可以改变的变量。可以在Remix上试试。编译完成后，在<em class="lr">契约/工件</em>文件夹中，你会发现一个名为<em class="lr"> TestBytecode.json </em>的文件。在它里面，有两个字节码，如下图所示:</p><figure class="lc ld le lf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ls"><img src="../Images/6185b6d951ad8539ccd632cd445ee510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kw5FyBpUy2xYsP1A10tUIA.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">One can find the bytecode and the deployedBytecode in Remix.</figcaption></figure><p id="49e7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我将复制并粘贴下面的代码。字节码是:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="d28b" class="ll ka ht lh b fv lm ln l lo lp">608060405234801561001057600080fd5b506003600081905550610133806100286000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c8063428706be146037578063ecbac7cf14604f575b600080fd5b604d600480360381019060499190608c565b6069565b005b60556073565b6040516060919060c1565b60405180910390f35b8060008190555050565b60005481565b60008135905060868160e9565b92915050565b600060208284031215609f57609e60e4565b5b600060ab848285016079565b91505092915050565b60bb8160da565b82525050565b600060208201905060d4600083018460b4565b92915050565b6000819050919050565b600080fd5b60f08160da565b811460fa57600080fd5b5056fea264697066735822122017a6da1fa9164307c08790caa5572a978138abb0de859b5ab8dd35d9976a661b64736f6c63430008070033</span></pre><p id="606a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">部署的字节码是:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="5c94" class="ll ka ht lh b fv lm ln l lo lp">6080604052348015600f57600080fd5b506004361060325760003560e01c8063428706be146037578063ecbac7cf14604f575b600080fd5b604d600480360381019060499190608c565b6069565b005b60556073565b6040516060919060c1565b60405180910390f35b8060008190555050565b60005481565b60008135905060868160e9565b92915050565b600060208284031215609f57609e60e4565b5b600060ab848285016079565b91505092915050565b60bb8160da565b82525050565b600060208201905060d4600083018460b4565b92915050565b6000819050919050565b600080fd5b60f08160da565b811460fa57600080fd5b5056fea264697066735822122017a6da1fa9164307c08790caa5572a978138abb0de859b5ab8dd35d9976a661b64736f6c63430008070033</span></pre><p id="c7c8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">请注意，第一个比第二个大。再深入一点，你会注意到第一个包含了第二个。为了检查这一点，一个技巧是寻找第一个操作码<em class="lr"> 0xfe </em>。它可能标志着初始代码的结束和部署的字节码的开始。我在下图中标记了它:</p><figure class="lc ld le lf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lx"><img src="../Images/f8936c95e6961ff88aacc60e316a7b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I6diIt7cnDPrAPHXsmwEig.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">The code tagged is the initial code. What is left is the deployed bytecode.</figcaption></figure><p id="f393" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们看一个更简单的合同。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="cc20" class="ll ka ht lh b fv lm ln l lo lp">pragma solidity ^0.8.7;  </span><span id="71fa" class="ll ka ht lh b fv lq ln l lo lp">contract TestBytecodeAgain {      <br/>   constructor() {}  <br/>}</span></pre><p id="2e55" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">生成了两个字节码。第一个是完整的代码，包括初始代码和将存储在区块链上的代码。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="a5d5" class="ll ka ht lh b fv lm ln l lo lp">6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea2646970667358221220255c2a05777f8a56db0a092845f057844163d0fef9104cafc45164eaf10f2dcd64736f6c63430008070033</span></pre><p id="eb16" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第二个问题是区块链号上将储存什么。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="f3c2" class="ll ka ht lh b fv lm ln l lo lp">6080604052600080fdfea2646970667358221220255c2a05777f8a56db0a092845f057844163d0fef9104cafc45164eaf10f2dcd64736f6c63430008070033</span></pre><p id="4edf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">正如我们在下图中再次看到的，字节码包含初始代码和部署的字节码。</p><figure class="lc ld le lf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ly"><img src="../Images/112736bd5c1c9277c7fc3c48e9b1cc70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u_-ThnVpL6b4SFbYK24rug.png"/></div></div></figure><h1 id="0d5f" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">初始代码的目的是什么？</h1><p id="b209" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">只运行一次的智能合约函数是它的构造函数。没有必要将此功能存储在区块链上，因为它不能再次执行。因此，它的执行是在初始代码中编写的，而不是在部署的字节码中。</p><p id="caa5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">此外，用户可以在合同创建后立即向其发送本币，因此有必要验证合同是否接受本币。该检查在部署时运行，如果创建者向不接受本地货币的合同发送本地货币，则应恢复合同创建。</p><p id="cafa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这向我们表明，有一个完整的脚本必须只在部署时执行，并且这个脚本包含在初始代码中。这就是为什么有两个二进制代码:一个必须在创建合同时发送，其中包含初始代码，另一个将存储在区块链上。</p><p id="d1a1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="95a6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">伊娃·戈洛贝特斯在<a class="ae lz" href="https://unsplash.com/s/photos/binary-code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p><blockquote class="ma"><p id="6a22" class="mb mc ht bd md me mf mg mh mi mj jy ek translated">加入Coinmonks <a class="ae lz" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae lz" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="6329" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk mk km kn ko ml kq kr ks mm ku kv kw dt translated">另外，阅读</h1><ul class=""><li id="b5fe" class="mn mo ht jd b je kx ji ky jm mp jq mq ju mr jy ms mt mu mv dt translated"><a class="ae lz" rel="noopener" href="/coinmonks/3commas-review-an-excellent-crypto-trading-bot-2020-1313a58bec92">3商业评论</a> | <a class="ae lz" href="https://coincodecap.com/pionex-review-exchange-with-crypto-trading-bot" rel="noopener ugc nofollow" target="_blank"> Pionex评论</a> | <a class="ae lz" rel="noopener" href="/coinmonks/coinrule-review-2021-a-beginner-friendly-crypto-trading-bot-daf0504848ba"> Coinrule评论</a></li><li id="88bc" class="mn mo ht jd b je mw ji mx jm my jq mz ju na jy ms mt mu mv dt translated"><a class="ae lz" rel="noopener" href="/coinmonks/ledger-vs-ngrave-zero-7e40f0c1d694">莱杰vs n rave</a>|<a class="ae lz" rel="noopener" href="/coinmonks/ledger-nano-s-vs-x-battery-hardware-price-storage-59a6663fe3b0">莱杰nano s vs x </a> | <a class="ae lz" rel="noopener" href="/coinmonks/binance-review-ee10d3bf3b6e">币安评论</a></li><li id="b88f" class="mn mo ht jd b je mw ji mx jm my jq mz ju na jy ms mt mu mv dt translated"><a class="ae lz" rel="noopener" href="/coinmonks/bybit-exchange-review-dbd570019b71"> Bybit Exchange评论</a> | <a class="ae lz" href="https://coincodecap.com/bityard-reivew" rel="noopener ugc nofollow" target="_blank"> Bityard评论</a> | <a class="ae lz" href="https://coincodecap.com/jet-bot-review" rel="noopener ugc nofollow" target="_blank"> Jet-Bot评论</a></li><li id="4e19" class="mn mo ht jd b je mw ji mx jm my jq mz ju na jy ms mt mu mv dt translated"><a class="ae lz" rel="noopener" href="/coinmonks/3commas-vs-pionex-vs-cryptohopper-best-crypto-bot-6a98d2baa203">3 commas vs crypto hopper</a>|<a class="ae lz" rel="noopener" href="/coinmonks/earn-crypto-interest-b10b810fdda3">赚取秘密利息</a></li><li id="fab2" class="mn mo ht jd b je mw ji mx jm my jq mz ju na jy ms mt mu mv dt translated">最好的比特币<a class="ae lz" rel="noopener" href="/coinmonks/hardware-wallets-dfa1211730c6">硬件钱包</a> | <a class="ae lz" rel="noopener" href="/coinmonks/bitbox02-review-your-swiss-bitcoin-hardware-wallet-c36c88fff29"> BitBox02回顾</a></li></ul></div></div>    
</body>
</html>