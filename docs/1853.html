<html>
<head>
<title>How to Build a Full Stack Decentralized Application (dApp)?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建全栈去中心化应用(dApp)？</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/how-to-build-a-full-stack-decentralized-application-dapp-abd5a27292bd?source=collection_archive---------3-----------------------#2022-03-07">https://medium.com/coinmonks/how-to-build-a-full-stack-decentralized-application-dapp-abd5a27292bd?source=collection_archive---------3-----------------------#2022-03-07</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="1f87" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">构建分散式应用程序(dApp)的分步指南</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/1fc957e11ac2f6046fb321b5aba8a9aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L-XTgbLut56on4hTyGxoAg.jpeg"/></div></div></figure><p id="5662" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">今天我将向你展示如何在以太坊区块链上构建你的第一个去中心化应用程序(dApp)。我将向您展示如何编写您的第一个以太坊智能合同，其中我们将在两个候选人之间进行选举。我们将针对智能合约编写测试，将其部署到以太坊区块链，并开发一个允许帐户投票的客户端应用程序。我们还将研究一些关键概念，如“什么是区块链？”，“什么是智能合约？”，以及“dApp如何工作？”。</p><p id="a0bd" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在我们开始构建我们的dApp之前，让我们检查一些关键概念。</p><h1 id="bbbc" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">什么是区块链？</h1><p id="20d3" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">让我们用一个类比来理解什么是区块链以及它是如何工作的。让我们看一个web应用程序。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/5454f36eba9840051c0e3c22f8b463d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*L60YdsGolSgGTnDcnH6sCA.png"/></div></figure><p id="0bdb" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">通常，当您与web应用程序交互时，您使用web浏览器通过网络连接到中央服务器。这个web应用程序的所有代码都保存在这个中央服务器上，所有数据都保存在一个中央数据库中。每当您处理应用程序时，都必须与web上的这个中央服务器进行通信。</p><p id="0e21" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">如果我们要在web上构建投票应用程序，我们会遇到一些问题:</p><ol class=""><li id="8646" class="lo lp ht jw b jx jy ka kb kd lq kh lr kl ls kp lt lu lv lw dt translated">数据库中的数据可能会被更改:它可能会被多次计数，或者被完全删除。</li><li id="2c44" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp lt lu lv lw dt translated">web服务器上的源代码也可以随时更改。</li></ol><p id="432e" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们不想在网络上构建我们的应用程序。我们希望将它建立在区块链上，任何连接到网络的人都可以参加选举。我们希望确保他们的选票被计算在内，而且只被计算一次。让我们来看看它是如何工作的。</p><p id="8e67" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">与网络、中央服务器和数据库不同，<em class="mc">区块链集网络和数据库于一身</em>。区块链是计算机的对等网络，称为节点，共享网络中的所有数据和代码。因此，如果你是一台连接到区块链的设备，你就是网络中的一个节点，你与网络中的所有其他计算机节点进行通信。您现在拥有了区块链上所有数据和代码的副本。不再有中央服务器了。只是一堆在同一个网络上互相交流的计算机。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff md"><img src="../Images/df1be04a70a14ee6c0e019911919b6b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*uFJ2Dg1i8Cr89P9GqyE9Kg.png"/></div></figure><p id="29bb" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">与集中式数据库不同，所有在区块链节点间共享的交易数据都包含在被称为块的<em class="mc">记录包中，这些记录被链接在一起</em>以创建公共分类账。该公共分类账代表区块链中的所有数据。公共分类账中的所有数据都通过加密哈希进行保护，并通过一致算法进行验证。网络上的节点参与进来，以确保分布在网络上的所有数据副本都是相同的。这是我们在区块链上构建投票应用程序的一个非常重要的原因，因为我们希望确保我们的投票被计算在内，并且不会改变。</p><p id="7799" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们应用程序的用户在区块链上投票会是什么样子？首先，用户需要一个账户，这个账户的钱包地址要有以太，以太坊的加密货币。一旦他们连接到网络，他们投下自己的一票，并支付少量交易费，以将此交易写入区块链。这个交易费叫“气”。每当投票时，网络上的一些称为矿工的节点竞争完成这一事务。完成这项交易的矿工将获得我们投票购买的乙醚。</p><p id="09d4" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">概括地说，当我投票时，我支付汽油价格来投票，当我的投票被记录时，网络上的一台计算机会支付我的以太费。反过来，我相信我的投票会被永远准确地记录下来。</p><p id="4608" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">因此，同样重要的是要注意，在区块链上投票需要时间，但仅仅看到候选人名单并不需要时间。这是因为从区块链读取数据是免费的，但写入数据却不是。</p><h1 id="4da0" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">什么是智能合同？</h1><p id="2f68" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">这就是投票过程的工作方式，但是我们实际上如何编写我们的应用程序呢？嗯，以太坊区块链允许我们用区块链上的以太坊虚拟机(EVM)通过一种叫做智能合约的东西来执行代码。</p><p id="32a2" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">智能合约是我们应用程序的所有业务逻辑所在。这是我们实际编写应用程序分散部分的地方。智能合约负责向区块链读写数据，以及执行业务逻辑。智能联系人是用一种叫做<a class="ae me" href="https://solidity.readthedocs.io/en/v0.4.21/" rel="noopener ugc nofollow" target="_blank"> Solidity </a>的编程语言编写的，看起来很像Javascript。它是一种成熟的编程语言，允许我们做许多与Javascript相同类型的事情，但由于它的用例，它的行为有点不同，我们将在本教程中看到。</p><p id="1438" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">区块链上的智能合约的功能非常类似于网络上的微服务。如果公共分类帐代表区块链的数据库层，那么智能合同就是处理该数据的所有业务逻辑所在的地方。</p><p id="7a54" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">此外，它们被称为智能合同，因为它们代表一个契约或协议。在我们的投票dApp的情况下，这是一个协议，我的票将被计算在内，其他的票只被计算一次，拥有最多选票的候选人将赢得选举。</p><p id="fc28" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在让我们快速看一下我们正在构建的dApp的结构。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/1bd2b440d07168746aebf5d21b9460ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*6Jl4qiCP9xec6nQ4Hnc6Mg.png"/></div></figure><p id="46e6" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们将拥有一个用HTML、CSS和Javascript编写的传统前端客户端。这个客户端将连接到我们将要安装的本地以太坊区块链，而不是与后端服务器对话。我们将使用Solidity编程语言在选举智能契约中编写关于dApp的所有业务逻辑。我们将这个智能合约部署到我们本地的以太坊区块链，并允许帐户开始投票。</p><p id="5576" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在我们已经了解了什么是区块链以及它是如何工作的。我们已经看到了为什么我们要在区块链而不是现在的网络上建立我们的投票dApp。我们已经看到，我们希望通过编写一个将部署到以太坊区块链的智能合约来编写我们的dApp。现在让我们开始编程吧！</p><h1 id="ea21" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">我们将会建造什么</h1><p id="e1f0" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">这是我们将要建立的投票dApp的演示。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mg"><img src="../Images/4c9a6d0cf17c2184d6ff690af7001b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*L18vW9VCCM2hBPBK0cSK8A.gif"/></div></div></figure><p id="7ba3" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们将构建一个客户端应用程序，它将在区块链上与我们的智能合约对话。这个客户端应用程序将有一个候选人表，列出每个候选人的id、姓名和票数。它将有一个表格，我们可以为我们想要的候选人投票。它还在“您的帐户”下显示了我们连接到区块链的帐户。</p><h1 id="e9ce" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">安装依赖项</h1><p id="c5a4" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">为了构建我们的dApp，我们首先需要一些依赖项。</p><h1 id="61b2" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">节点程序包管理器(NPM)</h1><p id="7c9c" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">我们需要的第一个依赖项是Node.js附带的<a class="ae me" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点包管理器</a>或NPM。您可以查看是否已经安装了节点，方法是在终端上键入:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="4d9b" class="mm kr ht mi b fv mn mo l mp mq">$ node -v</span></pre><h1 id="7c86" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">块菌框架</h1><p id="7ff7" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">下一个依赖项是<a class="ae me" href="http://truffleframework.com/" rel="noopener ugc nofollow" target="_blank">松露框架</a>，它允许我们在以太坊区块链上构建分散的应用程序。它提供了一套工具，允许我们用Solidity编程语言编写智能合同。它还使我们能够测试我们的智能合同，并将其部署到区块链。它还为我们提供了一个开发客户端应用程序的地方。</p><p id="cfd7" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">您可以在命令行中安装带有NPM的松露，如下所示:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="d76f" class="mm kr ht mi b fv mn mo l mp mq">$ npm install -g truffle</span></pre><h1 id="5230" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">加纳切</h1><p id="f6bb" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">下一个依赖项是<a class="ae me" href="http://truffleframework.com/ganache" rel="noopener ugc nofollow" target="_blank"> Ganache </a>，一个本地内存区块链。你可以从Truffle框架网站下载<a class="ae me" href="http://truffleframework.com/ganache" rel="noopener ugc nofollow" target="_blank">来安装Ganache。它会给我们10个外部帐户的地址在我们当地的以太坊区块链。每个账号都预装了100个假醚。</a></p><h1 id="8f5d" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">元掩码</h1><p id="08d6" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">下一个依赖项是Google Chrome 的<a class="ae me" href="https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn?hl=en" rel="noopener ugc nofollow" target="_blank">元掩码扩展。为了使用区块链，我们必须连接到它(记住，我说过区块链是一个网络)。为了使用以太坊区块链，我们必须安装一个特殊的浏览器扩展。这就是metamask的用武之地。我们将能够使用我们的个人账户连接到我们当地的以太坊区块链，并与我们的智能合约进行交互。</a></p><p id="a0da" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在本教程中，我们将使用Metamask chrome扩展，所以如果你还没有谷歌chrome浏览器，你也需要安装它。要安装Metamask，请在Google Chrome网络商店中搜索Metamask Chrome插件。一旦你安装了它，确保它在你的扩展列表中被选中。安装Chrome浏览器后，你会在浏览器的右上角看到狐狸图标。如果你卡住了，参考视频演练！</p><h1 id="b728" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">语法突出显示</h1><p id="f51f" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">依赖是可选的，但是我建议为<a class="ae me" href="https://solidity.readthedocs.io/en/v0.4.21/" rel="noopener ugc nofollow" target="_blank"> Solidity </a>编程语言安装语法高亮。大多数文本编辑器和ide没有突出显示语法的功能，所以你必须安装一个包来支持它。我正在使用<a class="ae me" href="https://www.sublimetext.com/" rel="noopener ugc nofollow" target="_blank">崇高文本</a>，并且我已经下载了<a class="ae me" href="https://packagecontrol.io/packages/Ethereum" rel="noopener ugc nofollow" target="_blank">“以太坊”软件包</a>，它提供了很好的语法高亮显示以保证可靠性。</p><h1 id="898e" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">第一步:烟雾测试</h1><p id="0798" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">现在我们已经安装了依赖项，让我们开始构建dApp吧！</p><p id="4cc7" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">首先，找到你下载Ganache的地方，打开它。现在，Ganache已经启动，您有一个本地区块链运行。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mr"><img src="../Images/7a17f20001a1187ce5fd5d29d9c2d56a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qAmFoR1gmn2I96oVlvcM2A.gif"/></div></div></figure><p id="ba6b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">Ganache给了我们10个预装了100个假以太的账号(这个在主以太网上一文不值)。每个帐户都有唯一的地址和私钥。在我们的选举中，每个帐户地址将作为每个选民的唯一标识符。</p><p id="3254" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在，让我们在命令行中为dApp创建一个项目目录，如下所示:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="f1a3" class="mm kr ht mi b fv mn mo l mp mq">$ mkdir election<br/>$ cd election</span></pre><p id="b4e0" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在我们已经进入了我们的项目，我们可以用一个<a class="ae me" href="http://truffleframework.com/boxes/" rel="noopener ugc nofollow" target="_blank">块菌盒子</a>快速启动并运行。在本教程中，我们将使用<a class="ae me" href="http://truffleframework.com/boxes/pet-shop" rel="noopener ugc nofollow" target="_blank">宠物店盒子</a>。在您的项目目录中，从命令行安装pet shop box，如下所示:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="91d2" class="mm kr ht mi b fv mn mo l mp mq">$ truffle unbox pet-shop</span></pre><p id="53d3" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">让我们看看宠物店盒子给了我们什么:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/e2283b3ab4e36ec648bcf79a8080abc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*-JzDk-wgLDIpiUGsFSFhgw.png"/></div></figure><ul class=""><li id="a56e" class="lo lp ht jw b jx jy ka kb kd lq kh lr kl ls kp mt lu lv lw dt translated"><strong class="jw hu">合同目录:</strong>这是所有智能联系人所在的位置。我们已经有了一份移民合同，处理我们到区块链的移民事宜。</li><li id="4c19" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp mt lu lv lw dt translated"><strong class="jw hu">迁移目录</strong>:这是所有迁移文件所在的位置。这些迁移类似于其他需要迁移来改变数据库状态的web开发框架。每当我们在区块链部署智能合约时，我们都在更新区块链的状态，因此需要迁移。</li><li id="9233" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp mt lu lv lw dt translated"><strong class="jw hu"> node_modules目录:</strong>这是我们所有节点依赖项的主目录。</li><li id="4522" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp mt lu lv lw dt translated">src目录:这是我们开发客户端应用程序的地方。</li><li id="1895" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp mt lu lv lw dt translated"><strong class="jw hu">测试目录:</strong>这是我们为智能合约编写测试的地方。</li><li id="8eea" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp mt lu lv lw dt translated"><strong class="jw hu"> truffle.js文件:</strong>这是我们的truffle项目的主要配置文件</li></ul><p id="4f17" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在让我们开始编写我们的智能合同吧！这个智能合同将包含我们dApp的所有业务逻辑。它将负责读取和写入以太坊区块链。它将允许我们列出将参加选举的候选人，并跟踪所有的选票和选民。它还将管理选举的所有规则，比如强制帐户只能投票一次。从项目的根目录开始，在contracts目录中创建一个新的合同文件，如下所示:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="b8c8" class="mm kr ht mi b fv mn mo l mp mq">$ touch contracts/Election.sol</span></pre><p id="bd2e" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">让我们从创建一个“冒烟测试”开始，它将确保我们已经正确地设置了我们的项目，并且我们可以成功地将合同部署到区块链。打开文件，从以下代码开始:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="fd73" class="mm kr ht mi b fv mn mo l mp mq">pragma solidity 0.4.2;</span><span id="904f" class="mm kr ht mi b fv mu mo l mp mq">contract Election {<br/>    // Read/write candidate<br/>    string <strong class="mi hu">public</strong> candidate;</span><span id="ebde" class="mm kr ht mi b fv mu mo l mp mq">    // Constructor<br/>    function <strong class="mi hu">Election</strong> () <strong class="mi hu">public</strong> {<br/>        candidate = "Candidate 1";<br/>    }<br/>}</span></pre><p id="aac6" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我来解释一下这段代码。我们从用<code class="eh mv mw mx mi b">pragma solidity</code>语句声明solidity版本开始。接下来，我们用“contract”关键字声明智能合约，后跟合约名称。接下来，我们声明一个状态变量，它将存储候选人姓名的值。状态变量允许我们将数据写入区块链。我们已经声明这个变量将是一个字符串，并且我们已经将它的可见性设置为<code class="eh mv mw mx mi b">public</code>。因为它是公共的，所以solidity将免费给我们一个getter函数，允许我们在契约之外访问这个值。我们将在稍后的控制台中看到这一点！</p><p id="d7d5" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">然后，我们创建一个构造函数，每当我们将智能合约部署到区块链时，都会调用这个函数。在这里，我们将设置候选状态变量的值，该变量将在迁移时存储到区块链中。请注意，构造函数与智能协定同名。Solidity就是这样知道函数是构造函数的。</p><p id="107e" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在，我们已经为智能合约创建了基础，让我们看看是否可以将它部署到区块链。为此，我们需要在迁移目录中创建新文件。从项目根目录中，通过命令行创建一个新文件，如下所示:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="0355" class="mm kr ht mi b fv mn mo l mp mq">$ touch migrations/2_deploy_contracts.js</span></pre><p id="fcb8" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">请注意，我们用数字给迁移目录中的所有文件编号，以便Truffle知道以什么顺序执行它们。让我们创建一个新的迁移来部署合同，如下所示:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="8293" class="mm kr ht mi b fv mn mo l mp mq"><strong class="mi hu">var</strong> Election = artifacts.require("./Election.sol");</span><span id="b811" class="mm kr ht mi b fv mu mo l mp mq">module.exports = <strong class="mi hu">function</strong>(deployer) {<br/>  deployer.deploy(Election);<br/>};</span></pre><p id="53a1" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">首先，我们需要我们已经创建的契约，并将其分配给一个名为“Election”的变量。接下来，我们将它添加到已部署契约的清单中，以确保它在我们运行迁移时得到部署。现在，让我们像这样从命令行运行我们的迁移:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="31c1" class="mm kr ht mi b fv mn mo l mp mq">$ truffle migrate</span></pre><p id="2d94" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在我们已经成功地将智能合约迁移到本地以太坊区块链，让我们打开控制台与智能合约进行交互。您可以从命令行打开truffle控制台，如下所示:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="5268" class="mm kr ht mi b fv mn mo l mp mq">$ truffle console</span></pre><p id="c24f" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在我们已经进入了控制台，让我们获取一个已部署的智能契约的实例，看看是否可以从契约中读取候选人的姓名。从控制台中，运行以下代码:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="ef37" class="mm kr ht mi b fv mn mo l mp mq">Election.deployed().then(<strong class="mi hu">function</strong>(instance) { app = instance })</span></pre><p id="07e5" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这里的<code class="eh mv mw mx mi b">Election</code>是我们在迁移文件中创建的变量的名称。我们用<code class="eh mv mw mx mi b">deployed()</code>函数检索了一个已部署的契约实例，并将其分配给promise回调函数中的一个<code class="eh mv mw mx mi b">app</code>变量。</p><p id="b73a" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在我们可以这样读取候选变量的值:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="a5f6" class="mm kr ht mi b fv mn mo l mp mq">app.candidate()<br/>// =&gt; 'Candidate 1'</span></pre><p id="1b03" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">恭喜你！您刚刚编写了第一个智能合约，将其部署到区块链，并检索了其中的一些数据。</p><h1 id="fd6e" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">第二步:列出候选人</h1><p id="18d5" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">现在一切都设置妥当了，让我们继续通过列出将参加选举的候选人来建立聪明的联系。我们需要一种方法来存储多个候选项，并存储每个候选项的多个属性。我们希望跟踪候选人的id、姓名和票数。以下是我们对候选人的建模方式:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="3796" class="mm kr ht mi b fv mn mo l mp mq">contract Election {<br/>    // Model a Candidate<br/>    <strong class="mi hu">struct</strong> Candidate {<br/>        <strong class="mi hu">uint</strong> id;<br/>        <strong class="mi hu">string</strong> name;<br/>        <strong class="mi hu">uint</strong> voteCount;<br/>    }</span><span id="1d48" class="mm kr ht mi b fv mu mo l mp mq">    // ...<br/>}</span></pre><p id="fb7e" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们已经用<a class="ae me" href="https://solidity.readthedocs.io/en/v0.4.21/structure-of-a-contract.html?highlight=struct#structure-struct-types" rel="noopener ugc nofollow" target="_blank">坚固结构</a>为候选人建模。坚固性允许我们创建自己的结构类型，就像我们在这里为我们的候选人所做的那样。我们指定该结构具有无符号整数类型的id、字符串类型的名称和无符号整数类型的voteCount。简单地声明这个结构实际上不会给我们一个候选。在将它写入存储之前，我们需要将其实例化并将其赋给一个变量。</p><p id="ba80" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">接下来我们需要一个存放候选人的地方。我们需要一个地方来存储我们刚刚创建的一个结构类型。我们可以用<a class="ae me" href="https://solidity.readthedocs.io/en/v0.4.21/types.html?highlight=mapping#mappings" rel="noopener ugc nofollow" target="_blank">实度贴图来做到这一点。</a>Solidity中的映射就像一个关联数组或散列，它将键值对关联起来。我们可以创建这样的映射:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="9516" class="mm kr ht mi b fv mn mo l mp mq">contract Election {<br/>    // Model a Candidate<br/>    <strong class="mi hu">struct</strong> Candidate {<br/>        <strong class="mi hu">uint</strong> id;<br/>        <strong class="mi hu">string</strong> name;<br/>        <strong class="mi hu">uint</strong> voteCount;<br/>    }</span><span id="7535" class="mm kr ht mi b fv mu mo l mp mq">    // Read/write Candidates<br/>    mapping(<strong class="mi hu">uint</strong> =&gt; Candidate) <strong class="mi hu">public</strong> candidates;</span><span id="9f07" class="mm kr ht mi b fv mu mo l mp mq">    // ...<br/>}</span></pre><p id="08d2" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在这种情况下，映射的键是一个<a class="ae me" href="https://solidity.readthedocs.io/en/v0.4.21/abi-spec.html?highlight=unsigned%20integer" rel="noopener ugc nofollow" target="_blank">无符号整数</a>，值是我们刚刚定义的候选结构类型。这实际上为我们提供了基于id的每个候选人的查找。因为这个映射被分配给一个状态变量，所以只要我们给它分配新的键值对，我们就会把数据写入区块链。接下来，我们将这个映射的visibility设置为<code class="eh mv mw mx mi b">public</code>，以便获得一个getter函数，就像我们在smoke测试中对候选人姓名所做的那样。</p><p id="1b30" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">接下来，我们使用如下计数器缓存状态变量来跟踪选举中有多少候选人:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="1a07" class="mm kr ht mi b fv mn mo l mp mq">contract Election {<br/>    // Model a Candidate<br/>    <strong class="mi hu">struct</strong> Candidate {<br/>        <strong class="mi hu">uint</strong> id;<br/>        <strong class="mi hu">string</strong> name;<br/>        <strong class="mi hu">uint</strong> voteCount;<br/>    }</span><span id="94e7" class="mm kr ht mi b fv mu mo l mp mq">    // Read/write Candidates<br/>    mapping(<strong class="mi hu">uint</strong> =&gt; Candidate) <strong class="mi hu">public</strong> candidates;</span><span id="aa48" class="mm kr ht mi b fv mu mo l mp mq">    // Store Candidates Count<br/>    <strong class="mi hu">uint</strong> <strong class="mi hu">public</strong> candidatesCount;</span><span id="7fc1" class="mm kr ht mi b fv mu mo l mp mq">    // ...<br/>}</span></pre><p id="3046" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">在Solidity中，没有办法确定映射的大小，也没有办法迭代它。这是因为映射中任何尚未赋值的键都将返回默认值(在本例中为空)。例如，如果我们在这次选举中只有2名候选人，并且我们试图查找候选人#99，那么映射将返回一个空的候选人结构。这种行为使得我们无法知道有多少候选项存在，因此我们必须使用计数器缓存。</p><p id="487e" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">接下来，让我们创建一个函数，将候选项添加到我们已经创建的映射中，如下所示:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="aae9" class="mm kr ht mi b fv mn mo l mp mq">contract Election {<br/>    // ...</span><span id="6c9d" class="mm kr ht mi b fv mu mo l mp mq">    function <strong class="mi hu">addCandidate</strong> (string _name) <strong class="mi hu">private</strong> {<br/>        candidatesCount ++;<br/>        candidates[candidatesCount] = Candidate(candidatesCount, _name, 0);<br/>    }<br/>}</span></pre><p id="e3e3" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们已经声明了函数<code class="eh mv mw mx mi b">addCandidate</code>,它接受一个字符串类型的参数，表示候选人的姓名。在函数内部，我们递增候选计数器缓存，以表示已经添加了一个新的候选。然后，我们用一个新的候选结构更新映射，使用当前的候选计数作为键。此候选结构用当前候选计数中的候选id、函数参数中的名称以及初始投票计数初始化为0。注意，这个函数的可见性是私有的，因为我们只想在契约内部调用它。</p><p id="9732" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在，我们可以通过在构造函数中调用两次“addCandidate”函数向选举中添加两个候选人，如下所示:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="57da" class="mm kr ht mi b fv mn mo l mp mq">contract Election {<br/>    // ...</span><span id="e557" class="mm kr ht mi b fv mu mo l mp mq">    <strong class="mi hu">function</strong> <strong class="mi hu">Election</strong> () <strong class="mi hu">public</strong> {<br/>        addCandidate("Candidate 1");<br/>        addCandidate("Candidate 2");<br/>    }</span><span id="127f" class="mm kr ht mi b fv mu mo l mp mq">    // ...<br/>}</span></pre><p id="0dec" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">当我们将合同部署到区块链并用两个候选人填充我们的选举时，将执行该迁移。此时，您的完整合同代码应该如下所示:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="8eec" class="mm kr ht mi b fv mn mo l mp mq">pragma solidity ^0.4.2;</span><span id="55c8" class="mm kr ht mi b fv mu mo l mp mq">contract Election {<br/>    // Model a Candidate<br/>    <strong class="mi hu">struct</strong> Candidate {<br/>        <strong class="mi hu">uint</strong> id;<br/>        <strong class="mi hu">string</strong> name;<br/>        <strong class="mi hu">uint</strong> voteCount;<br/>    }</span><span id="1cfa" class="mm kr ht mi b fv mu mo l mp mq">    // Read/write candidates<br/>    mapping(<strong class="mi hu">uint</strong> =&gt; Candidate) <strong class="mi hu">public</strong> candidates;</span><span id="7c59" class="mm kr ht mi b fv mu mo l mp mq">    // Store Candidates Count<br/>    <strong class="mi hu">uint</strong> <strong class="mi hu">public</strong> candidatesCount;</span><span id="fea5" class="mm kr ht mi b fv mu mo l mp mq">    function <strong class="mi hu">Election</strong> () <strong class="mi hu">public</strong> {<br/>        addCandidate("Candidate 1");<br/>        addCandidate("Candidate 2");<br/>    }</span><span id="d0b7" class="mm kr ht mi b fv mu mo l mp mq">    function <strong class="mi hu">addCandidate</strong> (<strong class="mi hu">string</strong> _name) <strong class="mi hu">private</strong> {<br/>        candidatesCount ++;<br/>        candidates[candidatesCount] = Candidate(candidatesCount, _name, 0);<br/>    }</span><span id="a344" class="mm kr ht mi b fv mu mo l mp mq">}</span></pre><p id="4c34" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在，让我们像这样迁移我们的合同:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="64fc" class="mm kr ht mi b fv mn mo l mp mq">$ truffle migrate --reset</span></pre><p id="d7b7" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在尝试在控制台内与候选人互动。</p><p id="887a" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在让我们编写一些测试来确保我们的智能契约被正确初始化。首先，让我解释一下为什么在开发智能合同时测试如此重要。出于几个原因，我们希望确保合同没有错误:</p><p id="3763" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">1.以太坊区块链上的所有代码都是不可变的；它不能改变。如果合同包含任何错误，我们必须禁用它并部署一个新的副本。这个新副本与旧合同的状态不同，地址也不同。</p><p id="6ee5" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">2.部署契约需要耗费大量资源，因为它会创建一个事务并将数据写入区块链。这需要消耗乙醚，而我们希望尽可能减少乙醚的用量。</p><p id="3005" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">3.如果写入区块链的任何契约函数包含错误，调用该函数的帐户可能会浪费资源，并且它可能不会按照预期的方式运行。</p><h1 id="4076" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">测试</h1><p id="4c45" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">现在让我们写一些测试。确保首先运行Ganache。然后，在命令行中从项目的根目录创建一个新的测试文件，如下所示:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="391c" class="mm kr ht mi b fv mn mo l mp mq">$ touch test/election.js</span></pre><p id="efd7" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们将在这个文件中用Javascript编写所有的测试，用<a class="ae me" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">Mocha测试框架</a>和<a class="ae me" href="http://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank">Chai断言库</a>。这些都与Truffle框架捆绑在一起。我们将使用Javascript编写所有这些测试来模拟客户端与智能合约的交互，就像我们在控制台中所做的一样。以下是测试的所有代码:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="0082" class="mm kr ht mi b fv mn mo l mp mq"><strong class="mi hu">var</strong> Election = artifacts.<strong class="mi hu">require</strong>("./Election.sol");</span><span id="01a0" class="mm kr ht mi b fv mu mo l mp mq">contract("Election", <strong class="mi hu">function</strong>(accounts) {<br/>  <strong class="mi hu">var</strong> electionInstance;</span><span id="65b2" class="mm kr ht mi b fv mu mo l mp mq">  it("initializes with two candidates", <strong class="mi hu">function</strong>() {<br/>    <strong class="mi hu">return</strong> Election.deployed().then(<strong class="mi hu">function</strong>(instance) {<br/>      <strong class="mi hu">return</strong> instance.candidatesCount();<br/>    }).then(<strong class="mi hu">function</strong>(count) {<br/>      assert.equal(count, 2);<br/>    });<br/>  });</span><span id="cd67" class="mm kr ht mi b fv mu mo l mp mq">  it("it initializes the candidates with the correct values", <strong class="mi hu">function</strong>() {<br/>    <strong class="mi hu">return</strong> Election.deployed().then(<strong class="mi hu">function</strong>(instance) {<br/>      electionInstance = instance;<br/>      <strong class="mi hu">return</strong> electionInstance.candidates(1);<br/>    }).then(<strong class="mi hu">function</strong>(candidate) {<br/>      assert.equal(candidate[0], 1, "contains the correct id");<br/>      assert.equal(candidate[1], "Candidate 1", "contains the correct name");<br/>      assert.equal(candidate[2], 0, "contains the correct votes count");<br/>      <strong class="mi hu">return</strong> electionInstance.candidates(2);<br/>    }).then(<strong class="mi hu">function</strong>(candidate) {<br/>      assert.equal(candidate[0], 2, "contains the correct id");<br/>      assert.equal(candidate[1], "Candidate 2", "contains the correct name");<br/>      assert.equal(candidate[2], 0, "contains the correct votes count");<br/>    });<br/>  });<br/>});</span></pre><p id="a0c7" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我来解释一下这段代码。首先，我们需要契约并将它赋给一个变量，就像我们在迁移文件中所做的那样。接下来，我们调用“契约”函数，并在回调函数中编写所有测试。这个回调函数提供了一个“accounts”变量，代表我们的区块链上的所有帐户，由Ganache提供。</p><p id="a67a" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">第一个测试通过检查候选人的计数是否等于2，来检查是否用正确数量的候选人初始化了协定。</p><p id="19ee" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">下一个测试检查选举中每个候选人的值，确保每个候选人都有正确的id、姓名和票数。</p><p id="229b" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在让我们从命令行运行测试，如下所示:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="ade3" class="mm kr ht mi b fv mn mo l mp mq">$ truffle test</span></pre><h1 id="9510" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">客户端应用程序</h1><p id="73eb" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">现在，让我们开始构建将与我们的智能合约对话的客户端应用程序。我们将通过修改上一节中安装的Truffle Pet Shop box附带的HTML和Javascript文件来实现这一点。我们将使用现有的代码开始。让我们也注意一下松露宠物店盒子附带的一些其他东西，比如<a class="ae me" href="https://getbootstrap.com/" rel="noopener ugc nofollow" target="_blank">引导框架</a>，这将使我们在本教程中不必编写任何CSS。我们还得到了一个<a class="ae me" href="https://www.npmjs.com/package/light-server" rel="noopener ugc nofollow" target="_blank">精简服务器</a>，它将为我们的资产提供开发服务。</p><p id="b7cc" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">您不必成为前端专家，也可以学习本教程的这一部分。我有意保持HTML和Javascript代码非常简单，我们不会花太多时间在这上面。我想继续专注于开发我们dApp的智能合同部分！</p><p id="c3e0" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">继续用以下代码替换“index.html”文件的所有内容:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="96f7" class="mm kr ht mi b fv mn mo l mp mq">&lt;!DOCTYPE html&gt;<br/>&lt;<strong class="mi hu">html</strong> lang="en"&gt;<br/>  &lt;<strong class="mi hu">head</strong>&gt;<br/>    &lt;<strong class="mi hu">meta</strong> charset="utf-8"&gt;<br/>    &lt;<strong class="mi hu">meta</strong> http-equiv="X-UA-Compatible" content="IE=edge"&gt;<br/>    &lt;<strong class="mi hu">meta</strong> name="viewport" content="width=device-width, initial-scale=1"&gt;<br/>    &lt;<strong class="mi hu">title</strong>&gt;Election Results&lt;/<strong class="mi hu">title</strong>&gt;</span><span id="dbc5" class="mm kr ht mi b fv mu mo l mp mq">    &lt;!-- Bootstrap --&gt;<br/>    &lt;<strong class="mi hu">link</strong> href="css/bootstrap.min.css" rel="stylesheet"&gt;<br/>  &lt;/<strong class="mi hu">head</strong>&gt;<br/>  &lt;<strong class="mi hu">body</strong>&gt;<br/>    &lt;<strong class="mi hu">div</strong> class="container" style="width: 650px;"&gt;<br/>      &lt;<strong class="mi hu">div</strong> class="row"&gt;<br/>        &lt;<strong class="mi hu">div</strong> class="col-lg-12"&gt;<br/>          &lt;<strong class="mi hu">h1</strong> class="text-center"&gt;Election Results&lt;/<strong class="mi hu">h1</strong>&gt;<br/>          &lt;<strong class="mi hu">hr</strong>/&gt;<br/>          &lt;<strong class="mi hu">br</strong>/&gt;<br/>          &lt;<strong class="mi hu">div</strong> id="loader"&gt;<br/>            &lt;<strong class="mi hu">p</strong> class="text-center"&gt;Loading...&lt;/<strong class="mi hu">p</strong>&gt;<br/>          &lt;/<strong class="mi hu">div</strong>&gt;<br/>          &lt;<strong class="mi hu">div</strong> id="content" style="display: none;"&gt;<br/>            &lt;<strong class="mi hu">table</strong> class="table"&gt;<br/>              &lt;<strong class="mi hu">thead</strong>&gt;<br/>                &lt;<strong class="mi hu">tr</strong>&gt;<br/>                  &lt;<strong class="mi hu">th</strong> scope="col"&gt;#&lt;/<strong class="mi hu">th</strong>&gt;<br/>                  &lt;<strong class="mi hu">th</strong> scope="col"&gt;Name&lt;/<strong class="mi hu">th</strong>&gt;<br/>                  &lt;<strong class="mi hu">th</strong> scope="col"&gt;Votes&lt;/<strong class="mi hu">th</strong>&gt;<br/>                &lt;/<strong class="mi hu">tr</strong>&gt;<br/>              &lt;/<strong class="mi hu">thead</strong>&gt;<br/>              &lt;<strong class="mi hu">tbody</strong> id="candidatesResults"&gt;<br/>              &lt;/<strong class="mi hu">tbody</strong>&gt;<br/>            &lt;/<strong class="mi hu">table</strong>&gt;<br/>            &lt;<strong class="mi hu">hr</strong>/&gt;<br/>            &lt;<strong class="mi hu">p</strong> id="accountAddress" class="text-center"&gt;&lt;/<strong class="mi hu">p</strong>&gt;<br/>          &lt;/<strong class="mi hu">div</strong>&gt;<br/>        &lt;/<strong class="mi hu">div</strong>&gt;<br/>      &lt;/<strong class="mi hu">div</strong>&gt;<br/>    &lt;/<strong class="mi hu">div</strong>&gt;</span><span id="e00a" class="mm kr ht mi b fv mu mo l mp mq">    &lt;!-- jQuery (necessary for Bootstrap's JavaScript plugins) --&gt;<br/>    &lt;<strong class="mi hu">script</strong> src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"&gt;&lt;/<strong class="mi hu">script</strong>&gt;<br/>    &lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt;<br/>    &lt;<strong class="mi hu">script</strong> src="js/bootstrap.min.js"&gt;&lt;/<strong class="mi hu">script</strong>&gt;<br/>    &lt;<strong class="mi hu">script</strong> src="js/web3.min.js"&gt;&lt;/<strong class="mi hu">script</strong>&gt;<br/>    &lt;<strong class="mi hu">script</strong> src="js/truffle-contract.js"&gt;&lt;/<strong class="mi hu">script</strong>&gt;<br/>    &lt;<strong class="mi hu">script</strong> src="js/app.js"&gt;&lt;/<strong class="mi hu">script</strong>&gt;<br/>  &lt;/<strong class="mi hu">body</strong>&gt;<br/>&lt;/<strong class="mi hu">html</strong>&gt;</span></pre><p id="0537" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">接下来，用以下代码替换“app.js”文件的所有内容:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="9d81" class="mm kr ht mi b fv mn mo l mp mq">App = {<br/>  web3Provider: null,<br/>  contracts: {},<br/>  account: '0x0',</span><span id="3971" class="mm kr ht mi b fv mu mo l mp mq">  init: <strong class="mi hu">function</strong>() {<br/>    <strong class="mi hu">return</strong> App.initWeb3();<br/>  },</span><span id="5445" class="mm kr ht mi b fv mu mo l mp mq">  initWeb3: <strong class="mi hu">function</strong>() {<br/>    <strong class="mi hu">if</strong> (<strong class="mi hu">typeof</strong> web3 !== 'undefined') {<br/>      // If a web3 instance is already provided by Meta Mask.<br/>      App.web3Provider = web3.currentProvider;<br/>      web3 = <strong class="mi hu">new</strong> Web3(web3.currentProvider);<br/>    } <strong class="mi hu">else</strong> {<br/>      // Specify default instance if no web3 instance provided<br/>      App.web3Provider = <strong class="mi hu">new</strong> Web3.providers.HttpProvider('http://localhost:7545');<br/>      web3 = <strong class="mi hu">new</strong> Web3(App.web3Provider);<br/>    }<br/>    <strong class="mi hu">return</strong> App.initContract();<br/>  },</span><span id="39da" class="mm kr ht mi b fv mu mo l mp mq">  initContract: <strong class="mi hu">function</strong>() {<br/>    $.getJSON("Election.json", <strong class="mi hu">function</strong>(election) {<br/>      // Instantiate a new truffle contract from the artifact<br/>      App.contracts.Election = TruffleContract(election);<br/>      // Connect provider to interact with contract<br/>      App.contracts.Election.setProvider(App.web3Provider);</span><span id="eddb" class="mm kr ht mi b fv mu mo l mp mq">      <strong class="mi hu">return</strong> App.render();<br/>    });<br/>  },</span><span id="5005" class="mm kr ht mi b fv mu mo l mp mq">  render: <strong class="mi hu">function</strong>() {<br/>    <strong class="mi hu">var</strong> electionInstance;<br/>    <strong class="mi hu">var</strong> loader = $("#loader");<br/>    <strong class="mi hu">var</strong> content = $("#content");</span><span id="c84a" class="mm kr ht mi b fv mu mo l mp mq">    loader.show();<br/>    content.hide();</span><span id="e86c" class="mm kr ht mi b fv mu mo l mp mq">    // Load account data<br/>    web3.eth.getCoinbase(<strong class="mi hu">function</strong>(err, account) {<br/>      <strong class="mi hu">if</strong> (err === null) {<br/>        App.account = account;<br/>        $("#accountAddress").html("Your Account: " + account);<br/>      }<br/>    });</span><span id="05ff" class="mm kr ht mi b fv mu mo l mp mq">    // Load contract data<br/>    App.contracts.Election.deployed().then(<strong class="mi hu">function</strong>(instance) {<br/>      electionInstance = instance;<br/>      <strong class="mi hu">return</strong> electionInstance.candidatesCount();<br/>    }).then(<strong class="mi hu">function</strong>(candidatesCount) {<br/>      <strong class="mi hu">var</strong> candidatesResults = $("#candidatesResults");<br/>      candidatesResults.empty();</span><span id="c4e8" class="mm kr ht mi b fv mu mo l mp mq">      <strong class="mi hu">for</strong> (<strong class="mi hu">var</strong> i = 1; i &lt;= candidatesCount; i++) {<br/>        electionInstance.candidates(i).then(<strong class="mi hu">function</strong>(candidate) {<br/>          <strong class="mi hu">var</strong> id = candidate[0];<br/>          <strong class="mi hu">var</strong> name = candidate[1];<br/>          <strong class="mi hu">var</strong> voteCount = candidate[2];</span><span id="88ae" class="mm kr ht mi b fv mu mo l mp mq">          // Render candidate Result<br/>          <strong class="mi hu">var</strong> candidateTemplate = "&lt;tr&gt;&lt;th&gt;" + id + "&lt;/th&gt;&lt;td&gt;" + name + "&lt;/td&gt;&lt;td&gt;" + voteCount + "&lt;/td&gt;&lt;/tr&gt;"<br/>          candidatesResults.append(candidateTemplate);<br/>        });<br/>      }</span><span id="55ee" class="mm kr ht mi b fv mu mo l mp mq">      loader.hide();<br/>      content.show();<br/>    }).catch(<strong class="mi hu">function</strong>(error) {<br/>      console.warn(error);<br/>    });<br/>  }<br/>};</span><span id="0d19" class="mm kr ht mi b fv mu mo l mp mq">$(<strong class="mi hu">function</strong>() {<br/>  $(window).load(<strong class="mi hu">function</strong>() {<br/>    App.init();<br/>  });<br/>});</span></pre><p id="d780" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">让我们注意一下这段代码做的一些事情:</p><ol class=""><li id="eead" class="lo lp ht jw b jx jy ka kb kd lq kh lr kl ls kp lt lu lv lw dt translated">设置web3: <a class="ae me" href="https://web3js.readthedocs.io/en/1.0/" rel="noopener ugc nofollow" target="_blank"> web3.js </a>是一个javascript库，它允许我们的客户端应用程序与区块链对话。我们在“initWeb3”函数中配置web3。</li><li id="a445" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp lt lu lv lw dt translated">初始化契约:我们在这个函数中获取智能契约的已部署实例，并分配一些允许我们与之交互的值。</li><li id="2a35" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp lt lu lv lw dt translated">Render函数:render函数使用智能合约中的数据来布局页面上的所有内容。现在，我们列出我们在智能合同中创建的候选人。我们通过遍历映射中的每个候选项并将其呈现到表中来实现这一点。我们还在这个函数中获取连接到区块链的当前帐户，并将其显示在页面上。</li></ol><p id="74a2" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在让我们在浏览器中查看客户端应用程序。首先，确保您已经像这样迁移了合同:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="8d92" class="mm kr ht mi b fv mn mo l mp mq">$ truffle migrate --reset</span></pre><p id="1519" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">接下来，从命令行启动开发服务器，如下所示:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="279e" class="mm kr ht mi b fv mn mo l mp mq">$ npm run dev</span></pre><p id="c506" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这应该会自动打开一个包含您的客户端应用程序的新浏览器窗口。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff my"><img src="../Images/48a0fff0e73d9895cd95bf0e5e418277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9f4THvqQ32_pKaRqyvfNbQ.png"/></div></div></figure><p id="f2de" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">请注意，您的应用程序显示“正在加载…”。那是因为我们还没有登录到区块链！为了连接到区块链，我们需要将其中一个帐户从Ganache导入Metamask。</p><p id="ba86" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">一旦您与Metamask建立了连接，您应该会看到所有的合同和帐户数据都已加载。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mz"><img src="../Images/5bc112fc7a98c277707719407ab13ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xv82XWskrvR9JP1V8nq8Yg.png"/></div></div></figure><h1 id="df34" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">第三步:投票</h1><p id="26f5" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">现在让我们添加在选举中投票的能力。让我们定义一个映射到智能合同的“选民”来跟踪在选举中投票的帐户，如下所示:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="6455" class="mm kr ht mi b fv mn mo l mp mq">contract Election {<br/>    // ...</span><span id="e3b8" class="mm kr ht mi b fv mu mo l mp mq">    // Store accounts that have voted<br/>    mapping(address =&gt; <strong class="mi hu">bool</strong>) <strong class="mi hu">public</strong> voters;</span><span id="a12c" class="mm kr ht mi b fv mu mo l mp mq">    // ...<br/>}</span></pre><p id="cc92" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在让我们添加一个“投票”功能:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="6b29" class="mm kr ht mi b fv mn mo l mp mq">contract Election {<br/>    // ...</span><span id="71d8" class="mm kr ht mi b fv mu mo l mp mq">    // Store accounts that have voted<br/>    mapping(address =&gt; bool) public voters;</span><span id="8d8a" class="mm kr ht mi b fv mu mo l mp mq">    // ...</span><span id="a2b9" class="mm kr ht mi b fv mu mo l mp mq">    <strong class="mi hu">function</strong> <strong class="mi hu">vote</strong> (uint _candidateId) <strong class="mi hu">public</strong> {<br/>        // require that they haven't voted before<br/>        require(!voters[msg.sender]);</span><span id="6496" class="mm kr ht mi b fv mu mo l mp mq">        // require a valid candidate<br/>        require(_candidateId &gt; 0 &amp;&amp; _candidateId &lt;= candidatesCount);</span><span id="8a1d" class="mm kr ht mi b fv mu mo l mp mq">        // record that voter has voted<br/>        voters[msg.sender] = true;</span><span id="4931" class="mm kr ht mi b fv mu mo l mp mq">        // update candidate vote Count<br/>        candidates[_candidateId].voteCount ++;<br/>    }<br/>}</span></pre><p id="941d" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">该函数的核心功能是通过从“candidates”映射中读取候选结构并使用递增运算符(++)将“vote count”增加1来增加候选人的投票数。让我们看看它的其他一些功能:</p><ol class=""><li id="c880" class="lo lp ht jw b jx jy ka kb kd lq kh lr kl ls kp lt lu lv lw dt translated">它接受一个参数。这是一个带有候选人id的无符号整数。</li><li id="6506" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp lt lu lv lw dt translated">它的可见性是公开的，因为我们希望外部帐户调用它。</li><li id="4d08" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp lt lu lv lw dt translated">它将投票的帐户添加到我们刚刚创建的选民映射中。这将允许我们跟踪选民是否在选举中投票。我们使用Solidity提供的全局变量“msg.sender”来访问调用这个函数的帐户。</li><li id="32f0" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp lt lu lv lw dt translated">它实现了require语句，如果不满足条件，这些语句将停止执行。首先，要求投票人以前没有投票。为此，我们从映射中读取带有“msg.sender”的帐户地址。如果在的话，账户已经投了。接下来，它要求候选人id有效。求职者id必须大于零且小于或等于求职者总数。</li></ol><p id="258e" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在，您的完整合同代码应该如下所示:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="6ede" class="mm kr ht mi b fv mn mo l mp mq">pragma solidity ^0.4.2;</span><span id="4851" class="mm kr ht mi b fv mu mo l mp mq">contract Election {<br/>    // Model a Candidate<br/>    <strong class="mi hu">struct</strong> Candidate {<br/>        <strong class="mi hu">uint</strong> id;<br/>        <strong class="mi hu">string</strong> name;<br/>        <strong class="mi hu">uint</strong> voteCount;<br/>    }</span><span id="bee5" class="mm kr ht mi b fv mu mo l mp mq">    // Store accounts that have voted<br/>    mapping(address =&gt; <strong class="mi hu">bool</strong>) <strong class="mi hu">public</strong> voters;<br/>    // Read/write candidates<br/>    mapping(<strong class="mi hu">uint</strong> =&gt; Candidate) <strong class="mi hu">public</strong> candidates;<br/>    // Store Candidates Count<br/>    <strong class="mi hu">uint</strong> <strong class="mi hu">public</strong> candidatesCount;</span><span id="903b" class="mm kr ht mi b fv mu mo l mp mq">    function <strong class="mi hu">Election</strong> () <strong class="mi hu">public</strong> {<br/>        addCandidate("Candidate 1");<br/>        addCandidate("Candidate 2");<br/>    }</span><span id="2739" class="mm kr ht mi b fv mu mo l mp mq">    function <strong class="mi hu">addCandidate</strong> (<strong class="mi hu">string</strong> _name) <strong class="mi hu">private</strong> {<br/>        candidatesCount ++;<br/>        candidates[candidatesCount] = Candidate(candidatesCount, _name, 0);<br/>    }</span><span id="0111" class="mm kr ht mi b fv mu mo l mp mq">    function <strong class="mi hu">vote</strong> (<strong class="mi hu">uint</strong> _candidateId) <strong class="mi hu">public</strong> {<br/>        // require that they haven't voted before<br/>        require(!voters[msg.sender]);</span><span id="03e8" class="mm kr ht mi b fv mu mo l mp mq">        // require a valid candidate<br/>        require(_candidateId &gt; 0 &amp;&amp; _candidateId &lt;= candidatesCount);</span><span id="bd9e" class="mm kr ht mi b fv mu mo l mp mq">        // record that voter has voted<br/>        voters[msg.sender] = true;</span><span id="da71" class="mm kr ht mi b fv mu mo l mp mq">        // update candidate vote Count<br/>        candidates[_candidateId].voteCount ++;<br/>    }<br/>}</span></pre><h1 id="2db6" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">测试投票功能</h1><p id="68ae" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">现在让我们向“election.js”测试文件添加一个测试:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="7bea" class="mm kr ht mi b fv mn mo l mp mq">it("allows a voter to cast a vote", <strong class="mi hu">function</strong>() {<br/>    <strong class="mi hu">return</strong> Election.deployed().then(<strong class="mi hu">function</strong>(instance) {<br/>      electionInstance = instance;<br/>      candidateId = 1;<br/>      <strong class="mi hu">return</strong> electionInstance.vote(candidateId, { from: accounts[0] });<br/>    }).then(<strong class="mi hu">function</strong>(receipt) {<br/>      <strong class="mi hu">return</strong> electionInstance.voters(accounts[0]);<br/>    }).then(<strong class="mi hu">function</strong>(voted) {<br/>      assert(voted, "the voter was marked as voted");<br/>      <strong class="mi hu">return</strong> electionInstance.candidates(candidateId);<br/>    }).then(<strong class="mi hu">function</strong>(candidate) {<br/>      <strong class="mi hu">var</strong> voteCount = candidate[2];<br/>      assert.equal(voteCount, 1, "increments the candidate's vote count");<br/>    })<br/>  });</span></pre><p id="03e3" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们想在这里测试两件事:</p><ol class=""><li id="10be" class="lo lp ht jw b jx jy ka kb kd lq kh lr kl ls kp lt lu lv lw dt translated">测试该函数是否会增加候选人的投票数。</li><li id="b90b" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp lt lu lv lw dt translated">测试投票人在投票时是否被添加到映射中。</li></ol><p id="90ce" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">接下来，我们可以为我们的功能需求编写一些测试。让我们编写一个测试来确保我们的投票函数为双重投票抛出一个异常:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="8c1d" class="mm kr ht mi b fv mn mo l mp mq">it("throws an exception for invalid candidates", <strong class="mi hu">function</strong>() {<br/>    <strong class="mi hu">return</strong> Election.deployed().then(<strong class="mi hu">function</strong>(instance) {<br/>      electionInstance = instance;<br/>      <strong class="mi hu">return</strong> electionInstance.vote(99, { from: accounts[1] })<br/>    }).then(assert.fail).<strong class="mi hu">catch</strong>(<strong class="mi hu">function</strong>(error) {<br/>      assert(error.message.indexOf('revert') &gt;= 0, "error message must contain revert");<br/>      <strong class="mi hu">return</strong> electionInstance.candidates(1);<br/>    }).then(<strong class="mi hu">function</strong>(candidate1) {<br/>      <strong class="mi hu">var</strong> voteCount = candidate1[2];<br/>      assert.equal(voteCount, 1, "candidate 1 did not receive any votes");<br/>      <strong class="mi hu">return</strong> electionInstance.candidates(2);<br/>    }).then(<strong class="mi hu">function</strong>(candidate2) {<br/>      <strong class="mi hu">var</strong> voteCount = candidate2[2];<br/>      assert.equal(voteCount, 0, "candidate 2 did not receive any votes");<br/>    });<br/>  });</span></pre><p id="5b80" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们可以断言事务失败，并返回一条错误消息。我们可以深入研究这个错误消息，以确保错误消息包含“revert”子字符串。然后，我们可以通过确保候选人没有收到任何投票来确保我们的合同状态没有改变。</p><p id="7e4e" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在让我们编写一个测试来确保我们防止双重投票:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="81c3" class="mm kr ht mi b fv mn mo l mp mq">it("throws an exception for double voting", <strong class="mi hu">function</strong>() {<br/>    <strong class="mi hu">return</strong> Election.deployed().then(<strong class="mi hu">function</strong>(instance) {<br/>      electionInstance = instance;<br/>      candidateId = 2;<br/>      electionInstance.vote(candidateId, { from: accounts[1] });<br/>      <strong class="mi hu">return</strong> electionInstance.candidates(candidateId);<br/>    }).then(<strong class="mi hu">function</strong>(candidate) {<br/>      <strong class="mi hu">var</strong> voteCount = candidate[2];<br/>      assert.equal(voteCount, 1, "accepts first vote");<br/>      // Try to vote again<br/>      <strong class="mi hu">return</strong> electionInstance.vote(candidateId, { from: accounts[1] });<br/>    }).then(assert.fail).<strong class="mi hu">catch</strong>(<strong class="mi hu">function</strong>(error) {<br/>      assert(error.message.indexOf('revert') &gt;= 0, "error message must contain revert");<br/>      <strong class="mi hu">return</strong> electionInstance.candidates(1);<br/>    }).then(<strong class="mi hu">function</strong>(candidate1) {<br/>      <strong class="mi hu">var</strong> voteCount = candidate1[2];<br/>      assert.equal(voteCount, 1, "candidate 1 did not receive any votes");<br/>      <strong class="mi hu">return</strong> electionInstance.candidates(2);<br/>    }).then(<strong class="mi hu">function</strong>(candidate2) {<br/>      <strong class="mi hu">var</strong> voteCount = candidate2[2];<br/>      assert.equal(voteCount, 1, "candidate 2 did not receive any votes");<br/>    });<br/>  });</span></pre><p id="a33a" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">首先，我们将使用一个尚未投票的新帐户设置一个测试场景。然后我们会代表他们投票。然后我们再试着投票。我们将断言这里发生了错误。我们可以检查错误消息，并确保没有候选人收到选票，就像之前的测试一样。</p><p id="65db" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在让我们运行我们的测试:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="c794" class="mm kr ht mi b fv mn mo l mp mq">$ truffle test</span><span id="e66e" class="mm kr ht mi b fv mu mo l mp mq">Yay, they pass! 🎉</span></pre><h1 id="01cc" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">客户端投票</h1><p id="854c" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">让我们在“index.html”文件中添加一个允许帐户在表格下方投票的表单:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="e5ba" class="mm kr ht mi b fv mn mo l mp mq">&lt;<strong class="mi hu">form</strong> onSubmit="App.castVote(); return false;"&gt;<br/>  &lt;<strong class="mi hu">div</strong> class="form-group"&gt;<br/>    &lt;<strong class="mi hu">label</strong> for="candidatesSelect"&gt;Select Candidate&lt;/<strong class="mi hu">label</strong>&gt;<br/>    &lt;<strong class="mi hu">select</strong> class="form-control" id="candidatesSelect"&gt;<br/>    &lt;/<strong class="mi hu">select</strong>&gt;<br/>  &lt;/<strong class="mi hu">div</strong>&gt;<br/>  &lt;<strong class="mi hu">button</strong> type="submit" class="btn btn-primary"&gt;Vote&lt;/<strong class="mi hu">button</strong>&gt;<br/>  &lt;<strong class="mi hu">hr</strong> /&gt;<br/>&lt;/<strong class="mi hu">form</strong>&gt;</span></pre><p id="61e2" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">让我们检查一下这个表单的一些内容:</p><ol class=""><li id="2e78" class="lo lp ht jw b jx jy ka kb kd lq kh lr kl ls kp lt lu lv lw dt translated">我们用一个空的select元素创建表单。我们将在“app.js”文件中使用智能合同提供的候选人来填充选择选项。</li><li id="f9a1" class="lo lp ht jw b jx lx ka ly kd lz kh ma kl mb kp lt lu lv lw dt translated">该表单有一个调用“castVote”函数的“onSubmit”处理程序。我们将在“app.js”文件中对此进行定义。</li></ol><p id="2a08" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在让我们更新我们的app.js文件来处理这两件事。首先，我们在表单的select元素中列出智能合同的所有候选人。然后，一旦帐户投票，我们将隐藏页面上的表单。我们将更新渲染函数，如下所示:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="48ca" class="mm kr ht mi b fv mn mo l mp mq">render: <strong class="mi hu">function</strong>() {<br/>  <strong class="mi hu">var</strong> electionInstance;<br/>  <strong class="mi hu">var</strong> loader = $("#loader");<br/>  <strong class="mi hu">var</strong> content = $("#content");</span><span id="6970" class="mm kr ht mi b fv mu mo l mp mq">  loader.show();<br/>  content.hide();</span><span id="b187" class="mm kr ht mi b fv mu mo l mp mq">  // Load account data<br/>  web3.eth.getCoinbase(<strong class="mi hu">function</strong>(err, account) {<br/>    <strong class="mi hu">if</strong> (err === null) {<br/>      App.account = account;<br/>      $("#accountAddress").html("Your Account: " + account);<br/>    }<br/>  });</span><span id="28b8" class="mm kr ht mi b fv mu mo l mp mq">  // Load contract data<br/>  App.contracts.Election.deployed().then(<strong class="mi hu">function</strong>(instance) {<br/>    electionInstance = instance;<br/>    <strong class="mi hu">return</strong> electionInstance.candidatesCount();<br/>  }).then(<strong class="mi hu">function</strong>(candidatesCount) {<br/>    <strong class="mi hu">var</strong> candidatesResults = $("#candidatesResults");<br/>    candidatesResults.empty();</span><span id="9c98" class="mm kr ht mi b fv mu mo l mp mq">    <strong class="mi hu">var</strong> candidatesSelect = $('#candidatesSelect');<br/>    candidatesSelect.empty();</span><span id="5bfe" class="mm kr ht mi b fv mu mo l mp mq">    <strong class="mi hu">for</strong> (<strong class="mi hu">var</strong> i = 1; i &lt;= candidatesCount; i++) {<br/>      electionInstance.candidates(i).then(<strong class="mi hu">function</strong>(candidate) {<br/>        <strong class="mi hu">var</strong> id = candidate[0];<br/>        <strong class="mi hu">var</strong> name = candidate[1];<br/>        <strong class="mi hu">var</strong> voteCount = candidate[2];</span><span id="eaa0" class="mm kr ht mi b fv mu mo l mp mq">        // Render candidate Result<br/>        <strong class="mi hu">var</strong> candidateTemplate = "&lt;tr&gt;&lt;th&gt;" + id + "&lt;/th&gt;&lt;td&gt;" + name + "&lt;/td&gt;&lt;td&gt;" + voteCount + "&lt;/td&gt;&lt;/tr&gt;"<br/>        candidatesResults.append(candidateTemplate);</span><span id="2831" class="mm kr ht mi b fv mu mo l mp mq">        // Render candidate ballot option<br/>        <strong class="mi hu">var</strong> candidateOption = "&lt;option value='" + id + "' &gt;" + name + "&lt;/ option&gt;"<br/>        candidatesSelect.append(candidateOption);<br/>      });<br/>    }<br/>    <strong class="mi hu">return</strong> electionInstance.voters(App.account);<br/>  }).then(<strong class="mi hu">function</strong>(hasVoted) {<br/>    // Do not allow a user to vote<br/>    <strong class="mi hu">if</strong>(hasVoted) {<br/>      $('form').hide();<br/>    }<br/>    loader.hide();<br/>    content.show();<br/>  }).catch(<strong class="mi hu">function</strong>(error) {<br/>    console.warn(error);<br/>  });<br/>}</span></pre><p id="b674" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">接下来，我们想编写一个函数，每当提交表单时都会调用这个函数:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="f72e" class="mm kr ht mi b fv mn mo l mp mq">castVote: <strong class="mi hu">function</strong>() {<br/>    <strong class="mi hu">var</strong> candidateId = $('#candidatesSelect').val();<br/>    App.contracts.Election.deployed().then(<strong class="mi hu">function</strong>(instance) {<br/>      <strong class="mi hu">return</strong> instance.vote(candidateId, { from: App.account });<br/>    }).then(<strong class="mi hu">function</strong>(result) {<br/>      // Wait for votes to update<br/>      $("#content").hide();<br/>      $("#loader").show();<br/>    }).catch(<strong class="mi hu">function</strong>(err) {<br/>      console.error(err);<br/>    });<br/>  }</span></pre><p id="723f" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">首先，我们在表单中查询候选人id。当我们从智能契约中调用vote函数时，我们传递这个id，并向当前帐户提供函数的“from”元数据。这将是一个异步调用。完成后，我们将显示加载器并隐藏页面内容。每当记录投票时，我们将反其道而行之，再次向用户显示内容。</p><p id="2b80" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在，您的前端应用程序应该如下所示:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff na"><img src="../Images/9eaf8b0869bca6b17964f68daf0bda84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*RyCOY-_nfYQGC1JN00ptdQ.png"/></div></figure><p id="210a" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">继续并尝试投票功能。一旦你这样做，你应该看到一个元掩码确认弹出如下:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/0eea6ce82f78051feb90829091873368.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*7O_4wJ4u5OsvlzI3MlvfJQ.png"/></div></figure><p id="6fef" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">一旦你点击提交，你就成功地投了一票！您仍会看到一个加载屏幕。现在，您必须刷新页面才能看到记录的投票。我们将在下一节中实现自动更新加载程序的功能。</p><h1 id="b3c8" class="kq kr ht bd ks kt ku kv kw kx ky kz la iz lb ja lc jc ld jd le jf lf jg lg lh dt translated">第四步:观察事件</h1><p id="1b1e" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">本教程的最后一步是每当投票时触发一个事件。这将允许我们在帐户投票时更新我们的客户端应用程序。幸运的是，这相当容易。让我们首先像这样在我们的契约中声明一个事件:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="a7fe" class="mm kr ht mi b fv mn mo l mp mq">contract Election {<br/>    // ...<br/>    <strong class="mi hu">event</strong> <strong class="mi hu">votedEvent</strong> (<br/>        <strong class="mi hu">uint</strong> indexed _candidateId<br/>    );<br/>    // ...<br/>}</span></pre><p id="b513" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在，我们可以在“投票”函数中触发这个“投票”事件，如下所示:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="20f2" class="mm kr ht mi b fv mn mo l mp mq"><strong class="mi hu">function</strong> <strong class="mi hu">vote</strong> (uint _candidateId) <strong class="mi hu">public</strong> {<br/>    // require that they haven't voted before<br/>    require(!voters[msg.sender]);</span><span id="d2a3" class="mm kr ht mi b fv mu mo l mp mq">    // require a valid candidate<br/>    require(_candidateId &gt; 0 &amp;&amp; _candidateId &lt;= candidatesCount);</span><span id="3394" class="mm kr ht mi b fv mu mo l mp mq">    // record that voter has voted<br/>    voters[msg.sender] = true;</span><span id="ab47" class="mm kr ht mi b fv mu mo l mp mq">    // update candidate vote Count<br/>    candidates[_candidateId].voteCount ++;</span><span id="3ec9" class="mm kr ht mi b fv mu mo l mp mq">    // trigger voted event<br/>    votedEvent(_candidateId);<br/>}</span></pre><p id="fc53" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">既然我们已经更新了合同，我们必须运行我们的迁移:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="c4cf" class="mm kr ht mi b fv mn mo l mp mq">$ truffle migrate --reset</span></pre><p id="6dc9" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">我们也可以像这样更新我们的测试来检查这个投票事件:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="a3eb" class="mm kr ht mi b fv mn mo l mp mq">it("allows a voter to cast a vote", <strong class="mi hu">function</strong>() {<br/>  <strong class="mi hu">return</strong> Election.deployed().then(<strong class="mi hu">function</strong>(instance) {<br/>    electionInstance = instance;<br/>    candidateId = 1;<br/>    <strong class="mi hu">return</strong> electionInstance.vote(candidateId, { from: accounts[0] });<br/>  }).then(<strong class="mi hu">function</strong>(receipt) {<br/>    assert.equal(receipt.logs.length, 1, "an event was triggered");<br/>    assert.equal(receipt.logs[0].event, "votedEvent", "the event type is correct");<br/>    assert.equal(receipt.logs[0].args._candidateId.toNumber(), candidateId, "the candidate id is correct");<br/>    <strong class="mi hu">return</strong> electionInstance.voters(accounts[0]);<br/>  }).then(<strong class="mi hu">function</strong>(voted) {<br/>    assert(voted, "the voter was marked as voted");<br/>    <strong class="mi hu">return</strong> electionInstance.candidates(candidateId);<br/>  }).then(<strong class="mi hu">function</strong>(candidate) {<br/>    <strong class="mi hu">var</strong> voteCount = candidate[2];<br/>    assert.equal(voteCount, 1, "increments the candidate's vote count");<br/>  })<br/>});</span></pre><p id="3e7c" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">该测试检查由“vote”函数返回的交易收据，以确保它有日志。这些日志包含触发的事件。我们检查事件的类型是否正确，以及它是否有正确的候选id。</p><p id="afad" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在让我们更新客户端应用程序来监听投票事件，并在它被触发时触发页面刷新。我们可以用如下的“listenForEvents”函数来实现:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="2730" class="mm kr ht mi b fv mn mo l mp mq">listenForEvents: <strong class="mi hu">function</strong>() {<br/>  App.contracts.Election.deployed().then(<strong class="mi hu">function</strong>(instance) {<br/>    instance.votedEvent({}, {<br/>      fromBlock: 0,<br/>      toBlock: 'latest'<br/>    }).watch(<strong class="mi hu">function</strong>(error, event) {<br/>      console.log("event triggered", event)<br/>      // Reload when a new vote is recorded<br/>      App.render();<br/>    });<br/>  });<br/>}</span></pre><p id="7540" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">这个函数做一些事情。首先，我们通过调用“voted event”函数来订阅投票事件。我们传入一些元数据，告诉我们要监听区块链上的所有事件。然后我们“看”这个事件。在这里，每当触发“votedEvent”时，我们都会记录到控制台。我们还重新呈现页面上的所有内容。这将在投票记录完成后删除加载器，并在表格上显示更新后的投票数。</p><p id="6ae9" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">最后，无论何时初始化契约，我们都可以调用这个函数:</p><pre class="jj jk jl jm fq mh mi mj mk aw ml dt"><span id="ce94" class="mm kr ht mi b fv mn mo l mp mq">initContract: <strong class="mi hu">function</strong>() {<br/>  $.getJSON("Election.json", <strong class="mi hu">function</strong>(election) {<br/>    // Instantiate a new truffle contract from the artifact<br/>    App.contracts.Election = TruffleContract(election);<br/>    // Connect provider to interact with contract<br/>    App.contracts.Election.setProvider(App.web3Provider);</span><span id="0b80" class="mm kr ht mi b fv mu mo l mp mq">    App.listenForEvents();</span><span id="efda" class="mm kr ht mi b fv mu mo l mp mq">    <strong class="mi hu">return</strong> App.render();<br/>  });<br/>}</span></pre><p id="2d16" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">现在，您可以在您的客户端应用程序上投票，并实时观看记录的投票！请耐心等待，事件触发可能需要几秒钟时间。如果您没有看到事件，请尝试重新启动Chrome。围绕事件的元掩码有一个已知问题<a class="ae me" href="https://github.com/MetaMask/metamask-extension/issues/2393" rel="noopener ugc nofollow" target="_blank">。重启Chrome总能帮我搞定。</a></p><p id="e071" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">恭喜你！🎉您已经在以太坊区块链上成功构建了一个全栈分散式应用程序(dApp )!</p></div><div class="ab cl nc nd hb ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="hm hn ho hp hq"><p id="a3fe" class="pw-post-body-paragraph ju jv ht jw b jx jy iu jz ka kb ix kc kd ke kf kg kh ki kj kk kl km kn ko kp hm dt translated">另外，阅读</p><div class="nj nk fm fo nl nm"><a href="https://blog.cryptostars.is/how-to-launch-ethereum-dapp-on-avalanche-185d29906c5f" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab ej"><div class="no ab np cl cj nq"><h2 class="bd hu fv z el nr eo ep ns er et hs dt translated">如何在雪崩上启动以太坊dApp</h2><div class="nt l"><h3 class="bd b fv z el nr eo ep ns er et ek translated">雪崩时启动以太坊dApp的终极指南</h3></div><div class="nu l"><p class="bd b gc z el nr eo ep ns er et ek translated">blog.cryptostars.is</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa js nm"/></div></div></a></div></div><div class="ab cl nc nd hb ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="hm hn ho hp hq"><h2 id="2162" class="mm kr ht bd ks ob oc od kw oe of og la kd oh oi lc kh oj ok le kl ol om lg on dt translated">在Linkedin上关注我，保持联系</h2><p id="07e0" class="pw-post-body-paragraph ju jv ht jw b jx li iu jz ka lj ix kc kd lk kf kg kh ll kj kk kl lm kn ko kp hm dt translated">https://www.linkedin.com/in/ishanshahzad/<a class="ae me" href="https://www.linkedin.com/in/ishanshahzad/" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>