<html>
<head>
<title>Handling events of a smart contract part 1/2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理智能合约的事件第1/2部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/handling-events-of-a-smart-contract-part-1-2-b086eb6696cf?source=collection_archive---------3-----------------------#2022-04-02">https://medium.com/coinmonks/handling-events-of-a-smart-contract-part-1-2-b086eb6696cf?source=collection_archive---------3-----------------------#2022-04-02</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/97ed81e3355f64a650f6afdb8cf251ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GB3r7gI29oudM_RFeOifww.jpeg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Photo by <a class="ae jf" href="https://unsplash.com/@altumcode?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">AltumCode</a> on <a class="ae jf" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c372" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">处理智能合约事件似乎给开发新手带来了一些困惑。在这个由两部分组成的教程中，我们将展示如何编写一个简单的应用程序来检索和监视发出的事件。</p><p id="3ef9" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们从创建智能合同开始。你可以用混音和林克比这样的测试区块链来做，但我会用松露和加纳切来做。要启动一个新的Truffle项目，创建一个新的目录并键入</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="6e57" class="kn ko ht kj b fv kp kq l kr ks">&gt; truffle init</span></pre><p id="a87c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在contracts文件夹中，我们编写了以下代码:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="f64a" class="kn ko ht kj b fv kp kq l kr ks">pragma solidity ^0.8.11;  </span><span id="c832" class="kn ko ht kj b fv kt kq l kr ks">contract ListeningEvents {      <br/>   <br/>   event NewEvent(address indexed newAddress, uint notIndexed);      <br/>   <br/>   function emitEvent(uint value) public {          <br/>      emit NewEvent(msg.sender, value);      <br/>   }  <br/>}</span></pre><p id="bb7f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这是一个简单的契约，其唯一目的是发出一个事件。本教程的目的是学习如何通过应用程序处理契约发出的事件。</p><p id="ac3b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">要迁移(部署)合同，在Migrations文件夹中创建一个名为<em class="ku"> 2_deploy.js </em>的新文件，其代码与<em class="ku"> 1_initial_migration.js </em>中的代码相同，但将“Migrations”替换为“ListeningEvents”。之后，使用下面的命令部署契约。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="7e6f" class="kn ko ht kj b fv kp kq l kr ks">&gt; truffle migrate</span></pre><p id="af48" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果你对这些程序有任何疑问，可以咨询帖子“<a class="ae jf" rel="noopener" href="/coinmonks/creating-and-deploying-smart-contracts-using-truffle-and-ganache-ffe927fa70ae">使用Truffle和Ganache </a>创建和部署智能合约”。</p><h1 id="ce34" class="kv ko ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">发射事件</h1><p id="fe35" class="pw-post-body-paragraph jg jh ht ji b jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd hm dt translated">发出一个事件非常简单。一旦执行了函数emitEvent(…)，就会发出一个事件。事件的工作方式类似于存储在区块链上而不是存储上的日志。记录一个事件比在存储器中记录一个变量花费更少的汽油，因此是一种更便宜的存储区块链信息的方式。</p><p id="de70" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">请注意事件是如何定义的:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="dff9" class="kn ko ht kj b fv kp kq l kr ks">event NewEvent(address indexed newAddress, uint notIndexed);</span></pre><p id="45cf" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">其中一个参数被定义为索引。这意味着更容易搜索它，我们将解释。每个事件最多可以索引三个参数。事件的每个索引参数称为一个<strong class="ji hu">主题</strong>。</p><p id="43bf" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">要发出事件，请打开truffle控制台</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="5c9a" class="kn ko ht kj b fv kp kq l kr ks">&gt; truffle console</span></pre><p id="ce79" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">创建ListeningEvents协定的(抽象)实例，如下所示</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="7cad" class="kn ko ht kj b fv kp kq l kr ks">&gt; let instance = await ListeningEvents.deployed()</span></pre><p id="92e8" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">并执行该功能</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="9f2b" class="kn ko ht kj b fv kp kq l kr ks">&gt; await instance.emitEvent(100)</span></pre><p id="0a99" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">所有这些都可以在下图中看到:</p><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lx"><img src="../Images/73480cb605454ba0a181198047b5e975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-zcWrM_sufVUJDyNykhcw.png"/></div></div></figure><p id="3aca" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们要做的第一件事是使用<strong class="ji hu"> web3.js </strong>库检索这个事件。不过，在此之前，让我们得到合同地址，以防你没有写下来。只是打字</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="28a0" class="kn ko ht kj b fv kp kq l kr ks">&gt; instance.address</span></pre><p id="ca89" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">请参见下图:</p><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/28ae79ed7c042115c69a55a08574565a.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*GNK9_p_JuDJy9wp85KnHnQ.png"/></div></figure><h1 id="23a9" class="kv ko ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">检索事件</h1><p id="52d0" class="pw-post-body-paragraph jg jh ht ji b jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd hm dt translated">让我们在node.js应用程序中检索事件，但是您在这里学到的内容也可以在前端使用。我在项目的根目录下创建了一个名为app的文件夹，在里面，我启动了一个新的节点项目。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="4fe8" class="kn ko ht kj b fv kp kq l kr ks">&gt; npm init -y</span></pre><p id="c182" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在app文件夹中，我创建了一个名为index.js的文件，这将是我在这个项目中唯一的文件，除了web3依赖项之外。要安装web3.js，只需键入:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="c501" class="kn ko ht kj b fv kp kq l kr ks">&gt; npm install web3</span></pre><p id="afeb" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在让我们使用<strong class="ji hu"> web3.eth </strong>模块的<strong class="ji hu"> web3.eth.getPastLogs </strong>方法来检索事件。还有其他检索事件的方法，但这是最通用的方法。它最多需要四个参数:</p><ol class=""><li id="6aed" class="lz ma ht ji b jj jk jn jo jr mb jv mc jz md kd me mf mg mh dt translated">一个地址</li><li id="bc28" class="lz ma ht ji b jj mi jn mj jr mk jv ml jz mm kd me mf mg mh dt translated">主题列表</li><li id="d86b" class="lz ma ht ji b jj mi jn mj jr mk jv ml jz mm kd me mf mg mh dt translated">初始块</li><li id="6ac9" class="lz ma ht ji b jj mi jn mj jr mk jv ml jz mm kd me mf mg mh dt translated">最后一块</li></ol><p id="5d31" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这些参数起过滤器的作用。该方法的返回是一个承诺，带有一个符合过滤器的发出事件列表。</p><p id="a732" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">原则上，所有参数都是可选的，但这取决于您要连接的节点。某些节点需要指定一些参数，以避免无限制的搜索。</p><p id="80a1" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们从不带参数的搜索开始，在第2部分我们将看到如何使用参数作为过滤器。这种搜索将只返回一个事件，原因是初始块和最终块的缺省值都是链中的最新块。</p><p id="681d" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在一个app文件夹中，我创建了一个<em class="ku"> index.js </em>文件，内容如下:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="d47c" class="kn ko ht kj b fv kp kq l kr ks">const Web3 = require("web3");<br/>  <br/>async function run() {      <br/>   const web3 = await new Web3("HTTP://127.0.0.1:8545");<br/>   let response = await web3.eth.getPastLogs({ });<br/>   console.log(response);  <br/>}  </span><span id="a590" class="kn ko ht kj b fv kt kq l kr ks">run();</span></pre><p id="0959" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">运行上面的文件，我们得到作为响应发出的事件。请参见下图(确保事件是在最后一个块中发出的):</p><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mn"><img src="../Images/d68d0dd4c48051c958db41e165ca5ddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xoiryvmRnXryPU1_TLPQQQ.png"/></div></div></figure><p id="b7d4" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们仔细分析一下上述事件。它有几个参数，我们将突出显示<em class="ku">地址</em>、<em class="ku">主题</em>和<em class="ku">数据</em>。</p><p id="be4e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">地址是合同地址。主题有两个:第一个是对发出的事件的引用。更具体地说，它是某个事件接口的散列，如下图所示:</p><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/da7511069ec6c128a834ee40bcd379ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*6tnJsqoH9PxE8JIAtzRO_w.png"/></div></figure><p id="de81" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">第二个主题涉及我们索引的第一个参数。让我们记住，在我们的事件中，索引的第一个参数是一个地址。主题0x 00000000000000000000000006547 ada 0 c 04 a 12376849 c 00 bfb 2 ea 8444 f 7 ee 72d是该地址的32字节表示(地址长20字节)。为了检查，地址是调用事务的地址。在下图中，我们在Ganache中验证了这一点。</p><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mp"><img src="../Images/4e1b087c68da7881b98025d5e9c1bb3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_9X8aFAB88GZBPruQN71FA.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">This address is the same of the first topic</figcaption></figure><p id="64f9" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">注意，上面的地址和第二个主题是同一个地址，只是改变了表示方式。一个是20字节长，而另一个是32字节长。</p><p id="b11a" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">最后，我们有日期字段。该字段包含事件的其他参数，即未编入索引的参数。在我们的示例中，只有一个参数uint256，我们向它传递了值100。与日期字段的值进行比较:它是正确的。我们只需要注意日期字段中的值是十六进制的(十六进制的64对应于十进制的100)。</p><p id="5e81" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在本文的第2部分，我们将使用过滤器和WebSockets。对于本文第1部分的剩余部分，我们将发出一个带有更多参数的事件。</p><h1 id="0624" class="kv ko ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">更完整的事件</h1><p id="d7c3" class="pw-post-body-paragraph jg jh ht ji b jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd hm dt translated">让我们稍微改变一下以前的合同。新契约看起来会有些不同，如下面的代码所示:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="2bc9" class="kn ko ht kj b fv kp kq l kr ks">pragma solidity ^0.8.11;  </span><span id="7a4a" class="kn ko ht kj b fv kt kq l kr ks">contract ListeningEvents {      </span><span id="67c1" class="kn ko ht kj b fv kt kq l kr ks">   event AnotherEvent(address indexed firstAddres, address indexed secondAddress, uint firstValue, uint secondValue);      </span><span id="bf41" class="kn ko ht kj b fv kt kq l kr ks">   function emitEvent(address _address, uint _value1, uint _value2) public {          <br/>    emit AnotherEvent(msg.sender, _address, _value1, _value2);     <br/>    }    <br/>}</span></pre><p id="e754" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">你不需要创建一个新的块菌项目。若要强制迁移此新协定，请使用</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="df3c" class="kn ko ht kj b fv kp kq l kr ks">&gt; truffle migrate --reset</span></pre><p id="a280" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">重复上述相同的过程，我调用了新契约的函数<strong class="ji hu"> emitEvent(…) </strong>两次，如下图所示:</p><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mq"><img src="../Images/c938f1fa587907e9553da046ceee61d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fl9IT0-H4EuuY8nIvcnrsQ.png"/></div></div></figure><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mr"><img src="../Images/865d91e4ee0d07b278862b95345a528b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8NUw2vTSyqLm42gg6-t5iQ.png"/></div></div></figure><p id="8d18" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">再次执行上一节中相同的<em class="ku"> index.js </em>，我们得到下图的结果:</p><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ms"><img src="../Images/3deba36f772ac8f59af0f371ec03b2c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UT0sDMQ_SNhHmPV8ip-j6w.png"/></div></div></figure><p id="3454" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">注意，我们现在有三个主题:第一个是事件散列，在本例中，是字符串“AnotherEvent(address，address，uint256，uint256)”的散列。我邀请你不要相信我，用<a class="ae jf" href="https://emn178.github.io/online-tools/keccak_256.html" rel="noopener ugc nofollow" target="_blank">https://emn178.github.io/online-tools/keccak_256.html</a>自己检查一下。</p><p id="c93c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">另外两个主题对应于两个索引地址。</p><p id="b8a4" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">数据字段是最后两个参数的一种串联(实际上是一种序列化)，这两个参数没有索引。为了看到这一点，让我们来看看它的值:0x 00000000000000000000000000000000000000000000000000000031500000000000000000000000000000000000000000000000。</p><p id="bf54" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">请注意，它的长度为62字节，因为它对应于两个各为32字节的参数:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="46b4" class="kn ko ht kj b fv kp kq l kr ks">0000000000000000000000000000000000000000000000000000000000000315 000000000000000000000000000000000000000000000000000000000000050a</span></pre><p id="baf6" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">从十六进制转换到十进制，我们有传递给事件的参数:789和1290。</p><h1 id="8e6d" class="kv ko ht bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr dt translated">对第一部分的评论</h1><p id="aaa9" class="pw-post-body-paragraph jg jh ht ji b jj ls jl jm jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd hm dt translated">我想提请注意我们可以从文章的第一部分得出的一些考虑。主题是索引参数，每个主题的长度总是32字节。因此，不可能对动态类型进行索引，动态类型可以超过该值。例如，索引一个字符串是没有意义的。</p><p id="710a" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">非索引参数在序列化时不能用作筛选器。注意，在处理两个非索引参数时，它们被放在同一个字段data中。因此，如果您想在日志中搜索一个参数，您需要索引这个参数。</p><p id="7a12" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在本文的下一部分，我们将更多地讨论web3.eth.getPastLogs方法以及如何使用WebSockets来监控事件。</p><p id="3913" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">感谢阅读！</strong></p><blockquote class="mt"><p id="2b4d" class="mu mv ht bd mw mx my mz na nb nc kd ek translated">加入Coinmonks <a class="ae jf" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jf" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="e193" class="kv ko ht bd kw kx ky kz la lb lc ld le lf nd lh li lj ne ll lm ln nf lp lq lr dt translated">另外，阅读</h1><ul class=""><li id="bdf6" class="lz ma ht ji b jj ls jn lt jr ng jv nh jz ni kd nj mf mg mh dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/3commas-review-an-excellent-crypto-trading-bot-2020-1313a58bec92">3商业评论</a> | <a class="ae jf" href="https://coincodecap.com/pionex-review-exchange-with-crypto-trading-bot" rel="noopener ugc nofollow" target="_blank"> Pionex评论</a> | <a class="ae jf" rel="noopener" href="/coinmonks/coinrule-review-2021-a-beginner-friendly-crypto-trading-bot-daf0504848ba"> Coinrule评论</a></li><li id="2865" class="lz ma ht ji b jj mi jn mj jr mk jv ml jz mm kd nj mf mg mh dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/ledger-vs-ngrave-zero-7e40f0c1d694">莱杰vs n rave</a>|<a class="ae jf" rel="noopener" href="/coinmonks/ledger-nano-s-vs-x-battery-hardware-price-storage-59a6663fe3b0">莱杰nano s vs x </a> | <a class="ae jf" rel="noopener" href="/coinmonks/binance-review-ee10d3bf3b6e">币安评论</a></li><li id="addd" class="lz ma ht ji b jj mi jn mj jr mk jv ml jz mm kd nj mf mg mh dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/bybit-exchange-review-dbd570019b71"> Bybit交易所评论</a> | <a class="ae jf" href="https://coincodecap.com/bityard-reivew" rel="noopener ugc nofollow" target="_blank"> Bityard评论</a> | <a class="ae jf" href="https://coincodecap.com/jet-bot-review" rel="noopener ugc nofollow" target="_blank"> Jet-Bot评论</a></li><li id="be11" class="lz ma ht ji b jj mi jn mj jr mk jv ml jz mm kd nj mf mg mh dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/3commas-vs-pionex-vs-cryptohopper-best-crypto-bot-6a98d2baa203">3 commas vs crypto hopper</a>|<a class="ae jf" rel="noopener" href="/coinmonks/earn-crypto-interest-b10b810fdda3">赚取加密利息</a></li><li id="4150" class="lz ma ht ji b jj mi jn mj jr mk jv ml jz mm kd nj mf mg mh dt translated">最好的比特币<a class="ae jf" rel="noopener" href="/coinmonks/hardware-wallets-dfa1211730c6">硬件钱包</a> | <a class="ae jf" rel="noopener" href="/coinmonks/bitbox02-review-your-swiss-bitcoin-hardware-wallet-c36c88fff29"> BitBox02回顾</a></li></ul></div></div>    
</body>
</html>