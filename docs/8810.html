<html>
<head>
<title>Byzantine Fault Tolerance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">拜占庭容错</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/byzantine-fault-tolerance-222a8134be7?source=collection_archive---------12-----------------------#2022-06-16">https://medium.com/coinmonks/byzantine-fault-tolerance-222a8134be7?source=collection_archive---------12-----------------------#2022-06-16</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/5c82a8d4a4a2c82a423106e5489ce829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GwKOj_F_C46NadbNmcS8Hw.jpeg"/></div></div></figure><p id="d7bd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在中本聪创造比特币之前，他需要在一个分散的网络中解决拜占庭将军的问题。现有的算法和协议都是基于集中式网络的解决方案。中本聪创造性地使用了<strong class="jd hu"> POW </strong>共识算法来解决这个问题，那么拜占庭将军的问题是什么呢？</p><p id="fb59" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">很久很久以前，拜占庭是东罗马帝国的首都。当时的罗马帝国疆域辽阔，出于防御目的，每支军队之间相隔很远，将军们只能依靠信使传递消息。去打仗的时候，拜占庭军队里的所有将领都要达成共识，才能更好的赢得胜利。然而，军队中可能有叛徒，扰乱将军们的决定。此时，在已知成员不可靠的情况下，剩余的忠诚将军需要在不受叛徒或间谍影响的情况下达成共识。这个“拜占庭”不是拜占庭，它与区块链有着密切的联系</p><p id="eda1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">从上面</strong>我们很容易发现2个问题</p><ol class=""><li id="029e" class="jz ka ht jd b je jf ji jj jm kb jq kc ju kd jy ke kf kg kh dt translated">信使的信息来源可靠吗？在计算机网络方面，可以参考我的网络通道的稳定性。</li><li id="0597" class="jz ka ht jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">军队中的所有将领是否都达到了某个目标(一致进攻或撤退)，在出现汉奸的情况下如何实现？在分布式计算机网络中，如何保证所有计算机的一致性，同时也允许节点计算机出现故障或错误。</li></ol><p id="bc1c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">美国计算机科学家(Leslie Lamport在1982年提出拜占庭将军问题)计算机可以分布在世界各地，我们称之为分布式节点，分布式节点可能会出现故障，宕机，或者恶意节点(黑客)，那么我们如何保持<strong class="jd hu">一致性</strong>，忠实的计算机保持不变，<strong class="jd hu">正确性</strong>。</p><p id="82a5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">口头协议:将军副官模式</strong></p><p id="fc83" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">1:忠诚副官:遵循同一命令(<strong class="jd hu">一致性</strong>)(要么一起进攻，要么一起撤退)</p><p id="db63" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">2: <strong class="jd hu">准确性:</strong>如果将军是忠诚的，所有忠诚的副将都必须执行他的命令</p><p id="05d8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">假设m =恶意人数(叛徒)，n =总人数(计算机节点总数)当n&gt;3m这个事件可以解决，你可能会问为什么n&gt;3m，可以看下面的例子</p><p id="d22a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> m=1 n=3 </strong></p><p id="146a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">c(指挥官)会给两个副官1和2下命令，但是2是叛徒，那么这个时候就会出现问题，将军会告诉1和2分别进攻，但是1在接到命令后不会马上进攻，因为他不确定将军是不是叛徒，所以1会问2命令是什么。由于2是叛徒，所以即使2接到进攻的命令，也会告诉1接到撤退的命令。所以这个时候1会很迷茫，因为他接到了将军进攻的命令，2让他撤退，所以他不确定将军和2哪个会是叛徒。所以这个时候的1很迷茫，情况无解。</p><p id="ceb4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">假设将军是叛徒</p><figure class="ko kp kq kr fq iu fe ff paragraph-image"><div class="fe ff kn"><img src="../Images/fe5a84cf664b23b2b9abd0046854c550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*IckdglyYTJ7pxdq0CTKzLw.png"/></div></figure><p id="0fde" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">1和2都是忠诚的，叛徒是将军会给两个不同的命令，告诉1进攻，告诉2撤退，这时1和2会互相交流，因为1和2收到的命令不同，所以他们会怀疑将军和其中一个会是叛徒，所以两个例子都是无解的。</p><p id="18f5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">如果n &gt; 3m问题可解</strong></p><p id="a55e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">假设m=1，n=4(一个将军和3个副官，一个副官是叛徒)</p><figure class="ko kp kq kr fq iu fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/0be5d05c0f5e2e8a9baea91d1a472c52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*MGrYdSjnDrLIBAWn4MVn6A.png"/></div></figure><p id="2028" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">将军告诉三名副官，命令是<strong class="jd hu">攻击</strong>，三名副官将互相交流。1和2之间的通信结果是一次<strong class="jd hu">攻击</strong>。因为3是叛徒，所以和1，2沟通的时候会被告知，他们接到的命令是<strong class="jd hu">撤退</strong>。</p><p id="1885" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">所以我们可以得出结论，1收到的命令是(进攻，进攻，撤退)v1=(A，A，R)所以1号会选择进攻。因为2也是忠诚的副官，所以他接到的命令(进攻，进攻，撤退)使得№2也选择进攻。</p><p id="b8ac" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">假设将军是叛徒，三个副官是忠诚的</p><figure class="ko kp kq kr fq iu fe ff paragraph-image"><div class="fe ff kt"><img src="../Images/f3349ac78e08de0019cc5a4dc549c602.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*KKXTlYjOVUPL1RU-t-DaYw.png"/></div></figure><p id="4072" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果将军是叛徒，那么现在只需要满足<strong class="jd hu">一致性</strong>和忠诚的副官服从同样的命令，不管命令是不是将军下达的。举个例子，如果卖国贼将军让1和2进攻，让3撤退，那么他们就会交流。1会告诉2他收到的命令是攻击命令，2会告诉1接受。收到的命令是攻击命令，2会告诉3这是攻击命令。3会告诉2收到撤退命令，1会告诉3收到攻击命令，3会告诉1收到撤退命令。所以1收到的命令集合是(攻击，攻击，撤退)，2收到的命令集合是(攻击，攻击，撤退)，3收到的命令集合是(撤退，攻击，攻击)所以这三个辅助者都会选择攻击，于是达成协议。三名助理可以达成协议。因为将军下达的命令比较混乱，执行哪一个都无所谓，达成一致就行。</p><p id="d8ba" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上面的例子是一个简单的例子，只有一个叛徒，但是如果叛徒的数量大于一呢？m=2，<strong class="jd hu">那么我们现在该怎么办？</strong></p><p id="ca5d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">由于m=2，n至少为7，如果小于7，则无解。这时候就会用到一个叫做<strong class="jd hu">递归</strong>的想法，在计算机中很常见。例:当摄像头对着你，结果你用摄像头对着电脑屏幕，这个时候你会发现一台电脑设置到另一台电脑，然后另一台电脑设置，我们可以认为是一种嵌套。</p><p id="bff9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，一个将军会向6个副官发出攻击命令，因为现在有两个叛徒，我们假设将军不是叛徒，假设5和6是叛徒(下图我没有画连接线，因为看起来很乱:)</p><figure class="ko kp kq kr fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ku"><img src="../Images/a0350081ae78ef71b71d66e1d927a133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5McMRDlcUtJttYJguG77Gw.png"/></div></div></figure><p id="afc6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">1接到进攻的命令，他不会马上去进攻，因为他不确定将军是不是汉奸，所以他会问2你接到将军的命令是什么？但他也不会相信2，因为他不确定2是否也是叛徒。所以它会继续问3，4，5，6。Q2告诉你他收到了什么订单，我们接下来将查看表格</p><figure class="ko kp kq kr fq iu fe ff paragraph-image"><div class="fe ff kv"><img src="../Images/67c6dc612f960345e60f4d5a0bcca258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*gY2jobiprLM-30V8j4KZ1w.png"/></div></figure><p id="b4ae" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先副官№1接到将军的进攻命令，所以A代表进攻，所以A会问大家收到的命令，因为№2是忠诚的，所以他收到的命令也是进攻，副官№3也是忠诚的，会说实话№2、№4也是忠诚的，而№5副官是叛徒，胡说八道，所以给出的不一定是什么所以我们在表中用A代替。副官№6也是汉奸，所以也是瞎说，也不一定说什么，所以我们在表中用b。所以№1得到的信息会发现，副官№2的陈述中有三个人说副官№2得到的命令是A，有两个人不知道他们在说什么，s <strong class="jd hu"> o我们取最大值原则</strong>，最后我们判定副官2收到的命令确实是攻击(取最大值原则)，我们再做同样的事情， 辅助1、2、3、4，收到的订单是A，辅助5、6收到的订单不确定。 ，所以第一列我们取最大值A =攻击，所以最后的结果是1，2，3，4个辅助者会选择攻击，同时保证一致性和准确性。</p><p id="da10" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">以上问题没有考虑网络延迟。在实际的互联网上，存在着网络延迟，于是诞生了一种简单实用的拜占庭容错算法，叫做<strong class="jd hu"> PBFT </strong>，在网络延迟的情况下仍然可以使用这种算法。在少数节点和故障节点存在的情况下，保证大多数忠诚节点的一致性和准确性。例如，中本聪提出了比特币。区块链的核心问题是保持一致性。如何保持一致性？我们可以将共识算法定义为区块链网络达成共识的机制。最常见的例子是工作证明(<strong class="jd hu"> PoW </strong>)和利益证明(<strong class="jd hu"> PoS </strong>)。与拜占庭的一般问题相比，这增加了叛徒的成本。如果你没有任何成本，网络上的恶意节点可以自由传播。比特币协议规定了系统的主要规则，工作证明共识算法描述了如何遵循这些规则达成共识(例如，在交易的验证和确认期间)。</p><p id="d965" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">虽然工作证明的概念早于数字货币，但中本聪修改了原始版本，并开发了一种改进的工作证明算法，可以生成比特币作为拜占庭容错系统。</p><p id="22ff" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">请注意，这种工作验证算法并不能完全抵御拜占庭故障，但由于高成本的挖掘过程和底层加密技术，工作验证已被证明是区块链网络中最安全可靠的方法之一。从这个意义上来说，由中本聪设计的工作证明一致性算法被许多人认为是拜占庭容错的最出色的解决方案之一。</p><blockquote class="kw"><p id="7cef" class="kx ky ht bd kz la lb lc ld le lf jy ek translated"><em class="lg">加入Coinmonks </em> <a class="ae lh" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank"> <em class="lg">电报频道</em> </a> <em class="lg">和</em> <a class="ae lh" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> <em class="lg"> Youtube频道</em> </a> <em class="lg">了解加密交易和投资</em></p></blockquote><h1 id="d8bc" class="li lj ht bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf dt translated">另外，阅读</h1><ul class=""><li id="3ed2" class="jz ka ht jd b je mg ji mh jm mi jq mj ju mk jy ml kf kg kh dt translated"><a class="ae lh" href="https://coincodecap.com/trading-signal" rel="noopener ugc nofollow" target="_blank">有哪些交易信号？</a> | <a class="ae lh" href="https://coincodecap.com/bitstamp-coinbase" rel="noopener ugc nofollow" target="_blank"> Bitstamp vs比特币基地</a> | <a class="ae lh" href="https://coincodecap.com/buy-solana" rel="noopener ugc nofollow" target="_blank">买索拉纳</a></li><li id="eb7d" class="jz ka ht jd b je ki ji kj jm kk jq kl ju km jy ml kf kg kh dt translated"><a class="ae lh" href="https://coincodecap.com/profitfarmers-review" rel="noopener ugc nofollow" target="_blank"> ProfitFarmers点评</a> | <a class="ae lh" href="https://coincodecap.com/cornix-trading-bot" rel="noopener ugc nofollow" target="_blank">如何使用Cornix交易机器人</a></li><li id="273e" class="jz ka ht jd b je ki ji kj jm kk jq kl ju km jy ml kf kg kh dt translated"><a class="ae lh" href="https://coincodecap.com/copy-trading-spain" rel="noopener ugc nofollow" target="_blank">西班牙5大最佳文案交易平台</a></li><li id="0ae8" class="jz ka ht jd b je ki ji kj jm kk jq kl ju km jy ml kf kg kh dt translated"><a class="ae lh" href="https://coincodecap.com/pionex-dual-investment" rel="noopener ugc nofollow" target="_blank"> Pionex双投</a> | <a class="ae lh" href="https://coincodecap.com/advcash-review" rel="noopener ugc nofollow" target="_blank"> AdvCash审核</a> | <a class="ae lh" href="https://coincodecap.com/uphold-review" rel="noopener ugc nofollow" target="_blank">支持审核</a></li><li id="a83e" class="jz ka ht jd b je ki ji kj jm kk jq kl ju km jy ml kf kg kh dt translated"><a class="ae lh" href="https://coincodecap.com/best-cryptocurrency-apis" rel="noopener ugc nofollow" target="_blank">面向开发者的8个最佳加密货币API</a></li><li id="16b8" class="jz ka ht jd b je ki ji kj jm kk jq kl ju km jy ml kf kg kh dt translated"><a class="ae lh" href="https://coincodecap.com/best-cryptocurrency-blogs" rel="noopener ugc nofollow" target="_blank">十大最佳加密货币博客</a> | <a class="ae lh" href="https://coincodecap.com/youhodler-review" rel="noopener ugc nofollow" target="_blank"> YouHodler评论</a></li></ul></div></div>    
</body>
</html>