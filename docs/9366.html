<html>
<head>
<title>How to Build &amp; Deploy a Solana Smart Contract using Anchor — KryptoMind</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Anchor-KryptoMind构建和部署Solana智能合同</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/how-to-build-deploy-a-solana-smart-contract-using-anchor-kryptomind-5dc53d119125?source=collection_archive---------34-----------------------#2022-06-25">https://medium.com/coinmonks/how-to-build-deploy-a-solana-smart-contract-using-anchor-kryptomind-5dc53d119125?source=collection_archive---------34-----------------------#2022-06-25</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/a9b8b22b95bfaa0024ef7c4d45becb0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y8TeZNaqDRA4kKMxBiaMDw.png"/></div></div></figure><p id="b19a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果你想学习如何创建索拉纳智能合同和程序，你来对地方了。Solana是一个崭露头角的高性能、无权限的区块链，支持快速、廉价和可伸缩的交易，并支持用Rust、C++和C编写的智能合约</p><h1 id="164f" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">索拉纳是什么？</h1><p id="fc2a" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">Solana是一个分散的区块链生态系统，旨在消除影响现有区块链的拥塞和可扩展性问题。区块链主要关注增加的可伸缩性，例如更大的(TPS)和更快的确认时间。这是一项开源计划，结合了英特尔、网景、谷歌和高通的尖端技术，帮助Solana保持高性能标准。</p><h1 id="6b47" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">索拉纳智能合同的架构</h1><p id="c183" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">传统的EVM支持的区块链与Solana的智能合同模型不同。传统的基于EVM的契约将代码/逻辑和状态组合成一个链上部署的契约。另一方面，Solana上的智能契约处于“只读”或“无状态”模式，只包含程序的逻辑。一旦设置了智能合约，它就可以被其外部的帐户访问。这些帐户与程序交互，并存储有关程序如何与它们交互的数据。</p><blockquote class="lc ld le"><p id="2dd5" class="jb jc lf jd b je jf jg jh ji jj jk jl lg jn jo jp lh jr js jt li jv jw jx jy hm dt translated">交易新手？试试<a class="ae lj" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae lj" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote><p id="e24e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这允许状态(帐户)和契约逻辑(程序)的逻辑分离，这将典型的EVM支持的智能契约与Solana智能契约区分开来。此外，索拉纳和其他区块链的帐户是非常不同的。相比以太坊账户，以太坊账户只是指向用户钱包的指针，Solana账户持有数据(比如钱包信息)。</p><p id="c2ef" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">此外，Solana有一个CLI和JSON RPC API来改进DApp与Solana的交互。此外，分散的应用程序可能会使用当前的SDK连接区块链和索拉纳程序。</p><figure class="ll lm ln lo fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lk"><img src="../Images/1b41c78152c33a8061965470ebedc053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vlX0QymYuHzp2c42"/></div></div></figure><ul class=""><li id="4ccc" class="lp lq ht jd b je jf ji jj jm lr jq ls ju lt jy lu lv lw lx dt translated">上图左侧的程序描述了开发过程，该过程使用户能够在Solana区块链上构建和部署独特的Rust、C和C++程序。</li><li id="5449" class="lp lq ht jd b je ly ji lz jm ma jq mb ju mc jy lu lv lw lx dt translated">一旦这些应用被有效地分发，任何有编程知识的人都可以利用它们。用户必须使用现有的客户端SDK和JSON RPC API来创建dApps，以便与这些应用进行交互。</li><li id="d721" class="lp lq ht jd b je ly ji lz jm ma jq mb ju mc jy lu lv lw lx dt translated">用户可以创建分散的应用程序，用于与第二个开发工作流客户端(在左下方)下部署的程序进行交互。这些app可能会构造各种应用，比如加密货币钱包、去中心化交易所等等，并通过客户端SDK向这些程序发送交易。</li><li id="0fdc" class="lp lq ht jd b je ly ji lz jm ma jq mb ju mc jy lu lv lw lx dt translated">程序和客户端是该流程的两个组成部分，它们共同创建了一个全面的dApps和程序网络，可以通过通信来更新状态和分析区块链。</li></ul><h1 id="5f80" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">什么是锚？</h1><p id="e6eb" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">Anchor是一个创建Solana智能合同的框架，包括许多开发工具。简而言之，锚挽救了你的生命，让创建智能合同变得异常简单。</p><h1 id="2e20" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">先决条件</h1><h2 id="e467" class="md ka ht bd kb me mf mg kf mh mi mj kj jm mk ml kn jq mm mn kr ju mo mp kv mq dt translated">生锈:</h2><p id="ff46" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">这是一个先决条件，因为它是一种非常强大的通用编程语言。这将适用于智能合同的创建。</p><h2 id="d4f8" class="md ka ht bd kb me mf mg kf mh mi mj kj jm mk ml kn jq mm mn kr ju mo mp kv mq dt translated">索拉纳工具套装:</h2><p id="a8b4" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">这包含了索拉纳CLI。</p><h2 id="9214" class="md ka ht bd kb me mf mg kf mh mi mj kj jm mk ml kn jq mm mn kr ju mo mp kv mq dt translated">入门指南</h2><p id="5dd9" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">首先，创建一个新的锚点项目:</p><p id="0222" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">锚初始化计数器应用程序</p><p id="670b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在项目结构中，您将看到以下文件和文件夹。</p><p id="210a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">程序—这是索拉纳程序(智能合同)的目录</p><p id="88ba" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">测试——这是javascript测试代码存在的地方</p><p id="fd64" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">迁移—这是部署脚本</p><p id="48f5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">应用程序—这是前端将要构建的地方</p><p id="cfbb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们看看程序目录中的lib.rs文件。</p><pre class="ll lm ln lo fq mr ms mt mu aw mv dt"><span id="3e56" class="md ka ht ms b fv mw mx l my mz">use anchor_lang::prelude::*;</span><span id="e545" class="md ka ht ms b fv na mx l my mz">declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");</span><span id="0497" class="md ka ht ms b fv na mx l my mz">#[program]<br/>pub mod counterapp {<br/>    use super::*;<br/>    pub fn initialize(ctx: Context&lt;Initialize&gt;) -&gt; ProgramResult {       <br/>        Ok(())<br/>    }<br/>}<br/>#[derive(Accounts)]<br/>pub struct Initialize {}</span></pre><p id="3f52" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最基本的CLI程序是这个。当被调用时，initialize函数只完成；初始化结构建立初始化函数的环境。</p><p id="dd9a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">设置好我们的项目后，让我们创建我们的计数器应用程序。</p><p id="f7d2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要做到这一点，我们必须首先建立一个帐户，我们可以保存我们的数据。你可能想知道这个账户到底是什么。帐户只是在Solana sealevel中访问和保存数据的一种手段。</p><p id="9ad0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在上面的代码中，我们定义了两个结构；CounterAccount结构是我们的帐户，它包含一个将存储我们的计数的count变量。</p><pre class="ll lm ln lo fq mr ms mt mu aw mv dt"><span id="c758" class="md ka ht ms b fv mw mx l my mz">#[derive(Accounts)]<br/>pub struct Create&lt;'info&gt; {<br/>    <br/>    #[account(init, payer=user, space = 16+16)]<br/>    pub counter_account: Account&lt;'info, CounterAccount&gt;,<br/>    <br/>    #[account(mut)]<br/>    pub user: Signer&lt;'info&gt;,<br/>    <br/>    pub system_program: Program&lt;'info, System&gt;,<br/>}<br/>#[account]<br/>pub struct CounterAccount {<br/>    pub count: u64,<br/>}</span></pre><p id="9844" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Create struct是我们的指令struct，它定义了创建帐户的上下文，它说，“嘿，我想创建一个带有32字节空间的帐户counter_account”。</p><p id="3e80" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">#[account(…)]属性定义了Anchor为创建上下文而进行的预处理中的约束和指令。现在让我们创建我们的函数。</p><pre class="ll lm ln lo fq mr ms mt mu aw mv dt"><span id="e135" class="md ka ht ms b fv mw mx l my mz">pub fn create(ctx: Context&lt;Create&gt;) -&gt; ProgramResult {<br/>let counter_account = &amp;mut ctx.accounts.counter_account;<br/>counter_account.count = 0;<br/>Ok(())<br/>}</span></pre><p id="3486" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Create函数是rpc请求的处理程序，它接受用Create struct创建的上下文。</p><p id="6894" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们创建测试函数并部署我们的杰作。</p><pre class="ll lm ln lo fq mr ms mt mu aw mv dt"><span id="d615" class="md ka ht ms b fv mw mx l my mz">import * as anchor from '<a class="ae lj" href="http://twitter.com/project" rel="noopener ugc nofollow" target="_blank">@project</a>-serum/anchor';<br/>import { Program } from '<a class="ae lj" href="http://twitter.com/project" rel="noopener ugc nofollow" target="_blank">@project</a>-serum/anchor';<br/>import { Counterapp } from '../target/types/counterapp';<br/>describe('counterapp', () =&gt; {<br/>    const provider = anchor.Provider.env()<br/>    anchor.setProvider(provider);<br/>    const program = anchor.workspace.Counterapp as Program&lt;Counterapp&gt;;<br/>    const counterAccount = anchor.web3.Keypair.generate();<br/>    it('Is initialized!', async () =&gt; {<br/>        await program.rpc.create({<br/>            accounts: {<br/>                counterAccount: counterAccount.publicKey,<br/>                user: provider.wallet.publicKey,<br/>                systemProgram: anchor.web3.SystemProgram.programId,<br/>            },<br/>            signers: [counterAccount]<br/>        } as any)<br/>    });<br/>    it("Increment counter", async () =&gt; {<br/>        await program.rpc.increment({<br/>            accounts: {<br/>                counterAccount: counterAccount.publicKey<br/>            }<br/>        } as any)<br/>    })<br/>    it("Fetch account", async () =&gt; {<br/>        const account: any = await<br/>        program.account.counterAccount.fetch(counterAccount.publicKey)<br/>        console.log(account.count)<br/>    })<br/>});</span></pre><p id="9cc0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，进行测试。</p><pre class="ll lm ln lo fq mr ms mt mu aw mv dt"><span id="0589" class="md ka ht ms b fv mw mx l my mz">anchor test</span></pre><p id="e11a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">测试通过后，我们现在可以部署程序了。确保solana-test-validator正在运行。</p><pre class="ll lm ln lo fq mr ms mt mu aw mv dt"><span id="406d" class="md ka ht ms b fv mw mx l my mz">anchor deploy</span></pre><h1 id="bb59" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">结论</h1><p id="5357" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">随着越来越多的行业采用区块链和分散式技术，分散式应用的使用正在扩大。Solana允许创建快速、适应性强的智能合同和分散式应用程序，作为一个可访问、高速且负担得起的生态系统。它还经常提供更新。因为Solana提供了各种前沿资源，如SDK、框架和开发工具，所以像我们这样的开发人员都渴望在其上进行构建。该平台还包括侵入式工具，如Solana CLI和Solana Explorer，让用户通过命令行与协议进行交互。</p></div><div class="ab cl nb nc hb nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="hm hn ho hp hq"><p id="ea05" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="lf">原载于2022年6月25日</em><a class="ae lj" href="https://kryptomind.com/how-to-build-deploy-a-solana-smart-contract-using-anchor/" rel="noopener ugc nofollow" target="_blank"><em class="lf">【https://kryptomind.com】</em></a><em class="lf">。</em></p></div></div>    
</body>
</html>