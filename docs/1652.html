<html>
<head>
<title>Crypto feature importance for Deep Reinforcement Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加密特征对深度强化学习的重要性</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/crypto-feature-importance-for-deep-reinforcement-learning-38416616c2a36-8416616c2a36?source=collection_archive---------5-----------------------#2022-03-04">https://medium.com/coinmonks/crypto-feature-importance-for-deep-reinforcement-learning-38416616c2a36-8416616c2a36?source=collection_archive---------5-----------------------#2022-03-04</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/ba7e68a3cad75a4f38b8260cfa013331.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7eac8ngUQsKpG2vl.jpg"/></div></div></figure><div class=""/><p id="94a8" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">本文由开源项目AI4Finance的核心团队成员Berend Gort &amp; <a class="ae jz" href="https://ai4finance.medium.com/" rel="noopener"> Bruce Yang </a>撰写。这个项目是一个共享金融AI工具的开源社区，是纽约哥伦比亚大学的一部分。GitHub链接:</p><div class="hs ht fm fo hu ka"><a href="https://github.com/AI4Finance-Foundation" rel="noopener  ugc nofollow" target="_blank"><div class="kb ab ej"><div class="kc ab kd cl cj ke"><h2 class="bd if fv z el kf eo ep kg er et id dt translated">ai4金融基金会</h2><div class="kh l"><h3 class="bd b fv z el kf eo ep kg er et ek translated">一个共享金融AI工具的开源社区。FinRL:第一个用于财务强化的开源项目…</h3></div><div class="ki l"><p class="bd b gc z el kf eo ep kg er et ek translated">github.com</p></div></div><div class="kj l"><div class="kk l kl km kn kj ko ia ka"/></div></div></a></div><p id="5f11" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">结果</strong></p><p id="5ed3" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在我的新文章中，我们展示了使用此管道的一些结果:</p><div class="hs ht fm fo hu ka"><a rel="noopener follow" target="_blank" href="/@CoderBurnt/best-technical-indicators-for-bitcoin-fromta-lib-fa5518560e"><div class="kb ab ej"><div class="kc ab kd cl cj ke"><h2 class="bd if fv z el kf eo ep kg er et id dt translated">来自TA-lib的比特币最佳技术指标</h2><div class="kh l"><h3 class="bd b fv z el kf eo ep kg er et ek translated">本文由开源项目AI4Finance的核心团队成员Berend Gort &amp; Bruce Yang撰写。这个…</h3></div><div class="ki l"><p class="bd b gc z el kf eo ep kg er et ek translated">medium.com</p></div></div><div class="kj l"><div class="kp l kl km kn kj ko ia ka"/></div></div></a></div><p id="9847" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">简介</strong></p><p id="8028" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">本教程旨在对深度强化学习(DRL)过程中使用的神经网络进行特征重要性分析。部署传统的机器学习技术来决定最佳特征。</p><p id="1ca3" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">简而言之，这条管道是为了:</strong></p><ol class=""><li id="56d2" class="kq kr ie jd b je jf ji jj jm ks jq kt ju ku jy kv kw kx ky dt translated"><strong class="jd if">确定价格上涨或下跌的高度可预测性特征(在本笔记本中)</strong></li><li id="b9c2" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy kv kw kx ky dt translated"><strong class="jd if">为DRL建立相应的网络(在本笔记本中)</strong></li><li id="959c" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy kv kw kx ky dt translated"><strong class="jd if">插入DRL的(不在本笔记本中)</strong></li></ol><p id="b625" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该管道是Lopez de Prado，M. (2018)在《金融机器学习进展》中提出的想法的组合。本教程遵循类似的方法，但不同之处在于神经网络用于分类无所事事，短期或长期。本文分为五个主要部分:</p><ul class=""><li id="9af6" class="kq kr ie jd b je jf ji jj jm ks jq kt ju ku jy le kw kx ky dt translated">Ch2:改编的币安下载器</li><li id="4799" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated">Ch3:三重屏障法</li><li id="f745" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated">Ch5:分数微分</li><li id="ba51" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated">Ch6:建模(在我们的例子中是神经网络)</li><li id="8d13" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated">Ch8:功能重要性</li></ul><p id="163f" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">ai4 finance foundation FinRL-Meta repo上提供了一款实用的Google Colab笔记本:</p><div class="hs ht fm fo hu ka"><a href="https://github.com/AI4Finance-Foundation/FinRL-Meta/blob/master/Demo_Crypto_Feature_Importance.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="kb ab ej"><div class="kc ab kd cl cj ke"><h2 class="bd if fv z el kf eo ep kg er et id dt translated">FinRL-Meta/Demo _ Crypto _ Feature _ importance . ipynb at master ai4 finance-Foundation/FinRL-Meta</h2><div class="kh l"><h3 class="bd b fv z el kf eo ep kg er et ek translated">FinRL -Meta:数据驱动的金融强化学习的宇宙。🔥 …</h3></div><div class="ki l"><p class="bd b gc z el kf eo ep kg er et ek translated">github.com</p></div></div><div class="kj l"><div class="lf l kl km kn kj ko ia ka"/></div></div></a></div></div><div class="ab cl lg lh hb li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hm hn ho hp hq"><p id="15d5" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if"> Ch2:改编的币安下载器</strong></p><p id="456e" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果你没有使用烛台(或蜡烛线)数据的经验，我们推荐这个视频:</p><figure class="ln lo lp lq fq hv"><div class="bz el l di"><div class="lr ls l"/></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Beginner’s guide to Candlestick data (klines)</figcaption></figure><p id="cfd2" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，需要无限的数据。这个处理器对你想下载的klines的数量没有限制。然而，<a class="ae jz" href="https://www.youtube.com/watch?v=qg-oboAY8rM" rel="noopener ugc nofollow" target="_blank">它需要来自币安的数据API密钥</a>。</p><figure class="ln lo lp lq fq hv"><div class="bz el l di"><div class="lx ls l"/></div></figure><p id="e91d" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">好了，回到处理器。该类有五个重要的方法:</p><ol class=""><li id="a5a6" class="kq kr ie jd b je jf ji jj jm ks jq kt ju ku jy kv kw kx ky dt translated">运行()</li><li id="929f" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy kv kw kx ky dt translated">下载数据()</li><li id="e52f" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy kv kw kx ky dt translated">添加技术指标()</li><li id="2e7c" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy kv kw kx ky dt translated">目标阵列()</li><li id="b67c" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy kv kw kx ky dt translated">get _币安_酒吧()</li></ol><p id="6f75" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要使用这个类，只需创建它的一个实例，然后应用run()方法。因此，我们将按顺序解释run方法。从那里开始。BinanceProcessor()的一个实例只需要API信息。</p><p id="1f01" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">之后，您可以在实例上调用run方法。运行方法要求:</p><ul class=""><li id="5492" class="kq kr ie jd b je jf ji jj jm ks jq kt ju ku jy le kw kx ky dt translated"><em class="ly"> ticker_list </em>:您要下载的交易对列表。这些必须可以在任何一个<a class="ae jz" href="https://www.binance.com/en/trade/BTC_USDT?layout=basic" rel="noopener ugc nofollow" target="_blank">币安市场</a>买到。</li><li id="32fe" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated"><em class="ly">start _ date</em>/<em class="ly">end _ date</em>:正确格式的两个字符串(Y%-M%-D% h%:m%:s%)。指示下载的开始和结束</li><li id="d404" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated"><em class="ly"> time_interval </em>:开始日期和结束日期之间的数据采样。格式应符合<a class="ae jz" href="https://python-binance.readthedocs.io/en/latest/binance.html" rel="noopener ugc nofollow" target="_blank">币安文件</a>。</li><li id="1d50" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated"><em class="ly">technical _ indicator _ list</em>:目前还不支持为币安下载器添加自定义技术指标。<strong class="jd if">这意味着为了分析额外的特征，必须手动将它们添加到处理器中。</strong>或者，其他数据源也可以集成到处理器中，以获得额外的功能。这超出了本文的范围，留给读者作为练习。</li><li id="e402" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated"><em class="ly"> if_vix </em> =False。暂时忽略它。</li></ul><p id="6672" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">读者现在理解了run()方法的输入。之后，调用download_data()。</p><pre class="ln lo lp lq fq lz ma mb mc aw md dt"><span id="debd" class="me mf ie ma b fv mg mh l mi mj">data = self.download_data(ticker_list, start_date, end_date, time_interval)</span></pre><p id="6073" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">它循环遍历<em class="ly"> ticker_list </em>，为每个ticker创建一个单独的数据帧，并将它们附加在一起。建议这款Google Colab笔记本将您的分析限制在一种加密货币上。剩下的代码还没有为多重加密分析而构建。</p><p id="2c04" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">通过<em class="ly"> ticker_list </em>的循环将<em class="ly">get _币安_bars() </em>应用于<em class="ly"> ticker_list中的每个股票。</em>这个方法使用币安客户端来获取klines，丢弃我们不感兴趣的klines，并将时间戳标签更改为索引。好了，现在我们回到run() 方法。我们得到了我们的数据框架。我们清理它并应用方法<em class="ly">添加技术指标</em>。</p><pre class="ln lo lp lq fq lz ma mb mc aw md dt"><span id="042e" class="me mf ie ma b fv mg mh l mi mj">data = self.add_technical_indicator(data, technical_indicator_list)</span></pre><p id="facf" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这就是TA-lib发挥作用的地方(技术分析库)。此处显示了受支持指示器的列表。你可以在数据处理器中添加TA-lib的任何功能，就像相对强弱指数(RSI)、移动平均收敛背离(MACD)、商品通道指数(CCI)和方向移动指数(DX)一样。这些指标中的大部分都是根据曲线(或开盘-盘高-盘低-收盘交易量数据，OHLCV)计算出来的。这一部分留给读者作为练习。</p><p id="4483" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">熊猫数据框现在可以进行进一步的分析了。方法<em class="ly"> df_to_array() </em>将数据帧转换为Numpy数组，该数组可以直接输入到AI4Finance GitHub中的深度强化学习(DRL)算法。这不是本文的目标，因此我们的数据现在已经准备好了。</p></div><div class="ab cl lg lh hb li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hm hn ho hp hq"><p id="70cc" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if"> Ch3:三重屏障法(第43页，洛佩斯·德·普拉多博士)</strong></p><p id="2bd0" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">考虑一个特征矩阵<em class="ly"> X </em>和一个<em class="ly"> I </em>行。特征矩阵存在于OHLCV数据和增加的技术指标中。一个例子:</p><figure class="ln lo lp lq fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff mk"><img src="../Images/24b64e5ed9808cfa763130d8f2413ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P2SrJ4V6HSRJUwoQ7vCTFg.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Example of data frame obtained by the BinanceProcessor class</figcaption></figure><p id="b975" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们首先研究一下你的直觉。和我待在这里。考虑下面的BTC/USDT图表。我们从2017年8月30日抽取一个红盒子，价格是4580。我们如何画这个盒子现在并不重要。盒子上有三条重要的线:</p><ul class=""><li id="c693" class="kq kr ie jd b je jf ji jj jm ks jq kt ju ku jy le kw kx ky dt translated">如果价格首先触及箱体底部，我们将观察值标记为y = 0(价格触及止损)。</li><li id="1ef6" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated">如果价格首先触及箱体的顶部，我们将观察标记为y = 2(价格触及获利回吐)。</li><li id="253e" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated">如果价格达到盒子的右侧，我们将观察值标记为y = 1，赌注超时(在盒子的时间范围内没有显著的价格变化)</li></ul><p id="40ac" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">想象一下，我们已经执行了这个标记，现在我们可以根据我们所拥有的特征进行预测了！0:做空，1:什么都不做，2:做多。</p><figure class="ln lo lp lq fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff ml"><img src="../Images/ef8288da6375899685ff859b85350967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cjuTjn21rzVLPXFSReYRpQ.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">BTC/USDT chart and a box</figcaption></figure><p id="c2e4" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们找到一个合理的方法来得到盒子的形状。数学形式的等价标记规则是:</p><figure class="ln lo lp lq fq hv fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/d9e0771238923fa53547e0565a311918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*ugl5Qd_Lk1dS0nN0eg0Rpg.png"/></div></figure><p id="9da2" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这里，𝜏是一个预定义的阈值，我们将在稍后确定。t(i，0)是第X(i)次观测的时间索引。t(i，0) + h是t(i，0)之后第h条的索引。现在用英语；从某个日期开始，比如2017年8月30日，添加<em class="ly"> h </em>数据点。如果收益低于前面描述的底部横线，标记为0。当返回的绝对值在上下横条之间时，标记为1。最后，如果返回超过顶栏标记为2。</p><p id="cbd2" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，r(t，h)是一个棒线水平h的价格回报:</p><figure class="ln lo lp lq fq hv fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/faca20f8b247df170069580378596b5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*RZ6SewupIXmHGNIzeuWMcA.png"/></div></figure><p id="5848" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们希望将止盈/止损水平条设置为每日波动的函数。<strong class="jd if">波动性是衡量价格上下波动程度的指标，如果我们在设定价格箱之前没有根据这些价格波动进行调整，我们的价格箱将会太大或太小，以至于价格无法以相当一致的方式触及价格箱。</strong></p><figure class="ln lo lp lq fq hv"><div class="bz el l di"><div class="lx ls l"/></div></figure><p id="50ea" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">下面的函数遍历上面代码片段产生的时间戳和相应的波动性。通过的数据点数是自第一次观察以来通过了多少次观察。</p><p id="ecd5" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后，让我们首先产生障碍值。垂直障碍是时间戳，另外两个障碍是价格。</p><ul class=""><li id="bebb" class="kq kr ie jd b je jf ji jj jm ks jq kt ju ku jy le kw kx ky dt translated">垂直屏障是由<em class="ly"> t_final </em>根据通过的数据点定义的超时。因此，如果仍然有足够的数据点，并且设置了超时，垂直障碍就是波动率指数的指数(时间戳)加上超时。</li></ul><figure class="ln lo lp lq fq hv fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/50f49ee3a9f4f70cc90a180621c15fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*CFw_W6eFQtBkXNtTywoMmA.png"/></div></figure><ul class=""><li id="d8db" class="kq kr ie jd b je jf ji jj jm ks jq kt ju ku jy le kw kx ky dt translated">然后在第二个if语句中设置顶部屏障。上限是作为每日波动率的动态函数计算的，从当前价格乘以乘数。这个乘数是一个常数，并且是预先设定的。</li></ul><figure class="ln lo lp lq fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff mp"><img src="../Images/5cc9c9e9c24d501d7f05d466b1358b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Um9nw40tQ5Kc-JUhwDYplw.png"/></div></div></figure><ul class=""><li id="25e9" class="kq kr ie jd b je jf ji jj jm ks jq kt ju ku jy le kw kx ky dt translated">对于底障，与顶障相同，但方向相反。</li></ul><figure class="ln lo lp lq fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff mq"><img src="../Images/e95ebe63198f1bacbfc64abb4bb5e3f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BweEQzhxIpduWhPOO595Xg.png"/></div></div></figure><figure class="ln lo lp lq fq hv"><div class="bz el l di"><div class="lx ls l"/></div></figure><p id="ddb7" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">新创建的数据帧的一个例子<em class="ly">障碍:</em></p><figure class="ln lo lp lq fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff mr"><img src="../Images/aac02f47109584248418fc5192d04b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tfknWIzLV9tiY4DJg5bA_g.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Example of the barriers dataframe</figcaption></figure><p id="0e19" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">好了，我们现在有目标了。我们可以相应地开始标记。这个函数遵循前面定义的标签规则。首先，我们得到开始和超时日期，它对应于索引和设置的垂直屏障。然后，我们找到盒子极值的价格。之后，我们检查条件，如果有任何顶部或底部障碍击中。最后，如果没有障碍物撞击，它将撞击垂直障碍物。</p><figure class="ln lo lp lq fq hv"><div class="bz el l di"><div class="lx ls l"/></div></figure></div><div class="ab cl lg lh hb li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hm hn ho hp hq"><p id="de6a" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if"> Ch5:分数微分(第75页)，！可选！</strong></p><p id="3cf0" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">这是一个数据转换的例子，你可以测量它的效果。您也可以<em class="ly">跳过</em>进入Ch8:特性重要性，并使用我们在前面章节中构建的数据框架。这是一个数据转换的例子，我们可以在下一节量化其效果。</strong></p><p id="13b4" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在最后一部分，Ch8:特征重要性，对数丢失误差被形式化。因此，我们可以直接测量分数微分等数据变换对对数损失误差的影响！当然，您可以测试您的数据转换。</p><p id="d05f" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">好，让我们开始分数微分:</p><p id="09ba" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="ly">机器学习</em>喜欢平稳的数据。因此，如果我们有非平稳数据(如2015年以来的BTC价格，可以用指数函数拟合)，我们可以做的是对它进行微分。然而，因为价格总是一个时间序列，当前价格依赖于以前水平的长期历史，这被称为记忆。</p><figure class="ln lo lp lq fq hv"><div class="bz el l di"><div class="lr ls l"/></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">What is stationarity</figcaption></figure><p id="f84b" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">所以我们想通过微分得到稳定的数据。然而，完全区分数据将导致<strong class="jd if">信息</strong>的丢失。因此我们希望<strong class="jd if">对</strong>数据进行分数微分，即不用整数对数据进行微分(如一阶微分；1)，但分数约为0.20。</p><p id="fd89" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">目标:我们想要静态数据，同时尽可能多地保留过去的记忆！</strong></p><p id="d1b8" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">分数微分使用二项式展开来估计原始数据，但阶数较低。目标是使数据更加稳定，同时尽可能多地保留内存:</p><figure class="ln lo lp lq fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff ms"><img src="../Images/bce70f4824596a09dc697cb731a16e98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_R3EZgp8aUfeTLpkCqOjwQ.png"/></div></div></figure><p id="c313" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">所以我们在这里微分w.r.t. <em class="ly"> d . </em>让我们看看一个实数(非整数→分数)的正d是如何保持记忆的。这个等差数列由一个点积组成。上面的系列被赋予某些变量名，最后被简化；它只是二项式展开的一种变换:</p><figure class="ln lo lp lq fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff mt"><img src="../Images/ff736c66d6670e6ba3fe296da43ae2e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qpn1uoQaBkc4cpWa5YqHSQ.png"/></div></div></figure><p id="674d" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，权重可以描述为:</p><figure class="ln lo lp lq fq hv fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/40fa8744982ada159a1267b0478a15d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*N3WH4d7BSptaS9bcx973tw.png"/></div></figure><p id="e380" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">好吧，这是怎么回事？见下图。y轴上是权重值<em class="ly"> w </em>。图例描述了分数微分变量<em class="ly"> d. </em>最后，x轴上是迭代器k。</p><p id="859a" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">关于这个数字，你只需要明白三件事:</p><ul class=""><li id="ed27" class="kq kr ie jd b je jf ji jj jm ks jq kt ju ku jy le kw kx ky dt translated">如果d = 0 →除w_0外所有权重为零。因此，不发生微分，估计值等于原始序列。</li><li id="1829" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated">如果d = 1 → w_0 = 1且w_1 = -1。其余权重为零！看看下面的方程，看着眼熟？由于X(t)和X(t-1)的步长差为1，所以是一阶导数！</li></ul><figure class="ln lo lp lq fq hv fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/1ae39bd07060d4730e0271763a724b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*yxuzrsqblDLhO8NgKkPxaw.png"/></div></figure><ul class=""><li id="44f7" class="kq kr ie jd b je jf ji jj jm ks jq kt ju ku jy le kw kx ky dt translated"><strong class="jd if">d越低，随着k的增加，仍然具有非零值的权重越多。</strong>这意味着记忆被保留(因为考虑了高阶项)</li></ul><figure class="ln lo lp lq fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff mw"><img src="../Images/df894959ab7f9d32060ed2d9ea8d8b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ACHvhMUtFGvKsxn7tLJTIg.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">𝜔 k (y-axis) as k increases (x-axis). Each line is associated with a particular value of d ∈<br/>[0,1], in 0.1 increments.</figcaption></figure><p id="7e34" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">就是这样，你刚刚理解了分数阶微分(简而言之)。所以现在出现了一个新的重要问题:<strong class="jd if">什么值的<em class="ly"> d </em>是可接受的？</strong></p><p id="6f9a" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">将固定宽度窗口fracdiff (FFD)方法应用于时间序列，我们可以计算最小系数d，使得所得的分数微分序列{ X ̃ t } t=l，…，t是平稳的。这个系数d量化了需要移除以实现稳定的内存量。</p><p id="788a" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="ly">我们将使用ADF统计检验来跟踪时间序列中是否存在单位根，单位根表示时间序列是否平稳。如果你有兴趣观看</em> <a class="ae jz" href="https://www.youtube.com/watch?v=2GxWgIumPTA" rel="noopener ugc nofollow" target="_blank"> <em class="ly">这个视频</em> </a> <em class="ly">。</em></p><p id="cad4" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">下一个表格+图显示了关于BTC/USDT原木价格的<a class="ae jz" href="https://www.youtube.com/watch?v=1opjnegd_hA" rel="noopener ugc nofollow" target="_blank"> ADF </a>统计数据。在x轴上，它显示用于生成序列的<em class="ly"> d </em>值，在该序列上计算ADF统计数据。</p><figure class="ln lo lp lq fq hv fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/8c7241693612aebdc89fa29543479bf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*T_20-oubD47m52f1crwR8A.png"/></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">ADF stat</figcaption></figure><p id="0796" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">原始系列的ADF统计值为–2.0(蓝线左侧)，而退货系列的ADF统计值为–110.35(蓝线右侧)。在95%的置信水平下(红色虚线)，测试的临界值是0.1832(蓝色穿过红色虚线)。左边的y轴表示原始序列(d = 0)和不同d值的微分序列之间的相关性。在d = 0.1832时，微分序列和原始序列之间的相关性仍然非常高，为0.993。在那之后，我们会失去很多记忆。</p><figure class="ln lo lp lq fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff my"><img src="../Images/a3729e7c4589dc0b47760adbb6d1e3f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tWcdM4Rk71Da1Ya5SOdqTA.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">ADF statistic as a function of d, on BTC/USDT log-prices</figcaption></figure><p id="6be8" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这证实了在这一章中介绍的过程已经成功地实现了静止而没有放弃太多的内存。相比之下，原始序列和收益序列之间的相关性只有0.011806，因此表明标准整数微分几乎完全消除了序列的记忆。</p><figure class="ln lo lp lq fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff mz"><img src="../Images/d0f8cbd98bca5ce8f3ea8da01d33ad00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d150H9WI8z5VnMcrwFexWg.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Original price and fractionally differentiated price for BTC/USDT</figcaption></figure><p id="01e4" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if"> Ch6:用神经网络模拟分类器来预测0，1，2标签</strong></p><p id="fe70" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这就是深度强化学习(DRL)发挥作用的地方。<strong class="jd if">如果你没有使用DRL加密的经验，这个视频教程(也是我做的)详细解释了如何使用AI4Finance DRL框架有效地培训加密领域的代理。</strong>这是一个非常强大的框架，看起来很容易进入。</p><p id="af68" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">！注意:我们想在这里强调，理解下面的视频并不是理解/关注这篇中等帖子的必要条件！</strong></p><figure class="ln lo lp lq fq hv"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="ea6c" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">所以，AI4Finance提供了一个预编码DRL代理的框架。在<em class="ly"> net.py </em>文件中定义了对应于每个代理的所有神经网络。</p><div class="hs ht fm fo hu ka"><a href="https://github.com/AI4Finance-Foundation/ElegantRL/tree/master/elegantrl/agents" rel="noopener  ugc nofollow" target="_blank"><div class="kb ab ej"><div class="kc ab kd cl cj ke"><h2 class="bd if fv z el kf eo ep kg er et id dt translated">ElegantRL/elegantrl/ai4金融硕士代理-基金会/ElegantRL</h2><div class="kh l"><h3 class="bd b fv z el kf eo ep kg er et ek translated">使用PyTorch的可扩展和弹性深度强化学习。请开始。🔥—ElegantRL/ElegantRL/master上的代理…</h3></div><div class="ki l"><p class="bd b gc z el kf eo ep kg er et ek translated">github.com</p></div></div><div class="kj l"><div class="na l kl km kn kj ko ia ka"/></div></div></a></div><p id="afb1" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当使用我们之前定义的特征时，我们想要测试神经网络的预测性能。比如我对ActorPPO感兴趣，我在<em class="ly"> net.py </em>文件中找到。我复制了这个特定神经网络的一份拷贝(格式有点不同)。因为我们有一个多类问题，所以我们不做<em class="ly"> tanh() </em>最终输出，而是卖/不做/买输出。</p><figure class="ln lo lp lq fq hv"><div class="bz el l di"><div class="lx ls l"/></div></figure><p id="7764" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">之后，在下一部分，有许多指南，如果你想更详细地在网上找到它们，我们推荐你。</p><p id="6e61" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们需要一个虚拟类，将数据转换成可迭代的项，这样PyTorch数据加载器就可以遍历它并获得长度:</p><figure class="ln lo lp lq fq hv"><div class="bz el l di"><div class="lx ls l"/></div></figure><p id="ebab" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">下面的代码</p><ul class=""><li id="a253" class="kq kr ie jd b je jf ji jj jm ks jq kt ju ku jy le kw kx ky dt translated">做一个简单的训练测试。</li><li id="61ec" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated">MinMaxScaler()将输入数据从0-1进行缩放。<em class="ly">训练数据上的fit_transform() </em>和测试数据上的<em class="ly">transform()</em>(Google这是你不知道的)。</li><li id="f4ae" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated">创建两个<em class="ly">分类数据集()的实例。</em></li><li id="2f29" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated">将这些输入PyTorch的DataLoader类，以获得可迭代的ite # Set optimizer<br/>criteria = nn。CrossEntropyLoss()<br/>optimizer = optim。Adam(model_NN1.parameters()，lr=0.0001)毫秒</li><li id="ece4" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated">多类问题的判据是CrossEntropyLoss()(记住最后已经有一个softmax了)。我们使用Adam优化器:</li></ul><pre class="ln lo lp lq fq lz ma mb mc aw md dt"><span id="9052" class="me mf ie ma b fv mg mh l mi mj">criterion = nn.CrossEntropyLoss()</span><span id="2d47" class="me mf ie ma b fv nb mh l mi mj">optimizer = optim.Adam(model_NN1.parameters(), lr=0.0001)</span></pre><figure class="ln lo lp lq fq hv"><div class="bz el l di"><div class="lx ls l"/></div></figure><p id="b645" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">关于训练和测试功能的说明如下:</p><ul class=""><li id="2b95" class="kq kr ie jd b je jf ji jj jm ks jq kt ju ku jy le kw kx ky dt translated"><em class="ly">输出=模型(数据)，</em>这里输出的是一个<em class="ly">批处理_大小*类</em>矩阵。类别维度是短/什么都不做/长的对数概率。</li><li id="2898" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated"><em class="ly"> nn。CrossEntropyLoss() </em>准则<em class="ly"> </em>要求<em class="ly"> </em>将对数概率作为输入，并将目标作为类(0，1，2)的向量。</li><li id="4951" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated">剩下的就不言自明了</li></ul><figure class="ln lo lp lq fq hv"><div class="bz el l di"><div class="lx ls l"/></div></figure><figure class="ln lo lp lq fq hv"><div class="bz el l di"><div class="lx ls l"/></div></figure><p id="b03a" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">那么火车环看起来非常简单</p><pre class="ln lo lp lq fq lz ma mb mc aw md dt"><span id="d802" class="me mf ie ma b fv mg mh l mi mj">model_NN1.to(device)</span><span id="bece" class="me mf ie ma b fv nb mh l mi mj"># State fold (no PurgedKFold build yet, ignore this</span><span id="d9c3" class="me mf ie ma b fv nb mh l mi mj">fold = 0</span><span id="18eb" class="me mf ie ma b fv nb mh l mi mj">for epoch in range(1, epochs + 1):</span><span id="d809" class="me mf ie ma b fv nb mh l mi mj">correct_train, train_loss = train(fold, model_NN1, device, train_loader, optimizer, epoch)</span><span id="6fda" class="me mf ie ma b fv nb mh l mi mj">test(fold, model_NN1, device, test_loader, correct_train, train_loss)</span></pre><p id="778e" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">重要的最后说明:</strong></p><p id="87df" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">现在比如你可以在一定的学习率下训练300个纪元。训练准确率保持缓慢收敛到100%(如预期)。然而，在150个时期之后，测试精度不超过60%。这意味着在纪元150之后，我们已经完全超负荷了。如果在现有的ActorPPO网络上增加一些基本层，准确率已经可以达到75%。</strong></p><p id="4e27" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">主要问题是:</p><p id="d8bf" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="ly">我们现在是否可以得出结论，ElegantRL中的ActorPPO神经网络在DRL训练期间使用这些特定特征不足以捕获给定数据集中的所有信息？</em></p><p id="f19f" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我把这留给读者(和我自己)作为一个假设，因为这本身就是一个完整的研究问题。</p><p id="5df3" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if"> Ch8:特征重要性</strong></p><p id="41ae" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，使用经过训练的神经网络来测量特征的重要性就很容易解释了。用PyTorch来做就不那么容易理解了。</p><p id="4c52" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">方法如下:</p><ol class=""><li id="a859" class="kq kr ie jd b je jf ji jj jm ks jq kt ju ku jy kv kw kx ky dt translated">对于功能中的每一列，洗牌。</li><li id="be41" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy kv kw kx ky dt translated">用打乱的列做一个预测。</li><li id="ed5a" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy kv kw kx ky dt translated">找出实际目标和新预测目标之间的log_loss误差(用混排的列)</li><li id="da27" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy kv kw kx ky dt translated">将这些错误附加到列表中</li><li id="b2c8" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy kv kw kx ky dt translated">对列表排序</li><li id="6454" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy kv kw kx ky dt translated">确定哪个错误是最大的，这是由于列重排造成的</li><li id="90b9" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy kv kw kx ky dt translated">衡量特征重要性</li></ol><p id="3aa9" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">阅读下面的代码。</p><figure class="ln lo lp lq fq hv"><div class="bz el l di"><div class="lx ls l"/></div></figure><p id="9168" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最终结果如下所示:</p><figure class="ln lo lp lq fq hv fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/0db37b89857f013b35e7546940653775.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*T4A_k91XBJmIRzEPb6nNvw.png"/></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Feature importance</figcaption></figure><p id="bf20" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在您可以开始使用这个管道了！</p><ul class=""><li id="e0ed" class="kq kr ie jd b je jf ji jj jm ks jq kt ju ku jy le kw kx ky dt translated">你想要分数微分特征吗？</li><li id="df52" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated">你想要哪些技术指标？</li><li id="523a" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated">哪些数据转换做得好会增加混洗时的错误？</li><li id="9b21" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated">您的网络规模应该是多少？</li><li id="a97b" class="kq kr ie jd b je kz ji la jm lb jq lc ju ld jy le kw kx ky dt translated">你希望DRL特工的神经网络有哪几层？</li></ul><p id="5bb4" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">结果</strong></p><p id="a6e0" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在我的新文章中，我们展示了一些结果</p><div class="hs ht fm fo hu ka"><a rel="noopener follow" target="_blank" href="/@CoderBurnt/best-technical-indicators-for-bitcoin-fromta-lib-fa5518560e"><div class="kb ab ej"><div class="kc ab kd cl cj ke"><h2 class="bd if fv z el kf eo ep kg er et id dt translated">来自TA-lib的比特币最佳技术指标</h2><div class="kh l"><h3 class="bd b fv z el kf eo ep kg er et ek translated">本文由开源项目AI4Finance的核心团队成员Berend Gort &amp; Bruce Yang撰写。这个…</h3></div><div class="ki l"><p class="bd b gc z el kf eo ep kg er et ek translated">medium.com</p></div></div><div class="kj l"><div class="kp l kl km kn kj ko ia ka"/></div></div></a></div></div><div class="ab cl lg lh hb li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hm hn ho hp hq"><p id="7c0e" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="ly">感谢您了解加密功能对DRL的重要性！</em></p><p id="f286" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="ly"> ~贝伦德&amp;布鲁斯</em></p></div><div class="ab cl lg lh hb li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hm hn ho hp hq"><p id="3a2f" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd if">参考文献</strong></p><p id="1137" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">0:洛佩兹·德·普拉多，男(2018)。金融机器学习进展。约翰·威利的儿子们。</p><p id="27cf" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><a class="ae jz" href="https://github.com/AI4Finance-Foundation" rel="noopener ugc nofollow" target="_blank">1:ai4金融基金会</a></p><p id="4344" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><a class="ae jz" href="https://www.youtube.com/watch?v=U2CxilKFue4" rel="noopener ugc nofollow" target="_blank"> 2:采用三重屏障标签的最优交易规则检测</a></p><p id="521d" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><a class="ae jz" href="https://towardsdatascience.com/the-triple-barrier-method-251268419dcd" rel="noopener" target="_blank"> 3:数据标注，三重关口法</a></p><p id="2b45" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><a class="ae jz" href="https://towardsdatascience.com/financial-machine-learning-part-1-labels-7eeed050f32e#:~:text=Adding%20Path%20Dependency%3A%20Triple%2DBarrier,%3A%20the%20triple%2Dbarrier%20method." rel="noopener" target="_blank"> 4:金融机器学习第1部分:标签</a></p><p id="1bcf" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><a class="ae jz" href="https://www.youtube.com/watch?v=WbgglcXfEzA" rel="noopener ugc nofollow" target="_blank"> 5:元标记:解决非平稳性和位置大小</a></p><p id="b701" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><a class="ae jz" href="https://github.com/JackBrady/Financial-Machine-Learning/blob/master/USDJPY_Notebook.ipynb" rel="noopener ugc nofollow" target="_blank"> 6:金融机器学习的进展</a></p></div></div>    
</body>
</html>