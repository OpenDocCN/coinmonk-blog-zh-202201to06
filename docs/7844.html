<html>
<head>
<title>Learn about the essential concepts of a Smart Contract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解智能合同的基本概念</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-about-the-essential-concepts-of-a-smart-contract-938717bd18ba?source=collection_archive---------20-----------------------#2022-06-01">https://medium.com/coinmonks/learn-about-the-essential-concepts-of-a-smart-contract-938717bd18ba?source=collection_archive---------20-----------------------#2022-06-01</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="ea3a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在本文中，我将带您浏览一个<strong class="is hu"><em class="jo"/></strong>智能合约的所有基本概念，这将帮助您构建自己的智能合约，并对它们的工作方式有一个概述。</p><p id="c0f1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="jo">我假设你有一些用另一种语言编程的经验(例如Javascript)。</em></p><h1 id="b187" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">目录</h1><ul class=""><li id="4c6f" class="kn ko ht is b it kp ix kq jb kr jf ks jj kt jn ku kv kw kx dt translated">基础</li><li id="4859" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">最佳化</li><li id="8760" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">时间单位</li><li id="d0a0" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">功能修饰符</li><li id="cfdb" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">使用“查看”功能节省汽油</li><li id="cb31" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">复习第一部分</li><li id="4e07" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">应付款修改量</li><li id="dff9" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">随机数</li><li id="d2b5" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">以太坊上的代币</li><li id="3bf1" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">转移逻辑</li><li id="4cda" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">断言与要求</li></ul><h1 id="40cc" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">基础</h1><p id="56d4" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">从最基本的开始:</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="fe ff lg"><img src="../Images/611d0575a6bb3519a112b135a50171e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M_mX5h8V9FYjvRPw.png"/></div></div></figure><p id="3b22" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Solidity的代码封装在<strong class="is hu">契约</strong>中。A <code class="eh ls lt lu lv b">contract</code>是以太坊应用的基本构建模块:</p><p id="f45d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-所有的变量和函数都属于一个契约，这将是你所有项目的起点。</p><p id="1427" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-所有solidity源代码都应该以“版本杂注”开始，即声明该代码应该使用的Solidity编译器的版本。</p><blockquote class="lw lx ly"><p id="58dd" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated">pragma实度&gt; =0.5.0 &lt;0.6.0;</p><p id="d06b" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated">contract HelloWorld <strong class="is hu"> { </strong></p><p id="c63f" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated"><strong class="is hu"> } </strong></p></blockquote><p id="bdf6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">- <strong class="is hu">状态变量</strong>永久存储在合同存储器中。这意味着它们被写入以太坊区块链。把它们想象成写数据库。</p><blockquote class="lw lx ly"><p id="dcdf" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated">合同示例<strong class="is hu"> { </strong></p><p id="a0aa" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated"><em class="ht"> //这将永久保存在区块链中</em></p><p id="5e14" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated">uint myUnsignedInteger = 100</p><p id="f81e" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated"><strong class="is hu"> } </strong></p></blockquote><p id="58d8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-当你想要一个东西的集合时，可以用数组。Solidity中有两种类型的数组:固定数组和动态数组:</p><blockquote class="lw lx ly"><p id="e9c3" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated"><em class="ht"> //固定长度2个元素的数组:</em></p><p id="f884" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated">uint[2]fixed array；</p><p id="663d" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated"><em class="ht"> //另一个固定数组，可以包含5个字符串:</em></p><p id="bfaa" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated">string[5]字符串数组；</p><p id="6c46" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated"><em class="ht"> //动态数组——没有固定大小，可以不断增长:</em></p><p id="5e24" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated">uint[]dynamic array；</p></blockquote><p id="200b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-你可以声明一个数组为public，Solidity会自动为它创建一个getter方法。</p><blockquote class="lw lx ly"><p id="2e0e" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated">人<em class="ht"> [] </em>公众人物；</p></blockquote><ul class=""><li id="7578" class="kn ko ht is b it iu ix iy jb mc jf md jj me jn ku kv kw kx dt translated"><strong class="is hu">存储</strong> —变量是一个状态变量(存储在区块链上)</li><li id="154b" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated"><strong class="is hu">内存</strong> —变量在内存中，在函数被调用时存在</li><li id="3666" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated"><strong class="is hu"> calldata </strong> —包含函数参数的特殊数据位置，仅对外部函数可用</li></ul><p id="972a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-我们还提供了关于_name变量应该存储在哪里的指令-在<strong class="is hu">内存</strong>中。这是所有引用类型(如数组、结构、映射和字符串)所必需的。</p><p id="1170" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-如果一个函数不改变任何值，也不写任何东西。我们可以将它声明为<strong class="is hu">视图</strong></p><blockquote class="lw lx ly"><p id="442c" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated">函数sayHello()公共视图返回(字符串内存){ … }</p></blockquote><p id="45b1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">- Solidity还包含纯粹的<strong class="is hu">函数，这意味着你甚至不能访问应用程序中的任何数据。请考虑以下情况:</strong></p><blockquote class="lw lx ly"><p id="caf9" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated">function _multiply(uint a，uint b)私有纯收益(uint) {</p><p id="58b9" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated">返回a * b；</p><p id="0564" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt">}</p></blockquote><p id="68d3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">注意:可能很难记住何时将函数标记为纯/视图。幸运的是，Solidity编译器善于发出警告，让您知道何时应该使用这些修饰符之一。</p><p id="24e6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-以太坊内置了哈希函数<strong class="is hu"> <em class="jo"> keccak256 </em> </strong>，是SHA3的一个版本。哈希函数基本上将输入映射为随机的256位十六进制数。输入中的微小变化都会导致散列值的巨大变化。</p><blockquote class="lw lx ly"><p id="e88e" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated">ke ccak 256(ABI . encode packed(" aaaab "))；</p></blockquote><p id="cff5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">- <strong class="is hu">事件</strong>是你的合同向你的应用前端传达区块链上发生的事情的一种方式，它可以“监听”某些事件，并在事件发生时采取行动。</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="fe ff mf"><img src="../Images/1287089a55c0773f85ef56feb5e1f55e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H4OCbO_mmPtmO4kg"/></div></div></figure><p id="3aca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-在可靠性方面，有某些全局变量可供所有函数使用。其中之一是msg.sender，它指的是调用当前函数的人(或智能合约)的地址。</p><blockquote class="lw lx ly"><p id="5e6a" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated">注意:在Solidity中，函数执行总是需要从一个外部调用者开始。在有人调用它的某个函数之前，一个契约将一直坐在区块链上，什么也不做。所以总会有一个<strong class="is hu"> msg.sender. </strong></p></blockquote><p id="9673" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">- <strong class="is hu"> Internal </strong>与private相同，只是它也可以被从这个契约继承的契约访问。</p><p id="7648" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">- <strong class="is hu">外部</strong>类似于public，除了这些函数只能在契约之外调用</p><ul class=""><li id="4b7f" class="kn ko ht is b it iu ix iy jb mc jf md jj me jn ku kv kw kx dt translated">为了让我们的合同与不属于我们的区块链上的另一个合同进行对话，首先我们需要定义一个接口。</li></ul><p id="1b7c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-在Solidity中，你可以从一个函数中返回多个值。</p><p id="7a30" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">- <strong class="is hu"> uint </strong>是<strong class="is hu"> uint256 </strong>的别名</p><p id="34d6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-记住对于字符串，我们必须比较它们的<strong class="is hu"> keccak256 </strong>散列来检查相等性</p><p id="6d94" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-函数修饰符<strong class="is hu">看起来就像一个函数，但是使用了关键字修饰符而不是关键字函数。它不能像函数那样被直接调用——相反，我们可以在函数定义的末尾加上修饰符的名字来改变函数的行为。</strong></p><h1 id="0afa" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">最佳化</h1><p id="e9be" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">-如果在一个<strong class="is hu">结构</strong>中有多个<strong class="is hu">单元</strong>，尽可能使用一个更小的<strong class="is hu">单元</strong>将允许Solidity将这些变量打包在一起以占用更少的存储空间。</p><p id="a1e4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-您还需要将相同的数据类型聚集在一起(例如，在结构中把它们放在一起)，这样Solidity可以最小化所需的存储空间。例如，带有字段<strong class="is hu"> <em class="jo"> uint c的结构；uint 32 a；uint 32 b；</em> </strong>比字段为<strong class="is hu"> <em class="jo"> uint32 a的结构消耗的气体少；uint c；uint 32 b；</em> </strong>因为uint32字段是聚类在一起的。</p><h1 id="f04c" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">时间单位</h1><p id="fd42" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">坚实度还包含时间单位<strong class="is hu"> <em class="jo">秒、分、小时、日、周和年</em> </strong>。这些将转换成该时间长度内的秒数的<strong class="is hu">单位</strong>。</p><p id="4730" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所以，1分钟是60，1小时是3600 (60秒x 60分钟)，1天是86400 (24小时x 60分钟x 60秒)等等。</p><h1 id="3619" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">功能修饰符</h1><figure class="lh li lj lk fq ll fe ff paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="fe ff mg"><img src="../Images/64c05e4f1cdfed5923693e12772da86a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qZlH3fTKVTReQ50Q"/></div></div></figure><p id="97be" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-您可以在这里看到olderThan修饰符像函数一样接受参数。并且driveCar函数将其参数传递给修饰符。</p><h1 id="f1b3" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">使用“查看”功能节省汽油</h1><p id="96e5" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">-当用户从外部调用视图函数时，它们不会消耗任何资源。</p><p id="6261" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-这是因为视图函数实际上不会更改区块链上的任何内容，它们只会读取数据。因此，用view标记一个函数告诉web3.js，它只需要查询您的本地以太坊节点来运行该函数，而实际上它不必在区块链上创建一个事务(这需要在每个节点上运行，并且很费油)。</p><blockquote class="lw lx ly"><p id="7c96" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated">注意:如果一个视图函数是从同一个契约中另一个不是视图函数的函数内部调用的，它仍然会消耗gas。这是因为另一个函数在以太坊上创建了一个事务，仍然需要从每个节点进行验证。所以视图函数只有在被外部调用时才是自由的。</p><p id="cc7c" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated">注意:创建内存数组时必须使用长度参数(在本例中为3)。它们目前不能像存储数组那样使用array.push()调整大小，尽管在Solidity的未来版本中可能会有所改变。</p></blockquote><h1 id="0159" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">回顾第一部分:</h1><p id="de28" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">1)我们有可见性修饰符来控制何时何地可以调用函数:<strong class="is hu"> private </strong>意味着它只能从契约中的其他函数调用；<strong class="is hu">内部</strong>类似于<strong class="is hu">私有</strong>，但是也可以被从这个继承的契约调用；<strong class="is hu">外部</strong>只能在合同外调用；最后<strong class="is hu"> public </strong>可以在任何地方调用，包括内部和外部。</p><p id="a79a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">2)我们还有状态修饰符，它告诉我们函数如何与区块链交互:</p><ul class=""><li id="3df6" class="kn ko ht is b it iu ix iy jb mc jf md jj me jn ku kv kw kx dt translated"><strong class="is hu">视图</strong>告诉我们，通过运行该功能，不会保存/更改任何数据。</li><li id="0d80" class="kn ko ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated"><strong class="is hu">纯粹的</strong>告诉我们，这个函数不仅不会将任何数据保存到区块链，而且也不会从区块链读取任何数据。</li></ul><p id="97b5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果从契约外部调用，这两个函数都不会消耗任何资源(但是如果由另一个函数内部调用，它们会消耗资源)。</p><p id="6ff7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">3)然后我们有自定义修饰符:<strong class="is hu"> onlyOwner </strong>和<strong class="is hu"> aboveLevel </strong>，例如。对于这些，我们可以定义自定义逻辑来确定它们如何影响功能。</p><blockquote class="lw lx ly"><p id="b761" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated">function test()仅外部视图owner another modifier {<em class="ht">/*…*/</em>}</p></blockquote><h1 id="3719" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">应付款修改量</h1><p id="ba54" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">- <strong class="is hu"> Payable </strong>函数是Solidity和Ethereum如此酷的部分原因——它们是一种可以接收以太的特殊类型的函数。</p><blockquote class="lw lx ly"><p id="fa34" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated">注意:如果一个函数没有被标记为payable，并且你试图像上面那样发送以太给它，这个函数将拒绝你的交易。</p></blockquote><p id="9bf2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-请务必注意，除非地址类型为<strong class="is hu">应付地址</strong>，否则您无法将乙醚转移至该地址。</p><p id="bc88" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">——<strong class="is hu">地址(本)。balance </strong>将返回存储在合同中的总余额。</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="fe ff mh"><img src="../Images/608de07d0e6a5190ddc1245b4bfec260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J-FNdRWUvYTAIYDT"/></div></div></figure><h1 id="20f7" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">随机数</h1><p id="ffaf" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">-我们在可靠性方面最好的随机性来源是<strong class="is hu"> <em class="jo"> keccak256 </em> </strong>哈希函数。</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="fe ff mi"><img src="../Images/7e4bcd94b38bd34915e78005e7a69b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OIUHXsJuso6O9Vtr"/></div></div></figure><h2 id="e43a" class="mj jq ht bd jr mk ml mm jv mn mo mp jz jb mq mr kd jf ms mt kh jj mu mv kl mw dt translated">解释:</h2><p id="3578" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">这样做的目的是获取现在为的<strong class="is hu">时间戳、<strong class="is hu"> msg.sender、</strong>和一个递增的<strong class="is hu"> nonce </strong>(一个只使用过一次的数字，因此我们不会使用相同的输入参数运行相同的哈希函数两次)。</strong></p><p id="2704" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后它会“打包”输入，并使用<strong class="is hu"> keccak </strong>将它们转换成随机散列。接下来，它将把散列转换成一个<strong class="is hu"> uint </strong>，然后使用<strong class="is hu"> % 100 </strong>只取最后2位。这将给我们一个0到99之间的完全随机的数。</p><h1 id="f3e8" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">以太坊上的代币</h1><p id="41e1" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">以太坊上的<strong class="is hu">令牌</strong>基本上只是一个智能合约，它遵循一些通用规则，即它实现了所有其他令牌合约共享的一组标准功能，例如:</p><p id="adf4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="jo"> transferFrom(地址_发件人，地址_收件人，uint256 _令牌Id)和balanceOf(地址_所有者)</em> </strong>。</p><p id="367f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-基本上，令牌只是一个记录谁拥有多少令牌的合同，以及一些功能，以便这些用户可以将其令牌转移到其他地址。</p><p id="5f73" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">- <strong class="is hu"> ERC721 </strong>令牌不可互换，因为每个令牌都被认为是唯一的，并且不可分割。你只能整单位交易，每一个都有唯一的ID。因此，这些是一个完美的适合使我们的僵尸交易。</p><blockquote class="lw lx ly"><p id="bf4b" class="iq ir jo is b it iu iv iw ix iy iz ja lz jc jd je ma jg jh ji mb jk jl jm jn hm dt translated">注意:使用ERC721这样的标准有一个好处，那就是我们不需要在合同中实现拍卖或托管逻辑来决定玩家如何交易/出售我们的僵尸。如果我们符合规范，其他人可以为加密交易的ERC721资产建立一个交换平台，我们的ERC721僵尸可以在该平台上使用。因此，使用代币标准代替自己的交易逻辑有明显的好处。</p></blockquote><figure class="lh li lj lk fq ll fe ff paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="fe ff mx"><img src="../Images/73693dea72723076b95ad9a9f652a3eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lR5Bafx8oZrGZKbw"/></div></div></figure><h1 id="2a84" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">转移逻辑</h1><p id="c284" class="pw-post-body-paragraph iq ir ht is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hm dt translated">1-第一种方式是令牌的所有者调用<strong class="is hu"> transferFrom </strong>，其中他的<strong class="is hu">地址</strong>作为<strong class="is hu"> _from </strong>参数，他想要转移到的<strong class="is hu">地址</strong>作为<strong class="is hu"> _to </strong>参数，以及他想要转移的令牌的<strong class="is hu"> _tokenId </strong>。</p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="fe ff my"><img src="../Images/0c1a5b6823705007bc1e4d423cc6b7d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KKdwA-QR9e-F1erK"/></div></div></figure><p id="f29e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">2-第二种方式是令牌的所有者首先调用<strong class="is hu"> approve </strong>和<strong class="is hu"> _tokenId </strong>以及他想要转移到的地址。然后，合同存储谁被批准使用令牌，通常存储在一个<strong class="is hu">映射中(uint256 = &gt;地址)。</strong>然后，当拥有者或被批准的地址从调用<strong class="is hu">transfer时，契约检查<strong class="is hu"> msg.sender </strong>是否是拥有者或被拥有者批准接受令牌，如果是，它将令牌转移给他。</strong></p><figure class="lh li lj lk fq ll fe ff paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="fe ff my"><img src="../Images/21a45faae647ef35b92fc9f23998e8cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pviwxoION5Wricrv"/></div></div></figure><h1 id="362b" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">断言与要求</h1><ul class=""><li id="575c" class="kn ko ht is b it kp ix kq jb kr jf ks jj kt jn ku kv kw kx dt translated"><strong class="is hu">断言</strong>类似于<strong class="is hu">要求</strong>，如果为假，将抛出错误。<strong class="is hu">断言</strong>和<strong class="is hu">要求</strong>的区别在于<strong class="is hu">要求</strong>会在某个功能失效时退还用户剩余的汽油，而<strong class="is hu">断言</strong>不会。所以大多数时候你想在你的代码中使用<strong class="is hu">要求</strong>；<strong class="is hu">断言</strong>通常在代码出现严重错误时使用(比如<strong class="is hu"> uint </strong>溢出)。</li></ul><p id="017f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">祝贺您，您现在已经对所有事情的工作原理有了一个概念，所以在下一篇文章(下面的链接)中，我们将看到您如何使用<strong class="is hu"> web3.js </strong>从前端应用程序与智能合同进行交互。</p><div class="mz na fm fo nb nc"><a rel="noopener follow" target="_blank" href="/@anasselabbadi.pro/how-to-interact-with-the-smart-contract-using-web3-js-3c10623385d7"><div class="nd ab ej"><div class="ne ab nf cl cj ng"><h2 class="bd hu fv z el nh eo ep ni er et hs dt translated">如何使用web3.js与智能合约交互</h2><div class="nj l"><h3 class="bd b fv z el nh eo ep ni er et ek translated">这篇文章是下面那篇文章的续篇:</h3></div><div class="nk l"><p class="bd b gc z el nh eo ep ni er et ek translated">medium.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq lq nc"/></div></div></a></div></div></div>    
</body>
</html>