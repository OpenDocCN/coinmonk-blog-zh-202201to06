<html>
<head>
<title>DATA STRUCTURE DESIGN in ETHEREUM and BITCOIN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊和比特币中的数据结构设计</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/data-structure-design-in-ethereum-and-bitcoin-83de4bd991ac?source=collection_archive---------5-----------------------#2022-06-02">https://medium.com/coinmonks/data-structure-design-in-ethereum-and-bitcoin-83de4bd991ac?source=collection_archive---------5-----------------------#2022-06-02</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="7b87" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我欣赏学习时的独立和批判精神，我喜欢问问题，比如为什么事情会这样。所以这篇文章将按照我自己的想法和思路来写，因为我希望它更像是一篇发人深省的文章，而不是一本告诉你事情如何运作的参考书。</p><p id="f72d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">什么是区块链？区块链V.S .链表</strong></p><p id="6800" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们从一个简单的问题开始:什么是区块链？</p><p id="a07a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">区块链是一种数据结构。为了理解区块链，你必须先了解链表。</p><p id="9a8b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在链表中，节点通过使用指针的链接来连接。</p><p id="a5d9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">节点中有两个元素:</p><p id="5d31" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">1.指向下一个节点的指针</p><p id="1612" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">2.存储数据的值部分</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff jo"><img src="../Images/579d16dc28548aad8fd195843b45d266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1EJM5rE4Ly5Kayg0cYwm2A.jpeg"/></div></div></figure><p id="0064" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在一个链表中，你可以通过改变节点的指针轻松地插入和删除新的节点，而不会影响其他节点。</p><p id="49fa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">区块链是使用哈希指针连接节点的链表。哈希指针是什么意思？</p><p id="dca6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">散列指针包括指向前一节点的指针和存储在前一节点中的数据的散列值。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff ka"><img src="../Images/4c6aefd6ad7bfa9d9dd30cd29a4fb661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ByoWBBFDqyRv5b5RN3SYUg.jpeg"/></div></div></figure><p id="2c35" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果内容发生变化，该哈希值也会发生变化。因此，这使得区块链不可改变篡改明显的日志。例如，您更改一个节点的值内容，它旁边的节点等等都将更改。所以你可以保留最近块的hash，证明所有的事务都是正确的。那就是光节点的来源。轻型节点只保留最近的块，并在需要时从完整节点查询附加数据。</p><p id="11b2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">特里是什么？</strong></p><p id="22b0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们知道积木是如何连接的了。让我们看看交易和账户数据是如何存储在块中的(trie是区块链的另一个重要的数据基础设施)。</p><p id="55af" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用trie(也称为树)存储事务。Trie来自“检索”,它是一种用于更好检索的数据结构。比特币使用merkle树组织交易，以太坊使用merkle Patricia树。</p><p id="d25a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">正常的trie具有以下特征:</p><ol class=""><li id="2461" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj dt translated">检索的效率取决于每个密钥的长度(以太坊地址的长度是160位，比特币地址是256位)。</li><li id="5690" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">在树中没有冲突的可能性(哈希冲突是可能的，但在trie中不会发生)。</li><li id="4f35" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">对于给定的输入，输出总是相同的(trie的结构总是相同的)。</li><li id="1669" class="kb kc ht is b it kk ix kl jb km jf kn jj ko jn kg kh ki kj dt translated">更新整个trie代价很大(最好小范围更新)。</li></ol><p id="21fd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">比特币中的Merkle树</strong></p><p id="2207" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在比特币中，交易存储在merkle树中。“Merkle”来源于hash函数，这个hash函数用于替换普通trie中的普通指针。</p><p id="174f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">交易存储在merkle树中。它们被逐层散列，最后构造一个根散列(如下所示)。</p><p id="a180" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果您想证明某个事务以前被正确执行过，您需要从完整节点(下面红色的节点)查询额外的哈希值，并通过merkle proof计算根哈希值。然后，您将这个计算出的根散列与您本地存储在您的光节点(SPV)中的根散列进行比较，如果根是相同的，那么您可以证明事务是正确的。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff kp"><img src="../Images/6787e2b97c634815c6d0a4f94a4bb2c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n3jtByJ4Ayc5DxpNQPBpVw.jpeg"/></div></div></figure><p id="7854" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这一程序也被称为会员证明，它意味着证明一项交易是包括在区块链。但当涉及到非会员证明时，情况可能会有所不同。如果你想证明一个事务在区块链中不存在，你必须把整个trie树上传到light节点来检查trie树的正确性，并且在那些块中查找每个事务，这是非常费力和低效的。(这个有解决方法:排序merkle树。但是比特币没有采取这种方式，因为非会员证明的场景很少。)</p><p id="c5a7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">以太坊中的Merkle Patricia树</strong></p><p id="0c05" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为什么以太坊使用merkle Patricia树而不是像比特币一样使用merkle树？</p><p id="cba0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">有很多考虑因素。</p><p id="ac28" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">与比特币中的UTXO模型不同，以太坊采用的是基于账户的模型。</p><p id="942a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在比特币中，交易由大小有限的区块管理。一个块可以容纳大约4000个事务。</p><p id="8675" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">基于帐户的模型意味着存在一个全局状态trie，其中包含每个帐户的信息(包括随机数、余额、代码哈希和存储trie)。</p><p id="aa9d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这种复杂的账目导致了一个问题。每次一个新的区块发布，整个trie都会改变，随着新帐户的创建，轮胎会不断增长。即使一个交易只涉及很少的账户，你也必须重新计算并重新发布整个trie，这是很昂贵的。</p><p id="295d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所以以太坊采取了这种不同的方式:Merkle Patricia Tree。</p><p id="d03b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">帕特丽夏的意思是<a class="ae kq" href="https://en.wikipedia.org/wiki/Memory_Optimization" rel="noopener ugc nofollow" target="_blank">空间优化</a>和压缩。</p><p id="646f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">一棵普通的树看起来像这样:</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff kr"><img src="../Images/e627d9dedd16116b33af891ff380d30b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7oquxRlVdrHcTk0HIhdUg.png"/></div></div></figure><p id="b40c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">帕特里夏树看起来像这样:</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff ks"><img src="../Images/d01b9bb37deeb2730a94a5810292ce42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uO1zxcAjZ_E9UuVDNZApUA.png"/></div></div></figure><p id="f81d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">帕特里夏树节省了大量资源。但是帕特丽夏·特里在什么情况下表现最好呢？答案是:键分布稀疏的地方。</p><p id="013b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">想象一个场景，当关键字总是有相同的前缀时，Patricia树看起来就像普通的树。这就是以太坊使用160位地址而不是较短地址来提高效率的原因。有2种⁶⁰类型的以太坊地址，2个⁶⁰与账户数量相比是一个非常大的数字，所以分布足够稀疏。</p><p id="8c04" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">此外，在完全分散的区块链系统中，地址由用户在本地生成，因此增加地址长度是防止分散系统中地址冲突的唯一方法。</p><p id="5ee4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">(我可能会在下一篇文章中从源代码的角度写一些东西……)</p><blockquote class="kt"><p id="18d4" class="ku kv ht bd kw kx ky kz la lb lc jn ek translated">加入Coinmonks <a class="ae kq" href="https://t.me/joinchat/Trz8jaxd6xEsBI4p" rel="noopener ugc nofollow" target="_blank"> Telegram group </a>并了解加密交易和投资</p></blockquote></div></div>    
</body>
</html>