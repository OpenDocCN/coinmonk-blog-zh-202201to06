<html>
<head>
<title>Building an application specific blockchain using Cosmos SDK Part-4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Cosmos SDK第4部分构建特定于应用程序的区块链</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/building-an-application-specific-blockchain-using-cosmos-sdk-part-4-bf0c609ecacc?source=collection_archive---------6-----------------------#2022-04-07">https://medium.com/coinmonks/building-an-application-specific-blockchain-using-cosmos-sdk-part-4-bf0c609ecacc?source=collection_archive---------6-----------------------#2022-04-07</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/67d22c1322a6792f7b1032f45d93352e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wHtJ8Mel44Q122KVrRucEg.jpeg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Photo by <a class="ae jf" href="https://unsplash.com/@launchpresso?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Launchpresso</a> on <a class="ae jf" href="https://unsplash.com/s/photos/cryptocurrency?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="17cc" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在第3部分中，我们完成了处理合同和交易的查询处理程序和商店管理员。现在让我们来处理<code class="eh ke kf kg kh b">Msg server</code>。</p><p id="de3c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">运行命令创建<code class="eh ke kf kg kh b">createDeal</code>消息-</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="4acd" class="kq kr ht kh b fv ks kt l ku kv">starport scaffold message createDeal vendor commission --module deal --response idValue</span></pre><p id="2ef5" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">该命令执行以下操作-</p><ul class=""><li id="9020" class="kw kx ht ji b jj jk jn jo jr ky jv kz jz la kd lb lc ld le dt translated">创建消息定义(<code class="eh ke kf kg kh b">tx.proto</code>)。</li></ul><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="eac2" class="kq kr ht kh b fv ks kt l ku kv">message MsgCreateDeal {<br/>string creator = 1; // added by starport, this is the msg creator<br/>string vendor = 2; // will store vendor address<br/>uint64 commission = 3; //vendor commission for each order completion<br/>}</span><span id="5d55" class="kq kr ht kh b fv lf kt l ku kv">message MsgCreateDealResponse {<br/>string idValue = 1;<br/>}</span></pre><ul class=""><li id="e9f3" class="kw kx ht ji b jj jk jn jo jr ky jv kz jz la kd lb lc ld le dt translated">实现满足<code class="eh ke kf kg kh b">sdk.Msg</code>接口(message_create_contract.go)的方法。</li><li id="0c0c" class="kw kx ht ji b jj lg jn lh jr li jv lj jz lk kd lb lc ld le dt translated">创建交易消息处理程序(<code class="eh ke kf kg kh b">msg_server_create_deal.go</code>)。</li><li id="2a61" class="kw kx ht ji b jj lg jn lh jr li jv lj jz lk kd lb lc ld le dt translated">生成cli命令来调用处理程序(<code class="eh ke kf kg kh b">tx_create_deal.go</code>)。</li><li id="00b8" class="kw kx ht ji b jj lg jn lh jr li jv lj jz lk kd lb lc ld le dt translated">注册处理程序(<code class="eh ke kf kg kh b">handler.go</code>)。</li></ul><p id="1c23" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们修改消息处理程序<code class="eh ke kf kg kh b">msg_server_create_deal.go</code>，如下所示</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="fb83" class="kq kr ht kh b fv ks kt l ku kv">// msg_server_create_deal.go</span><span id="a988" class="kq kr ht kh b fv lf kt l ku kv">package keeper</span><span id="cdd8" class="kq kr ht kh b fv lf kt l ku kv">import (<br/> "context"<br/> "strconv"<br/> "github.com/Harry-027/deal/x/deal/types"<br/> sdk "github.com/cosmos/cosmos-sdk/types"<br/>)</span><span id="d1b4" class="kq kr ht kh b fv lf kt l ku kv">func (k msgServer) CreateDeal(goCtx context.Context, msg *types.MsgCreateDeal) (*types.MsgCreateDealResponse, error) {</span><span id="1f74" class="kq kr ht kh b fv lf kt l ku kv"> ctx := sdk.UnwrapSDKContext(goCtx)</span><span id="a39f" class="kq kr ht kh b fv lf kt l ku kv"> dealCounter, found := k.Keeper.GetDealCounter(ctx)<br/> if !found {<br/>  panic("DealCounter not found")<br/> }</span><span id="0d3d" class="kq kr ht kh b fv lf kt l ku kv"> dealId := strconv.FormatUint(dealCounter.IdValue, 10)</span><span id="6201" class="kq kr ht kh b fv lf kt l ku kv"> newDeal := types.NewDeal{<br/>  DealId:     dealId,<br/>  Owner:      msg.Creator,<br/>  Vendor:     msg.Vendor,<br/>  Commission: msg.Commission,<br/> }</span><span id="d7ed" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// validate before processing the message<br/></em>err := newDeal.Validate()<br/>if err != nil {<br/> return nil, err<br/>}</span><span id="ff85" class="kq kr ht kh b fv lf kt l ku kv">k.Keeper.SetNewDeal(ctx, newDeal)<br/>dealCounter.IdValue++<br/>k.Keeper.SetDealCounter(ctx, dealCounter)</span><span id="8223" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// Set the new contract counter for a newly created deal<br/></em>contractCounter := types.ContractCounter{<br/> DealId:  dealId,<br/> IdValue: 0,<br/>}</span><span id="c3df" class="kq kr ht kh b fv lf kt l ku kv">k.Keeper.SetContractCounter(ctx, contractCounter)</span><span id="94bf" class="kq kr ht kh b fv lf kt l ku kv">ctx.GasMeter().ConsumeGas(types.CREATE_GAS, "Create Deal")</span><span id="3597" class="kq kr ht kh b fv lf kt l ku kv">ctx.EventManager().EmitEvent(<br/>sdk.NewEvent(sdk.EventTypeMessage,<br/>sdk.NewAttribute(sdk.AttributeKeyModule, types.ModuleName),<br/>sdk.NewAttribute(types.IDVALUE, dealId),<br/>sdk.NewAttribute(types.OWNER, newDeal.Owner),<br/>sdk.NewAttribute(types.VENDOR, newDeal.Vendor),<br/>),<br/>)</span><span id="f227" class="kq kr ht kh b fv lf kt l ku kv">return &amp;types.MsgCreateDealResponse{<br/>IdValue: dealId,<br/>}, nil<br/>}</span></pre><p id="6ac4" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">注意，在执行的最后，我们消耗了一定量的气体。这是为了激励验证者和阻止垃圾短信。我们在常量(<code class="eh ke kf kg kh b">contract_utils.go</code>)下定义了气体单位。我们还发出一个自定义事件来通知客户端关于成功发送的详细信息。</p><p id="a6ca" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">注意，在逻辑处理部分，我们首先获取<code class="eh ke kf kg kh b">dealCounter</code>以得到<code class="eh ke kf kg kh b">dealId</code>，然后将<code class="eh ke kf kg kh b">deal</code>保存在存储中。此外，在保存交易之前，我们将借助<code class="eh ke kf kg kh b">Validate()</code>方法验证消息，该方法将验证<code class="eh ke kf kg kh b">vendor</code>地址和<code class="eh ke kf kg kh b">commission</code></p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="e405" class="kq kr ht kh b fv ks kt l ku kv">// deal_utils.go<br/>package types</span><span id="d3f0" class="kq kr ht kh b fv lf kt l ku kv">import (<br/>sdk "github.com/cosmos/cosmos-sdk/types"<br/>sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"<br/>)</span><span id="e17b" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// utility funcs<br/></em>func (newDeal *NewDeal) GetOwnerAddress() (owner sdk.AccAddress, err error) {<br/>owner, errInvalidOwner := sdk.AccAddressFromBech32(newDeal.Owner)<br/>return owner, sdkerrors.Wrapf(errInvalidOwner, ErrInvalidOwner.Error(), newDeal.Owner)<br/>}</span><span id="1ffa" class="kq kr ht kh b fv lf kt l ku kv">func (newDeal *NewDeal) GetVendorAddress() (vendor sdk.AccAddress, err error) {<br/>vendor, errInvalidVendor := sdk.AccAddressFromBech32(newDeal.Vendor)<br/>return vendor, sdkerrors.Wrapf(errInvalidVendor,   ErrInvalidVendor.Error(), newDeal.Vendor)<br/>}</span><span id="e477" class="kq kr ht kh b fv lf kt l ku kv">func (newDeal *NewDeal) ValidateCommission() (err error) {<br/>  if 1 &lt;= newDeal.Commission &amp;&amp; 100 &gt;= newDeal.Commission {<br/>    return nil<br/>  }<br/>  return ErrInvalidCommission<br/>}</span><span id="8990" class="kq kr ht kh b fv lf kt l ku kv">func (newDeal *NewDeal) Validate() (err error) {<br/>_, err = newDeal.GetOwnerAddress()<br/>if err != nil {<br/>  return err<br/>}</span><span id="6cc0" class="kq kr ht kh b fv lf kt l ku kv">_, err = newDeal.GetVendorAddress()<br/>if err != nil {<br/>  return err<br/>}</span><span id="2cca" class="kq kr ht kh b fv lf kt l ku kv">err = newDeal.ValidateCommission()<br/>  return err<br/>}</span></pre><p id="8163" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们为cli命令<code class="eh ke kf kg kh b">tx_create_deal.go</code>编写代码</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="6c8e" class="kq kr ht kh b fv ks kt l ku kv">package cli</span><span id="dbca" class="kq kr ht kh b fv lf kt l ku kv">import (<br/><br/> "github.com/Harry-027/deal/x/deal/types"<br/> "github.com/cosmos/cosmos-sdk/client"<br/> "github.com/cosmos/cosmos-sdk/client/flags"<br/> "github.com/cosmos/cosmos-sdk/client/tx"<br/> "github.com/spf13/cast"<br/> "github.com/spf13/cobra"<br/>)</span><span id="c5fe" class="kq kr ht kh b fv lf kt l ku kv">func CmdCreateDeal() *cobra.Command {<br/> cmd := &amp;cobra.Command{<br/> Use:   "create-deal [vendor] [commission]",<br/> Short: "Broadcast message createDeal",<br/> Args:  cobra.ExactArgs(2),<br/> RunE: func(cmd *cobra.Command, args []string) (err error) {</span><span id="38ce" class="kq kr ht kh b fv lf kt l ku kv">  argVendor := args[0]<br/>  argCommission, err := cast.ToUint64E(args[1])<br/>  if err != nil {<br/>   return err<br/>  }</span><span id="aa2c" class="kq kr ht kh b fv lf kt l ku kv">  clientCtx, err := client.GetClientTxContext(cmd)<br/>  if err != nil {<br/>   return err<br/>  }</span><span id="9653" class="kq kr ht kh b fv lf kt l ku kv">  msg := types.NewMsgCreateDeal(<br/>  clientCtx.GetFromAddress().String(),<br/>   argVendor,<br/>   argCommission,<br/> )</span><span id="bf36" class="kq kr ht kh b fv lf kt l ku kv"> if err := msg.ValidateBasic(); err != nil {<br/>  return err<br/> }</span><span id="fad5" class="kq kr ht kh b fv lf kt l ku kv">  return tx.GenerateOrBroadcastTxCLI(clientCtx, cmd.Flags(), msg)<br/> },<br/>}</span><span id="0a8e" class="kq kr ht kh b fv lf kt l ku kv"> flags.AddTxFlagsToCmd(cmd)<br/> return cmd<br/>}</span></pre><p id="b82e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">注意方法<code class="eh ke kf kg kh b">msg.ValidateBasic()</code>(如上所用)也被cosmos sdk在<code class="eh ke kf kg kh b">checkTx</code>方法中调用来验证Tx，这样tendermint可以避免mempool中的无效Tx。</p><p id="df4e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在，让我们为createContract命令搭建脚手架</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="bf0b" class="kq kr ht kh b fv ks kt l ku kv">starport scaffold message createContract dealId consumer desc ownerETA expiry fees --module deal --response idValue</span></pre><p id="9099" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们的原型定义看起来像-</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="5903" class="kq kr ht kh b fv ks kt l ku kv">message MsgCreateContract {<br/>string creator = 1;<br/>string dealId = 2;<br/>string consumer = 3;<br/>string desc = 4;<br/>string ownerETA = 5;<br/>string expiry = 6;<br/>uint64 fees = 7;<br/>}</span><span id="eed2" class="kq kr ht kh b fv lf kt l ku kv">message MsgCreateContractResponse {<br/>string idValue = 1;<br/>string contractStatus = 2;<br/>}</span></pre><p id="b187" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh ke kf kg kh b">contractStatus</code>字段是后来手动添加的。添加字段<code class="eh ke kf kg kh b">contractStatus</code>字段后，运行命令重新生成原型文件-</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="4d44" class="kq kr ht kh b fv ks kt l ku kv">starport generate proto-go</span></pre><p id="17c1" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">修改处理器如下- ( <code class="eh ke kf kg kh b">msg_server_create_contract.go</code>)</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="1638" class="kq kr ht kh b fv ks kt l ku kv">package keeper<br/>import (<br/>"context"<br/>"strconv"<br/>"time"<br/>"github.com/Harry-027/deal/x/deal/types"<br/> sdk "github.com/cosmos/cosmos-sdk/types"<br/>)</span><span id="3393" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// CreateContract is the tx handler to handle create contract messages<br/></em>func (k msgServer) CreateContract(goCtx context.Context, msg *types.MsgCreateContract) (*types.MsgCreateContractResponse, error) {<br/> ctx := sdk.UnwrapSDKContext(goCtx)<br/> deal, found := k.Keeper.GetNewDeal(ctx, msg.DealId)</span><span id="308d" class="kq kr ht kh b fv lf kt l ku kv"> if !found {<br/>  return nil, types.ErrDealNotFound<br/> }</span><span id="5f0e" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll"> // validate if the tx came from owner</em></span><span id="357a" class="kq kr ht kh b fv lf kt l ku kv"> if msg.Creator != deal.Owner {<br/>  return nil, types.ErrInvalidOwner<br/> }</span><span id="d985" class="kq kr ht kh b fv lf kt l ku kv"> contractCounter, found := k.Keeper.GetContractCounter(ctx,  msg.DealId)</span><span id="edf7" class="kq kr ht kh b fv lf kt l ku kv">if !found {<br/>  return nil, types.ErrDealNotFound<br/>}</span><span id="b8c4" class="kq kr ht kh b fv lf kt l ku kv">contractCounter.IdValue++<br/>contractId := strconv.FormatUint(contractCounter.IdValue, 10)<br/>etaInMins, err := strconv.Atoi(msg.OwnerETA)</span><span id="a403" class="kq kr ht kh b fv lf kt l ku kv">if err != nil {<br/> return nil, types.ErrInvalidTime<br/>}</span><span id="6094" class="kq kr ht kh b fv lf kt l ku kv">expiryInMins, err := strconv.Atoi(msg.Expiry)<br/>if err != nil {<br/> return nil, types.ErrInvalidTime<br/>}</span><span id="b6d3" class="kq kr ht kh b fv lf kt l ku kv">expiry := ctx.BlockTime().Add(time.Duration(expiryInMins) * time.Minute)</span><span id="d938" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// create a new contract under the given dealId</em></span><span id="9719" class="kq kr ht kh b fv lf kt l ku kv">newContract := types.NewContract{<br/>DealId:     msg.DealId,<br/>ContractId: contractId,<br/>Consumer:   msg.Consumer,<br/>Desc:       msg.Desc,<br/>OwnerETA:   uint32(etaInMins),<br/>Expiry:     expiry.UTC().Format(types.TIME_FORMAT),<br/>Fees:       msg.Fees,<br/>StartTime:  ctx.BlockTime().UTC().Format(types.TIME_FORMAT),<br/>Status:     types.INITIATED,<br/>}</span><span id="ada0" class="kq kr ht kh b fv lf kt l ku kv">k.Keeper.SetNewContract(ctx, newContract)<br/>k.Keeper.SetContractCounter(ctx, contractCounter)<br/>ctx.GasMeter().ConsumeGas(types.CREATE_GAS, "Create Contract")</span><span id="26fb" class="kq kr ht kh b fv lf kt l ku kv">ctx.EventManager().EmitEvent(<br/>sdk.NewEvent(sdk.EventTypeMessage,<br/>sdk.NewAttribute(sdk.AttributeKeyModule, types.ModuleName),<br/>sdk.NewAttribute(sdk.AttributeKeyAction, types.INITIATED),<br/>sdk.NewAttribute(types.IDVALUE, newContract.ContractId),<br/>sdk.NewAttribute(types.START_TIME, newContract.StartTime),<br/>),<br/>)</span><span id="2067" class="kq kr ht kh b fv lf kt l ku kv">return &amp;types.MsgCreateContractResponse{IdValue: contractId, ContractStatus: types.INITIATED}, nil</span><span id="cfdd" class="kq kr ht kh b fv lf kt l ku kv">}</span></pre><p id="1d83" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们正根据关键字<code class="eh ke kf kg kh b">NewContract/value/{contractId}/</code>将合同存储在前缀关键字为<code class="eh ke kf kg kh b">NewContract/value/{dealId}/</code>的商店下。此外，我们确认只有当tx来自交易所有人时，才能处理<code class="eh ke kf kg kh b">createContract</code>tx。</p><p id="9536" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">一旦交易所有人创建了合同，供应商需要提交，消费者需要在到期时间之前批准，否则合同将被视为到期。为此，我们将生成另外两条消息- <code class="eh ke kf kg kh b">commitContract</code>和<code class="eh ke kf kg kh b">approveContract</code>。tx <code class="eh ke kf kg kh b">commitContract</code>将以分钟为单位输入发货时间(<code class="eh ke kf kg kh b">vendorETA</code>)，这是卖方完成订单的承诺。搭建这两条消息留给您作为练习:)</p><p id="1736" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们来看看<code class="eh ke kf kg kh b">commitContract</code>的处理程序——</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="c9d7" class="kq kr ht kh b fv ks kt l ku kv">// msg_server_commit_contract.go<br/>package keeper</span><span id="cd77" class="kq kr ht kh b fv lf kt l ku kv">import (<br/>"context"<br/>"strconv"<br/>"time"<br/>"github.com/Harry-027/deal/x/deal/types"<br/>sdk "github.com/cosmos/cosmos-sdk/types"<br/>)</span><span id="f2a0" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// CommitContract is the tx handler to handle commit contract messages</em></span><span id="f6ac" class="kq kr ht kh b fv lf kt l ku kv">func (k msgServer) CommitContract(goCtx context.Context, msg *types.MsgCommitContract) (*types.MsgCommitContractResponse, error) {<br/>  ctx := sdk.UnwrapSDKContext(goCtx)<br/>  deal, found := k.Keeper.GetNewDeal(ctx, msg.DealId)<br/>  if !found {<br/>     return nil, types.ErrDealNotFound<br/>  }</span><span id="10c6" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// validate is the transaction is coming from vendor<br/></em>if msg.Creator != deal.Vendor {<br/>   return nil, types.ErrInvalidVendor<br/>}</span><span id="497b" class="kq kr ht kh b fv lf kt l ku kv">contract, found := k.Keeper.GetNewContract(ctx, msg.DealId, msg.ContractId)</span><span id="66ae" class="kq kr ht kh b fv lf kt l ku kv">if !found {<br/> return nil, types.ErrContractNotFound<br/>}<br/>expiry, err := time.Parse(types.TIME_FORMAT, contract.Expiry)</span><span id="d879" class="kq kr ht kh b fv lf kt l ku kv">if err != nil {<br/> panic("invalid expiry time")<br/>}</span><span id="67d4" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// don't process the expired contracts<br/></em>if ctx.BlockTime().After(expiry) {<br/> return nil, types.ErrContractExpired<br/>}</span><span id="fc5e" class="kq kr ht kh b fv lf kt l ku kv">etaInMins, err := strconv.Atoi(msg.VendorETA)</span><span id="6111" class="kq kr ht kh b fv lf kt l ku kv">if err != nil {<br/> return nil, types.ErrInvalidTime<br/>}</span><span id="2198" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// validate the vendor ETA<br/></em>if (contract.OwnerETA / 2) &lt; uint32(etaInMins) {<br/> return nil, types.ErrVendorETA<br/>}</span><span id="cebc" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// process and emit the custom event<br/></em>contract.Status = types.COMMITTED<br/>contract.VendorETA = uint32(etaInMins)<br/>k.Keeper.SetNewContract(ctx, contract)</span><span id="3081" class="kq kr ht kh b fv lf kt l ku kv">ctx.GasMeter().ConsumeGas(types.PROCESS_GAS, "Commit Contract")</span><span id="b30d" class="kq kr ht kh b fv lf kt l ku kv">ctx.EventManager().EmitEvent(<br/> sdk.NewEvent(sdk.EventTypeMessage,<br/> sdk.NewAttribute(sdk.AttributeKeyModule, types.ModuleName),<br/> sdk.NewAttribute(sdk.AttributeKeyAction, types.COMMITTED),<br/> sdk.NewAttribute(types.IDVALUE, contract.ContractId),<br/> sdk.NewAttribute(types.VENDOR_ETA,  strconv.FormatUint(uint64(contract.VendorETA), 10)),<br/>sdk.NewAttribute(types.OWNER_ETA,  strconv.FormatUint(uint64(contract.OwnerETA), 10)),<br/> ),<br/>)</span><span id="2cd5" class="kq kr ht kh b fv lf kt l ku kv">return &amp;types.MsgCommitContractResponse{IdValue: contract.ContractId, ContractStatus: contract.Status}, nil<br/>}</span></pre><p id="1eee" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在<code class="eh ke kf kg kh b">commitContract</code>下，我们在将合同状态更改为已承诺之前验证以下内容-</p><ul class=""><li id="d4b7" class="kw kx ht ji b jj jk jn jo jr ky jv kz jz la kd lb lc ld le dt translated">如果交易来自供应商。</li><li id="14a2" class="kw kx ht ji b jj lg jn lh jr li jv lj jz lk kd lb lc ld le dt translated">如果合同还没到期。</li><li id="6d4a" class="kw kx ht ji b jj lg jn lh jr li jv lj jz lk kd lb lc ld le dt translated">如果vendorETA ≤ ownerETA /2。</li></ul><p id="4edc" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们来看看<code class="eh ke kf kg kh b">approveContract</code>处理器-</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="3769" class="kq kr ht kh b fv ks kt l ku kv">// msg_server_approve_contract.go</span><span id="78e5" class="kq kr ht kh b fv lf kt l ku kv">package keeper</span><span id="99a9" class="kq kr ht kh b fv lf kt l ku kv">import (<br/> "context"<br/> "time"<br/> "github.com/Harry-027/deal/x/deal/types"<br/> sdk "github.com/cosmos/cosmos-sdk/types"<br/> sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"<br/>)</span><span id="2222" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// ApproveContract is the tx handler for handling approve contract messages<br/></em>func (k msgServer) ApproveContract(goCtx context.Context, msg *types.MsgApproveContract) (*types.MsgApproveContractResponse, error) {</span><span id="cde8" class="kq kr ht kh b fv lf kt l ku kv">ctx := sdk.UnwrapSDKContext(goCtx)<br/>contract, found := k.Keeper.GetNewContract(ctx, msg.DealId,  msg.ContractId)</span><span id="5093" class="kq kr ht kh b fv lf kt l ku kv">if !found {<br/> return nil, types.ErrContractNotFound<br/>}</span><span id="bb91" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// handle validation before processing<br/></em>err := msg.DealHandlerValidation(goCtx, &amp;contract)<br/>if err != nil {<br/> return nil, err<br/>}</span><span id="2ec5" class="kq kr ht kh b fv lf kt l ku kv">expiryTime, err := time.Parse(types.TIME_FORMAT, contract.Expiry)<br/>if err != nil {<br/> return nil, err<br/>}</span><span id="7e05" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// don't process the expired contracts<br/></em>if ctx.BlockTime().After(expiryTime) {<br/> return nil, types.ErrContractExpired<br/>}</span><span id="29e4" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// store funds from user account to module escrow account and approve the contract</em></span><span id="0ca2" class="kq kr ht kh b fv lf kt l ku kv">consumerAddress, err := contract.GetConsumerAddress()<br/>if err != nil {<br/>panic("Invalid consumer address")<br/>}</span><span id="ccab" class="kq kr ht kh b fv lf kt l ku kv">err = k.bank.SendCoinsFromAccountToModule(ctx, consumerAddress, types.ModuleName, sdk.NewCoins(contract.GetCoin(contract.Fees)))</span><span id="31f7" class="kq kr ht kh b fv lf kt l ku kv">if err != nil {<br/> return nil, sdkerrors.Wrapf(err, types.ErrPaymentFailed.Error())<br/>}</span><span id="4211" class="kq kr ht kh b fv lf kt l ku kv">contract.Status = types.APPROVED<br/>k.Keeper.SetNewContract(ctx, contract)</span><span id="4a93" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// consume the gas to incentivize validators<br/></em>ctx.GasMeter().ConsumeGas(types.PROCESS_GAS, "Approve Contract")</span><span id="22c7" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// emit custom event that clients can subscribe to<br/></em>ctx.EventManager().EmitEvent(<br/>sdk.NewEvent(sdk.EventTypeMessage,<br/>sdk.NewAttribute(sdk.AttributeKeyModule, types.ModuleName),<br/>sdk.NewAttribute(sdk.AttributeKeyAction, types.APPROVED),<br/>sdk.NewAttribute(types.IDVALUE, contract.ContractId),<br/>),<br/>)</span><span id="3521" class="kq kr ht kh b fv lf kt l ku kv">return &amp;types.MsgApproveContractResponse{<br/>IdValue:        contract.ContractId,<br/>ContractStatus: contract.Status,<br/>}, nil<br/>}</span></pre><p id="4811" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">用户将启动<code class="eh ke kf kg kh b">approveContract</code> tx。该tx将执行以下步骤-</p><ul class=""><li id="2ae3" class="kw kx ht ji b jj jk jn jo jr ky jv kz jz la kd lb lc ld le dt translated">验证tx是否由消费者签名。</li><li id="bc2e" class="kw kx ht ji b jj lg jn lh jr li jv lj jz lk kd lb lc ld le dt translated">验证合同是否已提交。</li><li id="e6b1" class="kw kx ht ji b jj lg jn lh jr li jv lj jz lk kd lb lc ld le dt translated">验证合同是否尚未到期。</li><li id="a647" class="kw kx ht ji b jj lg jn lh jr li jv lj jz lk kd lb lc ld le dt translated">将资金从消费者账户转移到模块托管账户。</li></ul><p id="6455" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">注意处理程序中使用的<code class="eh ke kf kg kh b">msg.DealHandlerValidation</code>的定义如下-</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="c89f" class="kq kr ht kh b fv ks kt l ku kv">// message_approve_contract.go</span><span id="58f5" class="kq kr ht kh b fv lf kt l ku kv">func (msg *MsgApproveContract) DealHandlerValidation(goCtx context.Context, contract *NewContract) error {</span><span id="b2fa" class="kq kr ht kh b fv lf kt l ku kv">if msg.Creator != contract.Consumer {<br/> return ErrInvalidConsumer<br/>}</span><span id="611b" class="kq kr ht kh b fv lf kt l ku kv">if contract.Status != COMMITTED {<br/> return ErrNotCommitted<br/>}</span><span id="bf2e" class="kq kr ht kh b fv lf kt l ku kv">return nil<br/>}</span></pre><p id="3ba6" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们在这里使用银行保管员进行资金转移操作。为了访问银行保管员公开的任何功能，我们需要在我们的具体保管员类型中注入银行保管员接口-</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="71d1" class="kq kr ht kh b fv ks kt l ku kv">// keeper.go<br/><em class="ll">// concrete keeper type for deal module also includes bank &amp; account keeper interface for handling fund related transactions</em></span><span id="6891" class="kq kr ht kh b fv lf kt l ku kv">type (<br/>Keeper struct {<br/>auth       types.AccountKeeper<br/>bank       types.BankKeeper<br/>cdc        codec.BinaryCodec<br/>storeKey   sdk.StoreKey<br/>memKey     sdk.StoreKey<br/>paramstore paramtypes.Subspace<br/>})</span></pre><p id="07b3" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">因此，我们的<code class="eh ke kf kg kh b">keeper</code>构造函数将改变如下-</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="647e" class="kq kr ht kh b fv ks kt l ku kv">func NewKeeper(<br/>auth types.AccountKeeper,<br/>bank types.BankKeeper,<br/>cdc codec.BinaryCodec,<br/>storeKey,<br/>memKey sdk.StoreKey,<br/>ps paramtypes.Subspace,<br/>) *Keeper {<br/><em class="ll">// set KeyTable if it has not already been set<br/></em>if !ps.HasKeyTable() {<br/>ps = ps.WithKeyTable(types.ParamKeyTable())<br/>}</span><span id="5da2" class="kq kr ht kh b fv lf kt l ku kv">return &amp;Keeper{<br/> auth:       auth,<br/> bank:       bank,<br/> cdc:        cdc,<br/> storeKey:   storeKey,<br/> memKey:     memKey,<br/> paramstore: ps,<br/> }<br/>}</span></pre><p id="fd29" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们在<code class="eh ke kf kg kh b">app.go</code>的初始化阶段通过我们的keeper构造中的银行keeper接口</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="6c75" class="kq kr ht kh b fv ks kt l ku kv">// app.go</span><span id="63c7" class="kq kr ht kh b fv lf kt l ku kv">app.DealKeeper = *dealmodulekeeper.NewKeeper(<br/>app.AccountKeeper,<br/>app.BankKeeper,<br/>appCodec,<br/>keys[dealmoduletypes.StoreKey],<br/>keys[dealmoduletypes.MemStoreKey],<br/>app.GetSubspace(dealmoduletypes.ModuleName),<br/>)</span></pre><p id="248a" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">当我们传递非具体类型的银行保管员接口时，我们的保管员具体类型需要理解将使用银行保管员接口中的哪个方法。因此，在<code class="eh ke kf kg kh b">expected_keepers.go</code>下定义一个<code class="eh ke kf kg kh b">interface</code>用于我们要从银行保管员那里访问的方法-</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="67a3" class="kq kr ht kh b fv ks kt l ku kv"><em class="ll">// BankKeeper defines the expected interface needed to retrieve account balances.</em></span><span id="8707" class="kq kr ht kh b fv lf kt l ku kv">type BankKeeper interface {<br/> SpendableCoins(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins<br/> GetBalance(ctx sdk.Context, addr sdk.AccAddress, denom string)  sdk.Coin<br/> SendCoinsFromModuleToAccount(ctx sdk.Context, senderModule string,  recipientAddr sdk.AccAddress, amt sdk.Coins) error<br/> SendCoinsFromAccountToModule(ctx sdk.Context, senderAddr sdk.AccAddress, recipientModule string, amt sdk.Coins) error</span><span id="bfe9" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// Methods imported from bank should be defined here<br/></em>}</span><span id="09df" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// AccountKeeper defines the expected account keeper used for simulations (noalias)</em></span><span id="8fcc" class="kq kr ht kh b fv lf kt l ku kv">type AccountKeeper interface {<br/> GetAccount(ctx sdk.Context, addr sdk.AccAddress) types.AccountI<br/> GetModuleAddress(name string) sdk.AccAddress<br/><em class="ll">// Methods imported from account should be defined here<br/></em>}</span></pre><p id="a556" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">请注意，我们还将在<code class="eh ke kf kg kh b">orderDelivered</code>处理程序中使用记账员。因此，在我们的具体保管员类型中传递相同的，就像我们为银行保管员接口所做的一样。</p><p id="574a" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在合同被批准后，我们必须发出自定义事件，让FE客户端了解合同状态。这将通知卖方合同批准，以便卖方可以开始处理订单。一旦订单准备就绪，供应商将启动tx，将合同状态更改为<code class="eh ke kf kg kh b">INDELIVERY</code>。该tx还将根据初始发货承诺时间(<code class="eh ke kf kg kh b">vendorETA</code>)计算是否有任何发货延迟。让我们来看看汉德勒-</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="07cb" class="kq kr ht kh b fv ks kt l ku kv">//msg_server_ship_order.go</span><span id="c96c" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// ShipOrder is the tx handler for shipOrder messages from Vendor<br/></em>func (k msgServer) ShipOrder(goCtx context.Context, msg *types.MsgShipOrder) (*types.MsgShipOrderResponse, error) {</span><span id="2e88" class="kq kr ht kh b fv lf kt l ku kv">ctx := sdk.UnwrapSDKContext(goCtx)<br/>deal, found := k.Keeper.GetNewDeal(ctx, msg.DealId)<br/>if !found {<br/> return nil, types.ErrDealNotFound<br/>}</span><span id="143e" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// validate if the tx is from vendor<br/></em>if msg.Creator != deal.Vendor {<br/>  return nil, types.ErrInvalidVendor<br/>}</span><span id="eab2" class="kq kr ht kh b fv lf kt l ku kv">contract, found := k.Keeper.GetNewContract(ctx, msg.DealId,<br/>msg.ContractId)<br/>if !found {<br/> return nil, types.ErrContractNotFound<br/>}</span><span id="8786" class="kq kr ht kh b fv lf kt l ku kv">if contract.Status != types.APPROVED || contract.Status == types.COMPLETED {<br/> return nil, types.ErrNotApprovedOrCompleted<br/>}</span><span id="0930" class="kq kr ht kh b fv lf kt l ku kv">startTime, err := time.Parse(types.TIME_FORMAT, contract.StartTime)<br/>if err != nil {<br/> panic("invalid start time")<br/>}</span><span id="09c1" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// Calculate shipping delay if any (will be used later to calculate delay penalty)<br/></em>shippingExpectedTime := startTime.Add(time.Duration(contract.VendorETA))</span><span id="25b4" class="kq kr ht kh b fv lf kt l ku kv">shippingActualTime := ctx.BlockTime()<br/>if shippingActualTime.After(shippingExpectedTime) {<br/>shippingTimeDelay :=  shippingActualTime.Sub(shippingExpectedTime).Minutes()<br/>contract.ShippingDelay = uint32(shippingTimeDelay)<br/>}</span><span id="2a8b" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// mark the contract status as in delivery<br/></em>contract.Status = types.INDELIVERY<br/>k.Keeper.SetNewContract(ctx, contract)</span><span id="5395" class="kq kr ht kh b fv lf kt l ku kv">ctx.GasMeter().ConsumeGas(types.PROCESS_GAS, "Order shipped")</span><span id="5d2b" class="kq kr ht kh b fv lf kt l ku kv">ctx.EventManager().EmitEvent(<br/> sdk.NewEvent(sdk.EventTypeMessage,<br/> sdk.NewAttribute(sdk.AttributeKeyModule, types.ModuleName),<br/> sdk.NewAttribute(sdk.AttributeKeyAction, types.INDELIVERY),<br/> sdk.NewAttribute(types.IDVALUE, contract.ContractId),<br/> ),<br/>)</span><span id="0386" class="kq kr ht kh b fv lf kt l ku kv">return &amp;types.MsgShipOrderResponse{IdValue: contract.ContractId,  ContractStatus: contract.Status}, nil<br/>}</span></pre><p id="2edb" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在将合同状态更改为<code class="eh ke kf kg kh b">INDELIVERY</code>之前，我们在此记录运输延迟(如果有)。这将有助于我们计算订单交付后的延迟费用。请注意，我们有从<code class="eh ke kf kg kh b">ctx.BlockTime()</code>开始的当前可用时间。根据延期费用，将为交易所有人和供应商计算付款。和延期费用(如果有的话)将退还给消费者账户。</p><p id="3aa2" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">一旦订单到达消费者家门口，他需要启动一个tx来完成订单。该tx将订单标记为已完成，并将根据供应商佣金和延期费用结算所有资金。让我们简单了解一下<code class="eh ke kf kg kh b">orderDelivered</code>汉德勒。</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="2ede" class="kq kr ht kh b fv ks kt l ku kv">// msg_server_order_delivered.go</span><span id="8412" class="kq kr ht kh b fv lf kt l ku kv">package keeper</span><span id="0d68" class="kq kr ht kh b fv lf kt l ku kv">import (<br/>"context"<br/>"strconv"<br/>"time"<br/>"github.com/Harry-027/deal/x/deal/types"<br/>sdk "github.com/cosmos/cosmos-sdk/types"<br/>sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"<br/>)</span><span id="bf3e" class="kq kr ht kh b fv lf kt l ku kv">func (k msgServer) OrderDelivered(goCtx context.Context, msg *types.MsgOrderDelivered) (*types.MsgOrderDeliveredResponse, error) {<br/> ctx := sdk.UnwrapSDKContext(goCtx)<br/> logger := k.Logger(ctx)<br/> deal, found := k.Keeper.GetNewDeal(ctx, msg.DealId)</span><span id="f4b5" class="kq kr ht kh b fv lf kt l ku kv">if !found {<br/> return nil, types.ErrDealNotFound<br/>}</span><span id="9629" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// validate before processing the message<br/></em>contract, found := k.Keeper.GetNewContract(ctx, msg.DealId, msg.ContractId)<br/>if !found {<br/> return nil, types.ErrContractNotFound<br/>}</span><span id="b100" class="kq kr ht kh b fv lf kt l ku kv">if msg.Creator != contract.Consumer {<br/> return nil, types.ErrInvalidConsumer<br/>}</span><span id="9b42" class="kq kr ht kh b fv lf kt l ku kv">if contract.Status != types.INDELIVERY || contract.Status == types.COMPLETED {<br/> return nil, types.ErrNotShipped<br/>}</span><span id="d7ad" class="kq kr ht kh b fv lf kt l ku kv">startTime, err := time.Parse(types.TIME_FORMAT, contract.StartTime)<br/>if err != nil {<br/> panic("invalid start time")<br/>}</span><span id="e611" class="kq kr ht kh b fv lf kt l ku kv">deliveryExpectedTime := startTime.Add(time.Duration(contract.OwnerETA))<br/>deliveryActualTime := ctx.BlockTime()<br/>logger.Debug("deliveryExpectedTime :: ", deliveryExpectedTime)<br/>logger.Debug("deliveryActualTime :: ", deliveryActualTime)</span><span id="1184" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// calculate the delivery delay in case if any<br/></em>if deliveryActualTime.After(deliveryExpectedTime) {<br/>deliveryTimeDelay := deliveryActualTime.Sub(deliveryExpectedTime).Minutes()<br/>logger.Debug("deliveryTimeDelay :: ", deliveryTimeDelay)</span><span id="301a" class="kq kr ht kh b fv lf kt l ku kv">if contract.ShippingDelay != 0 {<br/><em class="ll">// subtract the shipping delay if any<br/></em>deliveryTimeDelay = deliveryTimeDelay - float64(contract.ShippingDelay)<br/>logger.Debug("deliveryTimeDelay after subtracting shipping delay", deliveryTimeDelay)<br/>}</span><span id="8422" class="kq kr ht kh b fv lf kt l ku kv">contract.DeliveryDelay = uint32(deliveryTimeDelay)<br/>}</span><span id="12d3" class="kq kr ht kh b fv lf kt l ku kv">timeTaken := deliveryActualTime.Sub(startTime).Minutes()<br/>logger.Debug("timeTaken :: ", timeTaken)</span><span id="99e0" class="kq kr ht kh b fv lf kt l ku kv">var refundAmount float64 = 0<br/>orderPayment := float64(contract.Fees)</span><span id="df57" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// calculate the penalty for late delivery/shipping for owner &amp; vendor respectively<br/></em>if timeTaken != 0 {<br/>vendorSlashPercent := float64(contract.ShippingDelay) / timeTaken<br/>logger.Debug("vendorSlashPercent :: ", vendorSlashPercent)</span><span id="a5e7" class="kq kr ht kh b fv lf kt l ku kv">ownerSlashPercent := float64(contract.DeliveryDelay) / timeTakenlogger.Debug("ownerSlashPercent :: ", ownerSlashPercent)</span><span id="baf8" class="kq kr ht kh b fv lf kt l ku kv">refundAmount = (vendorSlashPercent + ownerSlashPercent) * orderPayment * 0.01<br/>logger.Debug("refundAmount :: ", refundAmount)<br/>}</span><span id="414d" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">//deduct delay charges from payment<br/></em>totalPay := uint64(orderPayment - refundAmount)<br/>logger.Debug("TotalPay :: ", totalPay)<br/>moduleAccount := k.auth.GetModuleAddress(types.ModuleName)<br/>moduleBalance := k.bank.GetBalance(ctx, moduleAccount, types.TOKEN)</span><span id="6731" class="kq kr ht kh b fv lf kt l ku kv">if moduleBalance.IsLT(contract.GetCoin(totalPay)) {<br/> panic("Escrow account insufficient balance")<br/>}</span><span id="f02a" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// calculate the vendor payment for given order based on deal commission<br/></em>vendorPay := uint64(0.01 * float64(deal.Commission*totalPay))<br/>logger.Debug("vendorPay :: ", vendorPay)</span><span id="cb41" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// calculate the owner payment<br/></em>ownerPay := totalPay - vendorPay<br/>logger.Debug("ownerPay :: ", ownerPay)</span><span id="f338" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// validate the addresses for different parties involved in the contract<br/></em>consumerAddress, err := contract.GetConsumerAddress()<br/>if err != nil {<br/> panic("Invalid consumer address")<br/>}</span><span id="183a" class="kq kr ht kh b fv lf kt l ku kv">ownerAddress, err := deal.GetOwnerAddress()<br/>if err != nil {<br/> panic("Invalid owner address")<br/>}<br/>vendorAddress, err := deal.GetVendorAddress()</span><span id="e513" class="kq kr ht kh b fv lf kt l ku kv">if err != nil {<br/>panic("Invalid vendor address")<br/>}</span><span id="2a30" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// process the payment for all the parties<br/>// refund the delay charges to consumer</em></span><span id="9b38" class="kq kr ht kh b fv lf kt l ku kv">err = k.bank.SendCoinsFromModuleToAccount(ctx, types.ModuleName, consumerAddress, sdk.NewCoins(contract.GetCoin(uint64(refundAmount))))<br/>if err != nil {<br/>return nil, sdkerrors.Wrapf(err, types.ErrPaymentFailed.Error())<br/>}</span><span id="0029" class="kq kr ht kh b fv lf kt l ku kv">err = k.bank.SendCoinsFromModuleToAccount(ctx, types.ModuleName, ownerAddress, sdk.NewCoins(contract.GetCoin(ownerPay)))<br/>if err != nil {<br/>return nil, sdkerrors.Wrapf(err, types.ErrPaymentFailed.Error())<br/>}</span><span id="fa88" class="kq kr ht kh b fv lf kt l ku kv">err = k.bank.SendCoinsFromModuleToAccount(ctx, types.ModuleName, vendorAddress, sdk.NewCoins(contract.GetCoin(vendorPay)))<br/>if err != nil {<br/>return nil, sdkerrors.Wrapf(err, types.ErrPaymentFailed.Error())<br/>}</span><span id="c9c8" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// mark the contract status as completed as order has been delivered to consumer and settlement is complete<br/></em>contract.Status = types.COMPLETED<br/>k.Keeper.SetNewContract(ctx, contract)</span><span id="1e38" class="kq kr ht kh b fv lf kt l ku kv">ctx.GasMeter().ConsumeGas(types.SETTLEMENT_GAS, "Order delivered")</span><span id="196d" class="kq kr ht kh b fv lf kt l ku kv">ctx.EventManager().EmitEvent(<br/>sdk.NewEvent(sdk.EventTypeMessage,<br/>sdk.NewAttribute(sdk.AttributeKeyModule, types.ModuleName),<br/>sdk.NewAttribute(sdk.AttributeKeyAction, types.COMPLETED),<br/>sdk.NewAttribute(types.IDVALUE, contract.ContractId),<br/>sdk.NewAttribute(types.CONSUMER, contract.Consumer),<br/>sdk.NewAttribute(types.OWNER, deal.Owner),<br/>sdk.NewAttribute(types.VENDOR, deal.Vendor),<br/>sdk.NewAttribute(types.REFUND_PAY, strconv.FormatUint(uint64(refundAmount), 10)),<br/>sdk.NewAttribute(types.OWNER_PAY, strconv.FormatUint(ownerPay, 10)),<br/>sdk.NewAttribute(types.VENDOR_PAY, strconv.FormatUint(vendorPay, 10)),<br/>),<br/>)<br/>return &amp;types.MsgOrderDeliveredResponse{IdValue: contract.ContractId, ContractStatus: contract.Status}, nil<br/>}</span></pre><p id="6b02" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在上面的<code class="eh ke kf kg kh b">orderDelivered</code>处理程序中，在订单开始时间和发货延迟的帮助下，我们计算交货延迟(如果有)。计算出的延误费用与运输延误费用相加，并退还给消费者。鉴于卖方和业主根据卖方佣金和延期费用获得报酬。</p><p id="6c86" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们添加一个处理程序来取消订单，以防订单交付需要更多时间，用户可能想要取消订单。</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="f5e0" class="kq kr ht kh b fv ks kt l ku kv">// msg_server_cancel_order.go</span><span id="ee3b" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// CancelOrder is the tx handler for handling cancel order messages</em>func (k msgServer) CancelOrder(goCtx context.Context, msg *types.MsgCancelOrder) (*types.MsgCancelOrderResponse, error) {</span><span id="83d4" class="kq kr ht kh b fv lf kt l ku kv">ctx := sdk.UnwrapSDKContext(goCtx)<br/>contract, found := k.Keeper.GetNewContract(ctx, msg.DealId, msg.ContractId)</span><span id="3257" class="kq kr ht kh b fv lf kt l ku kv">if !found {<br/> return nil, types.ErrContractNotFound<br/>}<br/>err := msg.DealHandlerValidation(goCtx, &amp;contract)</span><span id="d09a" class="kq kr ht kh b fv lf kt l ku kv">if err != nil {<br/> return nil, err<br/>}</span><span id="d3d7" class="kq kr ht kh b fv lf kt l ku kv">consumerAddress, err := contract.GetConsumerAddress()<br/>if err != nil {<br/>  panic("Invalid consumer address")<br/>}</span><span id="6207" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// Validate is the escrow account has enough balance to process the refund<br/></em>moduleAccount := k.auth.GetModuleAddress(types.ModuleName)<br/>moduleBalance := k.bank.GetBalance(ctx, moduleAccount, types.TOKEN)</span><span id="4760" class="kq kr ht kh b fv lf kt l ku kv">if moduleBalance.IsLT(contract.GetCoin(contract.Fees)) {<br/> panic("Escrow account insufficient balance")<br/>}</span><span id="0964" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// Send coins from contract account to the consumer account</em></span><span id="e251" class="kq kr ht kh b fv lf kt l ku kv">err = k.bank.SendCoinsFromModuleToAccount(ctx, types.ModuleName, consumerAddress, sdk.NewCoins(contract.GetCoin(contract.Fees)))</span><span id="ef87" class="kq kr ht kh b fv lf kt l ku kv">if err != nil {<br/> return nil, sdkerrors.Wrapf(err, types.ErrPaymentFailed.Error())<br/>}</span><span id="0742" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// mark contract status as cancelled<br/></em>contract.Status = types.CANCELLED<br/>k.Keeper.SetNewContract(ctx, contract)</span><span id="09b9" class="kq kr ht kh b fv lf kt l ku kv">ctx.GasMeter().ConsumeGas(types.PROCESS_GAS, "Cancel Contract")</span><span id="adbf" class="kq kr ht kh b fv lf kt l ku kv">ctx.EventManager().EmitEvent(<br/>sdk.NewEvent(sdk.EventTypeMessage,<br/>sdk.NewAttribute(sdk.AttributeKeyModule, types.ModuleName),<br/>sdk.NewAttribute(sdk.AttributeKeyAction, types.CANCELLED),<br/>sdk.NewAttribute(types.IDVALUE, contract.ContractId),<br/>),<br/>)</span><span id="f609" class="kq kr ht kh b fv lf kt l ku kv">return &amp;types.MsgCancelOrderResponse{IdValue: contract.ContractId, ContractStatus: contract.Status}, nil<br/>}</span></pre><p id="18c0" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果订单交付延迟20分钟，我们允许用户取消订单，并将全部金额退还到用户帐户地址。</p><p id="f82d" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">最后，我们完成了Msg服务器处理程序。请确认我们的消息处理程序已经被模块注册-</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="3d00" class="kq kr ht kh b fv ks kt l ku kv">//module.go</span><span id="ec64" class="kq kr ht kh b fv lf kt l ku kv">func (am AppModule) Route() sdk.Route {<br/> return sdk.NewRoute(types.RouterKey, NewHandler(am.keeper))<br/>}</span></pre><p id="cfb9" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在，在启动区块链并测试消息和查询之前，让我们纠正起源状态以初始化交易计数器值。</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="663e" class="kq kr ht kh b fv ks kt l ku kv">// types/genesis.go</span><span id="c2e9" class="kq kr ht kh b fv lf kt l ku kv">func DefaultGenesis() *GenesisState {<br/>return &amp;GenesisState{<br/>DealCounter: &amp;DealCounter{<br/> IdValue: uint64(1),<br/>},<br/>NewDealList:     []NewDeal{},<br/>ContractCounter: nil,<br/>NewContractList: []NewContract{},<br/><em class="ll">// this line is used by starport scaffolding # genesis/types/default<br/></em>Params: DefaultParams(),<br/>}<br/>}</span></pre><p id="d265" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">确保我们正确初始化和导出创世状态-</p><pre class="ki kj kk kl fq km kh kn ko aw kp dt"><span id="83a2" class="kq kr ht kh b fv ks kt l ku kv">// x/deal/genesis.go</span><span id="3cc5" class="kq kr ht kh b fv lf kt l ku kv">package deal</span><span id="4289" class="kq kr ht kh b fv lf kt l ku kv">import (<br/>"github.com/Harry-027/deal/x/deal/keeper"<br/>"github.com/Harry-027/deal/x/deal/types"<br/>sdk "github.com/cosmos/cosmos-sdk/types"<br/>)<br/><em class="ll">// InitGenesis initializes the capability module's state from a provided genesis state.<br/></em>func InitGenesis(ctx sdk.Context, k keeper.Keeper, genState types.GenesisState) {</span><span id="fa66" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// Set if defined<br/></em>if genState.DealCounter != nil {<br/>  k.SetDealCounter(ctx, *genState.DealCounter)<br/>}</span><span id="5c20" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// Set all the newDeal<br/></em>for _, elem := range genState.NewDealList {<br/> k.SetNewDeal(ctx, elem)<br/>}</span><span id="661f" class="kq kr ht kh b fv lf kt l ku kv">for _, elem := range genState.ContractCounter {<br/>  k.SetContractCounter(ctx, *elem)<br/>}</span><span id="ad47" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// Set all the newContract<br/></em>for _, elem := range genState.NewContractList {<br/> k.SetNewContract(ctx, elem)<br/>}</span><span id="fafc" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// this line is used by starport scaffolding # genesis/module/init<br/>  </em>k.SetParams(ctx, genState.Params)<br/>}</span><span id="ee6a" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// ExportGenesis returns the capability module's exported genesis.<br/></em>func ExportGenesis(ctx sdk.Context, k keeper.Keeper) *types.GenesisState {<br/>genesis := types.DefaultGenesis()<br/>genesis.Params = k.GetParams(ctx)<br/><em class="ll">// Get all dealCounter<br/></em>dealCounter, found := k.GetDealCounter(ctx)<br/>if found {<br/> genesis.DealCounter = &amp;dealCounter<br/>}</span><span id="c7ce" class="kq kr ht kh b fv lf kt l ku kv">genesis.NewDealList = k.GetAllNewDeal(ctx)<br/><em class="ll">// Get all contractCounter<br/></em>contractCounter, err := k.GetAllContractCounter(ctx)<br/>if err == nil {<br/> genesis.ContractCounter = contractCounter<br/>}</span><span id="6f81" class="kq kr ht kh b fv lf kt l ku kv">for _, counter := range contractCounter {<br/>contractsForDealId := k.GetAllNewContract(ctx, counter.DealId)<br/> genesis.NewContractList = append(genesis.NewContractList,  contractsForDealId...)<br/>}</span><span id="dbf0" class="kq kr ht kh b fv lf kt l ku kv"><em class="ll">// this line is used by starport scaffolding # genesis/module/export<br/> </em>return genesis<br/>}</span></pre><p id="342e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">运行命令<code class="eh ke kf kg kh b">starport chain serve</code>来加速我们的开发节点。</p><p id="8367" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">打开另一个终端并运行命令<code class="eh ke kf kg kh b">starport chain build</code>，这将生成<code class="eh ke kf kg kh b">deald</code>二进制文件，用于测试txs并查询正在运行的节点。</p></div><div class="ab cl lm ln hb lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hm hn ho hp hq"><p id="37d9" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在下一部分中，我们将了解自定义事件索引以及用户如何订阅自定义索引事件。</p></div><div class="ab cl lm ln hb lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="hm hn ho hp hq"><p id="b001" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这里引用源代码- <a class="ae jf" href="https://github.com/Harry-027/deal" rel="noopener ugc nofollow" target="_blank"> <em class="ll">源代码</em> </a></p><p id="b712" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">系列<br/>*<a class="ae jf" rel="noopener" href="/coinmonks/building-an-application-specific-blockchain-using-cosmos-sdk-part-1-1f8388902fc8"><em class="ll">Part-1</em></a><em class="ll"><br/>*</em><a class="ae jf" rel="noopener" href="/@harish0y2j/building-an-application-specific-blockchain-using-cosmos-sdk-part-2-3da0b727cd9b"><em class="ll">Part-2</em></a><br/>*<a class="ae jf" rel="noopener" href="/@harish0y2j/building-an-application-specific-blockchain-using-cosmos-sdk-part-3-8ab623f35c74"><em class="ll">Part-3</em></a><em class="ll"><br/>*</em><a class="ae jf" rel="noopener" href="/@harish0y2j/building-an-application-specific-blockchain-using-cosmos-sdk-part-4-bf0c609ecacc"><em class="ll">Part-4</em></a><em class="ll"><br/>*</em><a class="ae jf" rel="noopener" href="/@harish0y2j/building-an-application-specific-blockchain-using-cosmos-sdk-part-5-e22c9a6debe3"><em class="ll">Part-5</em></a><em class="ll"><br/>*</em></p><blockquote class="lt"><p id="a118" class="lu lv ht bd lw lx ly lz ma mb mc kd ek translated">加入Coinmonks <a class="ae jf" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jf" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="7f3f" class="md kr ht bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz dt translated">另外，阅读</h1><ul class=""><li id="5960" class="kw kx ht ji b jj na jn nb jr nc jv nd jz ne kd lb lc ld le dt translated"><a class="ae jf" href="https://coincodecap.com/trading-signal" rel="noopener ugc nofollow" target="_blank">交易信号是什么？</a> | <a class="ae jf" href="https://coincodecap.com/bitstamp-coinbase" rel="noopener ugc nofollow" target="_blank"> Bitstamp vs比特币基地</a> | <a class="ae jf" href="https://coincodecap.com/buy-solana" rel="noopener ugc nofollow" target="_blank">买索拉纳</a></li><li id="970e" class="kw kx ht ji b jj lg jn lh jr li jv lj jz lk kd lb lc ld le dt translated"><a class="ae jf" href="https://coincodecap.com/profitfarmers-review" rel="noopener ugc nofollow" target="_blank"> ProfitFarmers点评</a> | <a class="ae jf" href="https://coincodecap.com/cornix-trading-bot" rel="noopener ugc nofollow" target="_blank">如何使用Cornix Trading Bot </a></li><li id="8c77" class="kw kx ht ji b jj lg jn lh jr li jv lj jz lk kd lb lc ld le dt translated"><a class="ae jf" href="https://coincodecap.com/best-cryptocurrency-blogs" rel="noopener ugc nofollow" target="_blank">十大最佳加密货币博客</a> | <a class="ae jf" href="https://coincodecap.com/youhodler-review" rel="noopener ugc nofollow" target="_blank"> YouHodler评论</a></li><li id="218e" class="kw kx ht ji b jj lg jn lh jr li jv lj jz lk kd lb lc ld le dt translated"><a class="ae jf" href="https://coincodecap.com/myconstant-review" rel="noopener ugc nofollow" target="_blank">my constant Review</a>|<a class="ae jf" href="https://coincodecap.com/best-swing-trading-bots" rel="noopener ugc nofollow" target="_blank">8款最佳摇摆交易机器人</a></li><li id="5cf0" class="kw kx ht ji b jj lg jn lh jr li jv lj jz lk kd lb lc ld le dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/mxc-exchange-review-3af0ec1cba8c"> MXC交易所评论</a> | <a class="ae jf" href="https://coincodecap.com/pionex-vs-binance" rel="noopener ugc nofollow" target="_blank"> Pionex vs币安</a> | <a class="ae jf" href="https://coincodecap.com/pionex-arbitrage-bot" rel="noopener ugc nofollow" target="_blank"> Pionex套利机器人</a></li></ul></div></div>    
</body>
</html>