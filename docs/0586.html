<html>
<head>
<title>Solidity for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者的可靠性</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-for-beginners-89fd67465cb?source=collection_archive---------19-----------------------#2022-02-11">https://medium.com/coinmonks/solidity-for-beginners-89fd67465cb?source=collection_archive---------19-----------------------#2022-02-11</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="572a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这些年来，网络发生了巨大的变化，它现在的应用程序与早期相比已经面目全非。web的发展通常分为三个阶段:Web 1.0、Web 2.0和Web 3.0。</p><p id="17e0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">旨在实现去中心化并使用区块链来实现这一壮举的web 3.0现在几乎处于初级阶段，任何现在进入它的人都是众所周知的早起鸟，为了在web 3上开发应用程序和编写智能合同，使用了两种语言，即solidity和vyper，流行的语言是solidity，这篇文章将涵盖从solidity开始时需要知道的基本知识。</p><h1 id="1241" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated"><strong class="ak">什么是扎实？</strong></h1><p id="75b2" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">Solidity是一种etheruem智能合约语言，是一种面向对象的高级语言，用于实现智能合约。智能合约是在以太坊状态下控制账户行为的程序。</p><p id="3bc9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Solidity是静态类型的，支持继承、库和复杂的用户定义类型等特性。有了Solidity，你可以为投票、众筹、盲目拍卖和多重签名钱包等用途创建合同。</p><p id="5867" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Solidity对于编写智能合同和构建去中心化的应用程序很有用，智能合同是存储在区块链上的数字合同，当满足预定的条款和条件时会自动执行，solidity的语法也类似于javascript的语法。</p><h1 id="6e6f" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated"><strong class="ak">坚实度数据类型</strong></h1><p id="66b4" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">Solidity是静态类型的编程语言，这意味着需要指定变量的类型。对于那些来自javascript后台的数据，solidity中不存在空的和未定义的数据类型，但是每种类型都有自己的默认值，即地址的默认值是<strong class="is hu">0x 0000000000000000000000000000000。</strong></p><p id="f36e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">固体数据类型可以根据数据位置进行分类。如果变量存储自己的数据；它是一种值类型。如果它保存数据的位置；它是一个引用类型。</p><p id="412f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">实值中的值类型</strong></p><p id="63b7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们知道值类型是那些存储自己数据的类型，它们是:</p><h2 id="ea3c" class="kr jp ht bd jq ks kt ku ju kv kw kx jy jb ky kz kc jf la lb kg jj lc ld kk le dt translated"><strong class="ak">布尔型</strong></h2><p id="4304" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">可能的值是真和假的常数。操作员是…</p><p id="d3aa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">● !(逻辑否定)<br/> ● &amp; &amp;(逻辑合取，“与”)<br/> ● ||(逻辑析取，“或”)<br/> ● ==(等式)<br/> ●！=(不等式)</p><h1 id="296d" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated"><strong class="ak">整数</strong></h1><p id="e326" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">这些分为int和uint，int代表有符号整数，这些只是正数的范围，uint代表无符号整数，包括正数和负数。</p><h2 id="3f74" class="kr jp ht bd jq ks kt ku ju kv kw kx jy jb ky kz kc jf la lb kg jj lc ld kk le dt translated"><strong class="ak">字符串文字和类型</strong></h2><p id="2a7b" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">字符串文字由双引号或单引号组成(“foo”或“bar”)，也可以分成多个连续的部分(“foobar”相当于“foobar”)，这在处理长字符串时很有用。它们不像C中那样隐含尾随零；“foo”代表三个字节，而不是四个。与整数文字一样，它们的类型可以变化，但是如果合适的话，它们可以隐式地转换为bytes1、…、bytes32、bytes和string。</p><h1 id="1e94" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated"><strong class="ak">地址</strong></h1><p id="dd84" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">地址有两种来源，它们几乎完全相同</p><ul class=""><li id="cb7c" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln dt translated">地址:保存一个20字节的值(以太坊地址的大小)。</li><li id="068a" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">应付地址:与地址相同，多了两个会员转送。</li></ul><p id="3a75" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这种区别背后的想法是，<code class="eh lt lu lv lw b">address payable</code>是一个可以发送以太网的地址，而普通的<code class="eh lt lu lv lw b">addres</code>不能发送以太网。</p><h2 id="6eab" class="kr jp ht bd jq ks kt ku ju kv kw kx jy jb ky kz kc jf la lb kg jj lc ld kk le dt translated"><strong class="ak">固定大小的字节数组</strong></h2><p id="6128" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">值类型bytes1、bytes2、bytes3、…、bytes32保存从1到32的字节序列。byte是bytes1的别名。</p></div><div class="ab cl lx ly hb lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hm hn ho hp hq"><p id="cf5f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">参考类型</strong></p><p id="6bb7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">引用类型的值可以通过多个不同的名称来修改。这与值类型形成对比，在值类型中，无论何时使用值类型的变量，都会得到一个独立的副本。因此，引用类型必须比值类型处理得更小心。目前，引用类型包括结构、数组和映射。如果使用引用类型，则必须始终显式提供存储该类型的数据区域。</p><ul class=""><li id="7f10" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln dt translated"><strong class="is hu">结构</strong></li></ul><p id="beb3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Solidity允许用户以结构化的形式创建自己的数据类型。该结构包含一组具有不同数据类型的元素。通常，它用于表示一个记录。为了定义一个结构<em class="me">，使用了struct </em>关键字，它创建了一个新的数据类型。</p><ul class=""><li id="1861" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln dt translated"><strong class="is hu">枚举</strong></li></ul><p id="1bcd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">枚举是在Solidity中创建用户定义类型的一种方式。它们可以在所有整数类型之间显式转换，但不允许隐式转换。整数的显式转换在运行时检查值是否在枚举的范围内，否则会导致断言失败。枚举需要至少一个成员，声明时其默认值是第一个成员。</p><ul class=""><li id="5389" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln dt translated"><strong class="is hu">数组</strong></li></ul><p id="dc6d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">数组是存储相同数据类型的元素的固定集合的数据结构，其中每个元素都有一个称为索引的特定位置。我们不需要创建大量相同类型的单独变量，只需声明一个所需大小的数组，并将元素存储在数组中，并可以使用索引来访问。在Solidity中，数组可以是固定大小或动态大小的。</p></div><div class="ab cl lx ly hb lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hm hn ho hp hq"><h1 id="9047" class="jo jp ht bd jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh mj kj kk kl dt translated"><strong class="ak">变量类型</strong></h1><p id="5dad" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">变量的类型是根据它们在智能契约中声明的来分类的，这可以比作javascript中的范围概念，其中我们有局部和全局变量，但是在solidity中我们有:</p><ul class=""><li id="d051" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln dt translated"><strong class="is hu">状态变量:</strong>这些变量未在任何函数中声明，可由智能合约中的任何函数访问，它们永久存储在智能合约中</li><li id="9b1c" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated"><strong class="is hu">局部变量:</strong>这些在函数中声明的变量只能在声明它们的函数中被访问，它们会一直存在，直到函数被执行</li></ul><p id="58ea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">全局变量:</strong>这些是一些特殊的变量，可以在全局范围内使用，并给出有关事务和区块链属性的信息。</p></div><div class="ab cl lx ly hb lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hm hn ho hp hq"><p id="384d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">内存和位置</strong></p><p id="d3b8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">存储:</strong>是所有契约状态变量驻留的地方。每个契约都有自己的存储，它在函数调用之间是持久的，使用起来非常昂贵。默认情况下，结构、数组或映射类型的局部变量引用存储。<br/> <strong class="is hu">内存</strong>:用于保存临时值。它在(外部)函数调用之间被擦除，使用起来更便宜。</p></div><div class="ab cl lx ly hb lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hm hn ho hp hq"><h1 id="cf23" class="jo jp ht bd jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh mj kj kk kl dt translated">功能类型</h1><p id="f147" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">函数是一组可重用的代码，可以在程序中的任何地方调用。这消除了反复编写相同代码的需要。它帮助程序员编写模块化代码。下面将讨论solidity中的各种函数类型</p><ul class=""><li id="13b0" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln dt translated"><strong class="is hu">外部函数:</strong>外部函数是合同接口的一部分，也就是说可以从其他合同和交易中调用。不能在内部调用外部函数f(即f()不起作用，但this.f()起作用)。外部函数在接收大型数据数组时有时会更有效，因为数据不是从calldata复制到内存中的。</li><li id="f1b0" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated"><strong class="is hu">公共函数:</strong>公共函数是契约接口的一部分，可以在内部调用，也可以通过消息调用。对于公共状态变量，会生成一个自动getter函数。</li><li id="848c" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated"><strong class="is hu">内部函数:</strong>这些函数和状态变量只能在内部访问(即从当前合同或从其派生的合同中)，而不能使用这个。</li><li id="5683" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated"><strong class="is hu">私有函数:</strong>私有函数和状态变量仅对定义它们的契约可见，在派生契约中不可见。</li></ul><p id="cf1d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">此外，根据函数与状态变量的交互方式，函数可以分为纯函数和视图函数。</p><ul class=""><li id="3033" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln dt translated"><strong class="is hu">查看功能:</strong>这是读取和修改状态变量的功能。</li><li id="b98a" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated"><strong class="is hu">纯函数:</strong>这些函数不读取或修改智能合约中的状态变量。</li></ul><p id="8cac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，函数中需要了解的另一个概念是函数修饰符，它们用于在智能契约中改变函数的行为。</p></div><div class="ab cl lx ly hb lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hm hn ho hp hq"><p id="b049" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们已经到了这篇文章的结尾，但这只是对solidity编程语言的简要概述，下面列出了你需要知道的其他概念和你需要浏览的资源。</p><ul class=""><li id="ed70" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln dt translated">坚固性的处理误差</li><li id="7707" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">坚实中的继承</li><li id="5ac3" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">事件</li><li id="6ad0" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">后备功能</li><li id="bba1" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">构造器</li></ul><p id="98a3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">资源</strong></p><ul class=""><li id="fcca" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln dt translated">【Youtube新手坚实度教程</li><li id="e7bb" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated"><a class="ae mk" href="https://docs.soliditylang.org/en/v0.8.11/introduction-to-smart-contracts.html" rel="noopener ugc nofollow" target="_blank">官方担保文件</a></li><li id="be05" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated"><a class="ae mk" href="https://ethereum.org/en/developers/docs/" rel="noopener ugc nofollow" target="_blank">以太网固化文件</a></li><li id="fd39" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated"><a class="ae mk" href="https://www.youtube.com/channel/UCJWh7F3AFyQ_x01VKzr9eyA" rel="noopener ugc nofollow" target="_blank">智能合约程序员Youtube </a></li></ul><p id="fd11" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你喜欢这篇文章，请多鼓掌并与他人分享。</p></div></div>    
</body>
</html>