<html>
<head>
<title>Day 5: Events log and introduction about the Graph</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第5天:事件日志和关于图表的介绍</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/day-5-events-log-and-introduction-about-the-graph-8254815eb95e?source=collection_archive---------1-----------------------#2022-04-19">https://medium.com/coinmonks/day-5-events-log-and-introduction-about-the-graph-8254815eb95e?source=collection_archive---------1-----------------------#2022-04-19</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><h1 id="67fd" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">概观</h1><p id="1d07" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我们都知道，块分散应用程序或Dapp利用智能合约来执行业务逻辑，而区块链it本身作为交易的超级分类帐，充当不可变的数据库。前端在web3库(如EtherJS或Web3JS)的帮助下，将能够与区块链节点进行对话，以读取或写入区块链。在Web3的世界中，基本架构如下所示:</p><figure class="kn ko kp kq fq kr fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff km"><img src="../Images/ffb1cd354b6ec10f851df1910b8df603.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6voMnL7XRM2-tMmEfeE7Q.png"/></div></div><figcaption class="ky kz fg fe ff la lb bd b be z ek"><a class="ae lc" href="https://www.preethikasireddy.com/post/the-architecture-of-a-web-3-0-application" rel="noopener ugc nofollow" target="_blank">https://www.preethikasireddy.com/post/the-architecture-of-a-web-3-0-application</a></figcaption></figure><p id="0cbe" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">我真心建议你仔细阅读Preethi Kasireddy女士写的帖子，了解从Web2到Web3架构的演变。</p><h1 id="2d69" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">事件日志机制的需求</h1><p id="ed48" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">如果我们想知道区块链上发生了什么？对于Web2，这很简单，因为我们可以使用日志机制来捕获事件，以便稍后检查并显示在仪表板上(使用类似ELK stack的东西)。在Web3的世界里，事情变得更加复杂，因为:</p><ul class=""><li id="3c9c" class="li lj ht jq b jr ld jv le jz lk kd ll kh lm kl ln lo lp lq dt translated">当传统的区块链没有这样的日志记录机制时，我们如何知道区块链上发生了什么(用于监督、调试等……)。</li><li id="26ad" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">我们可以创建智能合同，并将事件捕获到区块链中以备后用，但这将非常昂贵，而且每次我们需要读取数据时，都需要额外调用区块链，因此，我们如何以高效的方式存储日志并检索它们呢？</li><li id="630c" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">如果我们存储我们的日志，区块链不是一个真正的数据库，而是一个超级分类帐，因为它不提供像SQL这样的查询语言。那么，我们如何对那个分类账进行复杂的查询呢？</li></ul><p id="4bc0" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">区块链像以太坊一样提供了对事件日志的支持。智能协定开发人员可以实现在事务发生时发出事件。这些事件被写到事务日志中，这要便宜得多，前端在Web3库的帮助下可以观察和过滤事件日志，以获得它感兴趣的内容并相应地做一些事情。</p><p id="c96c" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">在这篇文章的范围内，我们不会进入以太坊如何做到这一点的技术细节，但我认为下面的链接将对理解以太坊区块链的事件日志有很大的帮助。</p><div class="lw lx fm fo ly lz"><a rel="noopener follow" target="_blank" href="/mycrypto/understanding-event-logs-on-the-ethereum-blockchain-f4ae7ba50378"><div class="ma ab ej"><div class="mb ab mc cl cj md"><h2 class="bd hu fv z el me eo ep mf er et hs dt translated">了解以太坊区块链上的事件日志</h2><div class="mg l"><h3 class="bd b fv z el me eo ep mf er et ek translated">每个事务都有一个事件日志，但是这些事件日志可能很难阅读。</h3></div><div class="mh l"><p class="bd b gc z el me eo ep mf er et ek translated">medium.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn kw lz"/></div></div></a></div><p id="c248" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">简而言之，要捕获事件，我们需要执行以下步骤</p><ul class=""><li id="7d18" class="li lj ht jq b jr ld jv le jz lk kd ll kh lm kl ln lo lp lq dt translated">定义事件:定义需要捕获和索引的数据</li><li id="5908" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">发出事件:通过使用<code class="eh mo mp mq mr b">emit</code>关键字，智能合约可以按照定义的格式动态发出事件。</li><li id="1341" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">捕获事件:前端显式地观察事件日志，捕获它感兴趣的任何内容，并执行预定义的逻辑或UI更新。</li></ul><p id="cfbb" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">但是仍然有未解决的问题</p><ul class=""><li id="f45c" class="li lj ht jq b jr ld jv le jz lk kd ll kh lm kl ln lo lp lq dt translated">对事件日志进行复杂的查询</li><li id="5f84" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">回溯事件(过去的事件)</li></ul><p id="9773" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated"><strong class="jq hu">介绍图表</strong></p><blockquote class="ms mt mu"><p id="3147" class="jo jp mv jq b jr ld jt ju jv le jx jy mw lf kb kc mx lg kf kg my lh kj kk kl hm dt translated">图表是什么？</p><p id="6f4a" class="jo jp mv jq b jr ld jt ju jv le jx jy mw lf kb kc mx lg kf kg my lh kj kk kl hm dt translated">该图是一个分散的协议，用于索引和查询来自区块链的数据，从以太坊开始。使得难以直接查询的数据查询成为可能。</p><p id="266f" class="jo jp mv jq b jr ld jt ju jv le jx jy mw lf kb kc mx lg kf kg my lh kj kk kl hm dt translated"><a class="ae lc" href="https://thegraph.com/docs/en/about/introduction/" rel="noopener ugc nofollow" target="_blank">https://thegraph.com/docs/en/about/introduction/</a></p></blockquote><p id="7542" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">因此<a class="ae lc" href="https://thegraph.com/" rel="noopener ugc nofollow" target="_blank">图</a>通过构建一个分散的协议来解决我们的问题，该协议允许处理区块链事件并将它们存储为索引数据，dApps可以通过API端点(GraphQL)查询这些数据。那么他们是怎么做到的呢？</p><figure class="kn ko kp kq fq kr fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff mz"><img src="../Images/03193ccc0c5e18a0d0254390214a56d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FLx_BVxT7e5R1Q9PPIuL6Q.png"/></div></div></figure><p id="60c9" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated"><em class="mv">该图基于子图描述学习什么以及如何索引区块链数据，这被称为子图清单。子图描述定义了子图感兴趣的智能契约、这些契约中要注意的事件，以及如何将事件数据映射到图将存储在其数据库中的数据。</em></p><p id="944f" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">因此，我们可以把图看作是一个分散的网络，包含许多运行图的分散协议的节点。图表是由子图表构成的，就像你的DApp是由智能合约构成的一样。每个子图都是使用子图清单定义的，子图清单实际上定义了目标智能合同及其需要被捕获和索引的事件。一旦子图被部署，下面场景显示了实际发生的情况:</p><ul class=""><li id="6d67" class="li lj ht jq b jr ld jv le jz lk kd ll kh lm kl ln lo lp lq dt translated">dApps(通过它们的智能合约)提交事务，这将发出事件。</li><li id="a11c" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">图形节点扫描每个块寻找事件</li><li id="34e5" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">图节点在块中为您的子图查找事件，并运行映射处理程序来将捕获的事件存储到数据结构中。</li><li id="2539" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">dApp可以通过GraphQL APIs查询这些数据，GraphQL APIs由Graph节点进行翻译以获取索引数据。</li></ul><h2 id="3336" class="na ir ht bd is nb nc nd iw ne nf ng ja jz nh ni je kd nj nk ji kh nl nm jm nn dt translated">动手部件</h2><p id="47f6" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我们将尝试做以下事情:</p><ul class=""><li id="b66e" class="li lj ht jq b jr ld jv le jz lk kd ll kh lm kl ln lo lp lq dt translated">使用OpenZeppelin库构建一个简单的ERC20智能合约</li><li id="6d6c" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">将我们的智能合约部署到本地Ganache上，并从我们的智能合约中发出事件</li><li id="3d23" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">设置一个本地子图节点，用于监视和索引来自Ganache的事件</li><li id="3d88" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">使用Apollo客户端从前端向本地子图进行查询</li></ul><ol class=""><li id="d8e7" class="li lj ht jq b jr ld jv le jz lk kd ll kh lm kl no lo lp lq dt translated"><strong class="jq hu">简单的ERC20令牌</strong></li></ol><p id="c38a" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">创建一个hardhat-vue项目(请参考<a class="ae lc" rel="noopener" href="/coinmonks/blockchain-day-1-environment-setup-4b2ed581cc99">第1天</a>了解更多详情)</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="d037" class="na ir ht mr b fv nt nu l nv nw">$vue create MyToken<br/>$cd MyToken<br/>$mkdir blockchain<br/>$npm init<br/>$npm install --save-dev hardhat<br/>$npm install @openzeppelin/contracts</span></pre><p id="6bb2" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">我们的智能合约非常简单，因为我们重用了OpenZeppelin library中的ERC20。除了从ERC20发出的事件之外，还包括</p><ul class=""><li id="f50f" class="li lj ht jq b jr ld jv le jz lk kd ll kh lm kl ln lo lp lq dt translated">转移</li><li id="bae4" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">同意</li><li id="f61f" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">所有权转让</li></ul><p id="1a3d" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">出于测试目的，我们还自定义了<code class="eh mo mp mq mr b">NameChanged</code>事件，并在我们更改私有属性<code class="eh mo mp mq mr b">_name</code>时发出该事件。</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="f68b" class="na ir ht mr b fv nt nu l nv nw">// SPDX-License-Identifier: MIT</span><span id="f4c5" class="na ir ht mr b fv nx nu l nv nw">pragma solidity ^0.8.4;</span><span id="3af5" class="na ir ht mr b fv nx nu l nv nw">import "@openzeppelin/contracts/token/ERC20/ERC20.sol";</span><span id="7896" class="na ir ht mr b fv nx nu l nv nw">import "@openzeppelin/contracts/access/Ownable.sol";</span><span id="4231" class="na ir ht mr b fv nx nu l nv nw">contract MiiToken is ERC20, Ownable {</span><span id="ea21" class="na ir ht mr b fv nx nu l nv nw">    string private _name;</span><span id="04ec" class="na ir ht mr b fv nx nu l nv nw">    event NameChanged(string newName, address by);</span><span id="3ff4" class="na ir ht mr b fv nx nu l nv nw">    constructor(uint256 initialSupply) ERC20("MiiToken", "MIT") {<br/>        _name = "MiiToken";</span><span id="1a2e" class="na ir ht mr b fv nx nu l nv nw">        _mint(msg.sender, initialSupply);</span><span id="c25e" class="na ir ht mr b fv nx nu l nv nw">    }</span><span id="e5ae" class="na ir ht mr b fv nx nu l nv nw">    function changeName(string memory name) public onlyOwner {</span><span id="1ff0" class="na ir ht mr b fv nx nu l nv nw">       _name = name;</span><span id="aa69" class="na ir ht mr b fv nx nu l nv nw">       emit NameChanged(name, msg.sender);</span><span id="fabb" class="na ir ht mr b fv nx nu l nv nw">    }</span><span id="5c8c" class="na ir ht mr b fv nx nu l nv nw">    function getName() public view returns (string memory){</span><span id="484d" class="na ir ht mr b fv nx nu l nv nw">        return _name;</span><span id="8382" class="na ir ht mr b fv nx nu l nv nw">    }</span><span id="e632" class="na ir ht mr b fv nx nu l nv nw">}</span></pre><p id="3421" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated"><strong class="jq hu"> 2。在Ganache上构建和部署我们的智能合约</strong></p><ul class=""><li id="a9bc" class="li lj ht jq b jr ld jv le jz lk kd ll kh lm kl ln lo lp lq dt translated">首先运行我们的加纳切本地区块链</li><li id="1c71" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">修改hardhat.config.ts以使用ganache</li></ul><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="0d9e" class="na ir ht mr b fv nt nu l nv nw">networks: {<br/>   ...</span><span id="ea84" class="na ir ht mr b fv nx nu l nv nw">   ganache: {</span><span id="ea10" class="na ir ht mr b fv nx nu l nv nw">       url: process.env.GANACHE_URL || "",</span><span id="70d0" class="na ir ht mr b fv nx nu l nv nw">       accounts:</span><span id="f6c3" class="na ir ht mr b fv nx nu l nv nw">            process.env.GANACHE_PRIVATE_KEY !== undefined ? <br/>            [process.env.GANACHE_PRIVATE_KEY] : [],</span><span id="1699" class="na ir ht mr b fv nx nu l nv nw">       },</span><span id="0751" class="na ir ht mr b fv nx nu l nv nw">   },<br/>},</span></pre><ul class=""><li id="ef20" class="li lj ht jq b jr ld jv le jz lk kd ll kh lm kl ln lo lp lq dt translated">部署设置文件<code class="eh mo mp mq mr b">scripts/deploy.ts</code>:</li></ul><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="40be" class="na ir ht mr b fv nt nu l nv nw">async function main() {</span><span id="5e6d" class="na ir ht mr b fv nx nu l nv nw">    const MiiToken = await ethers.getContractFactory("MiiToken");</span><span id="5c79" class="na ir ht mr b fv nx nu l nv nw">    const mitoken = await MiiToken.deploy(1000000);</span><span id="acf5" class="na ir ht mr b fv nx nu l nv nw">    await mitoken.deployed();</span><span id="69b3" class="na ir ht mr b fv nx nu l nv nw">    console.log("Miitoken deployed to:", mitoken.address);</span><span id="dd93" class="na ir ht mr b fv nx nu l nv nw">}</span></pre><ul class=""><li id="6dea" class="li lj ht jq b jr ld jv le jz lk kd ll kh lm kl ln lo lp lq dt translated">部署智能合同:</li></ul><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="2acf" class="na ir ht mr b fv nt nu l nv nw">$npx hardhat run --network ganache scripts/deploy.ts</span></pre><ul class=""><li id="8e87" class="li lj ht jq b jr ld jv le jz lk kd ll kh lm kl ln lo lp lq dt translated">在这一步，我们可以使用<code class="eh mo mp mq mr b">hardhat console</code>来处理我们部署的智能契约，尝试发出诸如转移令牌、更改名称等事件..等等</li></ul><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="a641" class="na ir ht mr b fv nt nu l nv nw">$npx hardhat console <br/>&gt; let MiiToken = await ethers.getContractFactory("MiiToken");<br/>&gt; let miiToken = await MiiToken.attach('&lt;SmartContractAddress&gt;');<br/>&gt; await miiToken.changeName('SomeInterestingName');<br/>&gt; await miiToken.getName();<br/>&gt; await miiToken.transfer('&lt;SomeAddresss&gt;', &lt;SomeToken&gt;);</span></pre><p id="2e80" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated"><strong class="jq hu"> 3-使用docker </strong>运行子图节点</p><p id="32ff" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">下一步是运行我们的本地图节点，并将其连接到我们的本地ganache。首先，我们从github克隆图形节点</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="02f2" class="na ir ht mr b fv nt nu l nv nw">git clone <a class="ae lc" href="https://github.com/graphprotocol/graph-node/" rel="noopener ugc nofollow" target="_blank">https://github.com/graphprotocol/graph-node/</a></span></pre><p id="a073" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">然后，我们通过修改<code class="eh mo mp mq mr b">graph-node/docker/docker-compose.yml</code>来使用<a class="ae lc" href="http://host.docker.internal:7545" rel="noopener ugc nofollow" target="_blank">http://host . docker . internal:7545</a>(ganache gRPC服务器)将图节点连接到Ganache</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="fbd2" class="na ir ht mr b fv nt nu l nv nw">environment:<br/>      postgres_host: postgres<br/>      postgres_user: graph-node<br/>      postgres_pass: let-me-in<br/>      postgres_db: graph-node<br/>      ipfs: 'ipfs:5001'<br/><strong class="mr hu">      ethereum: 'mainnet:</strong><a class="ae lc" href="http://host.docker.internal:7545'" rel="noopener ugc nofollow" target="_blank"><strong class="mr hu">http://host.docker.internal:7545'</strong></a></span></pre><p id="48cc" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">然后开始，我们设置图形节点并运行</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="3d49" class="na ir ht mr b fv nt nu l nv nw">$ ./setup.sh<br/>$ docker-compose up</span></pre><p id="78d1" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">※有时我们需要删除数据文件夹来重新运行:</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="ae8d" class="na ir ht mr b fv nt nu l nv nw">$docker-compose down -v <br/>$rm -rf data</span></pre><p id="9a3e" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">此时，图节点连接到ganache，但是我们还没有定义任何子图。</p><p id="2c09" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated"><strong class="jq hu"> 4-定义我们的子图</strong></p><p id="a93f" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">现在是时候通过定义子图来定义我们想要捕获和检索什么数据了。但是在此之前，我们在我们的vue项目根文件夹中创建一个文件夹</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="6945" class="na ir ht mr b fv nt nu l nv nw">$ mkdir subgraph <br/>$ cd subgraph</span></pre><p id="69dd" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">然后我们需要安装graph cli</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="cdf9" class="na ir ht mr b fv nt nu l nv nw">npm install -g @graphprotocol/graph-cli</span></pre><p id="eb7f" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">使用以下命令初始化子图</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="2024" class="na ir ht mr b fv nt nu l nv nw">$ graph init</span></pre><p id="ccaf" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">Graph CLI将询问我们一些问题，并尝试从以太网扫描获取ABI，这是不可能的，因为我们正在使用本地ganache。但是不要担心，因为它毕竟允许我们手动提供ABI:</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="a120" class="na ir ht mr b fv nt nu l nv nw">❯ graph init<br/>✔ Protocol · ethereum<br/>✔ Product for which to initialize · subgraph-studio<br/>✔ Subgraph slug · MIT<br/>✔ Directory to create the subgraph in · MIT<br/>✔ Ethereum network · mainnet<br/>✔ Contract address · &lt;Deployed Address on Ganache&gt; <br/>✖ Failed to fetch ABI from Etherscan: ABI not found, try loading it from a local file<br/>? ABI file (path) ›..<strong class="mr hu">/blockchain/artifacts/contracts/MiiToken.sol/MiiToken.json</strong></span></pre><p id="fc13" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">这是结果:</p><figure class="kn ko kp kq fq kr fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff ny"><img src="../Images/7d3440df3162b747ddd0d240335d25ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7kQKYdnk9mO_mt6VE-lNkA.png"/></div></div></figure><p id="2017" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">正如我们已经知道的，子图定义有3个主要组成部分</p><ul class=""><li id="5b5a" class="li lj ht jq b jr ld jv le jz lk kd ll kh lm kl ln lo lp lq dt translated">yaml:把它想象成设置文件，定义数据源并把它们映射到预定义的句柄，句柄反过来处理数据源并将事件的数据存储到数据库中以备将来查询</li><li id="f98f" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">schema.graphql:它实际上是一个定义结构(表/实体及其关系)的DDL(数据定义语言)文件。处理程序将使用模式定义的数据结构来存储事件数据。</li><li id="6fe1" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">src/mapping.ts:一组处理程序，使用事件作为输入，处理它们，然后将它们存储到schema定义的数据结构中。</li></ul><p id="2d33" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">由于OpenZeppelin也为我们提供了它们预定义的子图，所以直接使用它们会比从头开始构建方便得多。要使用<a class="ae lc" href="https://docs.openzeppelin.com/subgraphs/0.1.x/" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin子图</a>,我们首先需要安装它</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="46b7" class="na ir ht mr b fv nt nu l nv nw">$npm install <a class="ae lc" href="https://www.npmjs.com/package/@openzeppelin/subgraphs" rel="noopener ugc nofollow" target="_blank">@openzeppelin/subgraphs</a></span></pre><p id="cce0" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">然后我们需要创建一个erc20.json配置文件</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="7ec6" class="na ir ht mr b fv nt nu l nv nw">{</span><span id="f829" class="na ir ht mr b fv nx nu l nv nw">   "output": "generated/openzeppelin.erc20.",</span><span id="7e88" class="na ir ht mr b fv nx nu l nv nw">   "chain": "mainnet",</span><span id="7ea6" class="na ir ht mr b fv nx nu l nv nw">   "datasources": [</span><span id="b47a" class="na ir ht mr b fv nx nu l nv nw">    { <br/>    "address": "0xfDD1b55448da925abD960dF489d675616A7Ec301", <br/>    "module": [ "erc20",  "ownable"] }</span><span id="2a9d" class="na ir ht mr b fv nx nu l nv nw">   ]</span><span id="66e5" class="na ir ht mr b fv nx nu l nv nw">}</span></pre><p id="1419" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">请注意</p><ul class=""><li id="3e62" class="li lj ht jq b jr ld jv le jz lk kd ll kh lm kl ln lo lp lq dt translated">地址是部署的合同地址</li><li id="b11a" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">保持链为<code class="eh mo mp mq mr b">mainnet</code></li><li id="360a" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">我们重用由<code class="eh mo mp mq mr b">graph init</code>创建的<code class="eh mo mp mq mr b">generated</code>文件夹，并将生成文件的前缀定义为<code class="eh mo mp mq mr b">openzeppelin.erc20.</code></li><li id="0272" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">由于我们的合同使用了来自OpenZeppelin的ERC20.sol和Ownable.sol，在<code class="eh mo mp mq mr b">module</code>中指出它们就足够了</li></ul><p id="5081" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">使用以下命令为OpenZeppelin契约生成了模式和子图</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="a22f" class="na ir ht mr b fv nt nu l nv nw">npx graph-compiler --config erc20.json <br/>--include node_modules/@openzeppelin/subgraphs/src/datasources<br/>--export-schema <br/>--export-subgraph</span></pre><p id="702c" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">该命令将导出<code class="eh mo mp mq mr b">generated</code>文件夹中ERC20.sol和Ownable.sol所需的schema和子图。我们复制那些生成的文件的所有内容来替换由<code class="eh mo mp mq mr b">graph init</code>提供的文件的内容:</p><ul class=""><li id="1f76" class="li lj ht jq b jr ld jv le jz lk kd ll kh lm kl ln lo lp lq dt translated">schema.graphql</li></ul><figure class="kn ko kp kq fq kr"><div class="bz el l di"><div class="nz oa l"/></div></figure><ul class=""><li id="3e08" class="li lj ht jq b jr ld jv le jz lk kd ll kh lm kl ln lo lp lq dt translated">subgraph.yaml</li></ul><figure class="kn ko kp kq fq kr"><div class="bz el l di"><div class="nz oa l"/></div></figure><p id="6fc5" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">可以看出，已经定义了3个数据源，其中2个由OpenZeppelin处理。我们只使用在<code class="eh mo mp mq mr b">mapping.ts</code>中定义的处理程序<code class="eh mo mp mq mr b">handleNameChanged</code>来处理我们的自定义事件<code class="eh mo mp mq mr b">NameChaned</code>:</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="44c4" class="na ir ht mr b fv nt nu l nv nw">import { BigInt } from "@graphprotocol/graph-ts"</span><span id="ab0a" class="na ir ht mr b fv nx nu l nv nw">import {</span><span id="260c" class="na ir ht mr b fv nx nu l nv nw">    NameChanged,</span><span id="f875" class="na ir ht mr b fv nx nu l nv nw">} from "../generated/MiiToken/MiiToken"</span><span id="f851" class="na ir ht mr b fv nx nu l nv nw">import { TokenName } from "../generated/schema"</span><span id="1a07" class="na ir ht mr b fv nx nu l nv nw">export function handleNameChanged(event: NameChanged): void {</span><span id="fe41" class="na ir ht mr b fv nx nu l nv nw">    let tokenName = TokenName.load(event.transaction.from.toHex())</span><span id="c3bd" class="na ir ht mr b fv nx nu l nv nw">    if (tokenName == null) {</span><span id="96bc" class="na ir ht mr b fv nx nu l nv nw">    // create if doesn't exist yet</span><span id="caa3" class="na ir ht mr b fv nx nu l nv nw">      tokenName = new TokenName(event.transaction.from.toHex());</span><span id="17dd" class="na ir ht mr b fv nx nu l nv nw">      tokenName.name = event.params.newName;</span><span id="1e52" class="na ir ht mr b fv nx nu l nv nw">      tokenName.owner = event.params.by.toHex();</span><span id="a8c9" class="na ir ht mr b fv nx nu l nv nw">    }</span><span id="cf5d" class="na ir ht mr b fv nx nu l nv nw">    tokenName.name = event.params.newName;</span><span id="f275" class="na ir ht mr b fv nx nu l nv nw">    tokenName.save();</span><span id="2a41" class="na ir ht mr b fv nx nu l nv nw">}</span></pre><p id="61ca" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">你必须立即注意到<code class="eh mo mp mq mr b">TokenName</code>直到现在还没有定义。什么是<code class="eh mo mp mq mr b">TokenName</code>？如前所述，处理程序从发出的事件<code class="eh mo mp mq mr b">NameChanged</code>中提取信息，然后将信息存储到一个表/实体中。我们需要一个名为<code class="eh mo mp mq mr b">TokenName</code>的实体来存储事件信息，但是到目前为止我们还没有定义它，所以让我们打开schema.graphql文件并添加以下内容</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="6abc" class="na ir ht mr b fv nt nu l nv nw">type TokenName @entity {</span><span id="2f6b" class="na ir ht mr b fv nx nu l nv nw">   id: ID!</span><span id="8321" class="na ir ht mr b fv nx nu l nv nw">   name: String</span><span id="57b8" class="na ir ht mr b fv nx nu l nv nw">   owner: Account!</span><span id="6d61" class="na ir ht mr b fv nx nu l nv nw">}</span></pre><p id="f3c7" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">现在一切都清楚了，SubGraph将从事件中提取信息并存储在schema定义的实体中，这种映射在subgraph.yaml中定义:</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="80dd" class="na ir ht mr b fv nt nu l nv nw">dataSources:</span><span id="06cb" class="na ir ht mr b fv nx nu l nv nw">- kind: ethereum</span><span id="fb66" class="na ir ht mr b fv nx nu l nv nw">   name: MiiToken</span><span id="5536" class="na ir ht mr b fv nx nu l nv nw">   network: mainnet</span><span id="2858" class="na ir ht mr b fv nx nu l nv nw">   source:</span><span id="a0e6" class="na ir ht mr b fv nx nu l nv nw">      address: "0xfDD1b55448da925abD960dF489d675616A7Ec301"</span><span id="6580" class="na ir ht mr b fv nx nu l nv nw">      abi: MiiToken</span><span id="dcbf" class="na ir ht mr b fv nx nu l nv nw">   mapping:</span><span id="9136" class="na ir ht mr b fv nx nu l nv nw">      kind: ethereum/events</span><span id="ec2c" class="na ir ht mr b fv nx nu l nv nw">      apiVersion: 0.0.5</span><span id="bf82" class="na ir ht mr b fv nx nu l nv nw">      language: wasm/assemblyscript</span><span id="8cf2" class="na ir ht mr b fv nx nu l nv nw">      entities:</span><span id="0055" class="na ir ht mr b fv nx nu l nv nw">         - NameChanged</span><span id="c8ff" class="na ir ht mr b fv nx nu l nv nw">      abis:</span><span id="64b6" class="na ir ht mr b fv nx nu l nv nw">         - name: MiiToken</span><span id="16b8" class="na ir ht mr b fv nx nu l nv nw">         file: ./abis/MiiToken.json</span><span id="5a15" class="na ir ht mr b fv nx nu l nv nw">      eventHandlers:</span><span id="9710" class="na ir ht mr b fv nx nu l nv nw">         - event: NameChanged(string,address)</span><span id="ef76" class="na ir ht mr b fv nx nu l nv nw">         handler: handleNameChanged</span><span id="1aff" class="na ir ht mr b fv nx nu l nv nw">      file: ./src/mapping.ts</span></pre><p id="f7dc" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">是时候将我们的子图部署到本地图节点了</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="9e96" class="na ir ht mr b fv nt nu l nv nw">$npm run codegen   // &lt;- Generate the file for sub-graph<br/>$npm run build     // &lt;- Build SubGraph<br/>$npm run create-local  // &lt;- Create API info on graph local<br/>$npm run deploy-local  // &lt;- Deploy to local graph node</span></pre><p id="ca3e" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">成功部署将为我们提供2个端点用于前端:</p><ul class=""><li id="5e3f" class="li lj ht jq b jr ld jv le jz lk kd ll kh lm kl ln lo lp lq dt translated">HTTP端点</li><li id="c1cd" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated">订阅端点</li></ul><figure class="kn ko kp kq fq kr fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff ob"><img src="../Images/28af11ade6da75e5770614fe95abf909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WcJ_VYx484XoAJvcPpedLA.png"/></div></div><figcaption class="ky kz fg fe ff la lb bd b be z ek">HTTP endpoint testing</figcaption></figure><p id="b136" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">※跟随OpenZeppelin教程测试其他赛事:<a class="ae lc" href="https://docs.openzeppelin.com/subgraphs/0.1.x/" rel="noopener ugc nofollow" target="_blank">https://docs.openzeppelin.com/subgraphs/0.1.x/</a></p><p id="df4b" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated"><strong class="jq hu"> 5。玩前端</strong></p><p id="8f84" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">我们可以用Apollo客户端玩前端。在Vue根文件夹中运行以下命令来安装必要的库</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="8391" class="na ir ht mr b fv nt nu l nv nw">$npm install vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag</span></pre><p id="3c97" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">在main.js中:</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="97a7" class="na ir ht mr b fv nt nu l nv nw"><strong class="mr hu">import VueApollo from 'vue-apollo'</strong></span><span id="3fd6" class="na ir ht mr b fv nx nu l nv nw"><strong class="mr hu">import ApolloClient from 'apollo-boost'</strong></span><span id="e4ef" class="na ir ht mr b fv nx nu l nv nw"><strong class="mr hu">Vue.use(VueApollo)</strong></span><span id="49f6" class="na ir ht mr b fv nx nu l nv nw"><strong class="mr hu">const apolloClient = new ApolloClient({</strong></span><span id="6126" class="na ir ht mr b fv nx nu l nv nw"><strong class="mr hu">// You should use an absolute URL here</strong></span><span id="3054" class="na ir ht mr b fv nx nu l nv nw"><strong class="mr hu">   uri: 'http://localhost:8000/subgraphs/name/mit'</strong></span><span id="2863" class="na ir ht mr b fv nx nu l nv nw"><strong class="mr hu">})</strong></span><span id="8737" class="na ir ht mr b fv nx nu l nv nw"><strong class="mr hu">const apolloProvider = new VueApollo({</strong></span><span id="91a8" class="na ir ht mr b fv nx nu l nv nw"><strong class="mr hu">    defaultClient: apolloClient,</strong></span><span id="17ce" class="na ir ht mr b fv nx nu l nv nw"><strong class="mr hu">})</strong></span><span id="d892" class="na ir ht mr b fv nx nu l nv nw">new Vue({</span><span id="641f" class="na ir ht mr b fv nx nu l nv nw">   router,</span><span id="502b" class="na ir ht mr b fv nx nu l nv nw"><strong class="mr hu">   apolloProvider</strong>,</span><span id="5b3d" class="na ir ht mr b fv nx nu l nv nw">   render: h =&gt; h(App),</span><span id="557c" class="na ir ht mr b fv nx nu l nv nw">}).$mount('#app')</span></pre><p id="6103" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">在HelloWorld.vue中，我们尝试进行查询以从TokenName实体获取数据列表，并将其打印出来:</p><pre class="kn ko kp kq fq np mr nq nr aw ns dt"><span id="9d7a" class="na ir ht mr b fv nt nu l nv nw">&lt;template&gt;</span><span id="0261" class="na ir ht mr b fv nx nu l nv nw">&lt;div class="hello"&gt;</span><span id="3857" class="na ir ht mr b fv nx nu l nv nw">   &lt;h1&gt;Token Name&lt;/h1&gt;</span><span id="eda6" class="na ir ht mr b fv nx nu l nv nw">   &lt;div v-if="tokenNames"&gt;</span><span id="45bd" class="na ir ht mr b fv nx nu l nv nw">       &lt;ul v-for="item in tokenNames" :key="item.id"&gt;</span><span id="aca1" class="na ir ht mr b fv nx nu l nv nw">          &lt;li&gt;</span><span id="e7c5" class="na ir ht mr b fv nx nu l nv nw">               {{item.name}}</span><span id="fb8e" class="na ir ht mr b fv nx nu l nv nw">          &lt;/li&gt;</span><span id="0bb4" class="na ir ht mr b fv nx nu l nv nw">      &lt;/ul&gt;</span><span id="107c" class="na ir ht mr b fv nx nu l nv nw">    &lt;/div&gt;</span><span id="c3f5" class="na ir ht mr b fv nx nu l nv nw">&lt;/div&gt;</span><span id="b80b" class="na ir ht mr b fv nx nu l nv nw">&lt;/template&gt;</span><span id="9093" class="na ir ht mr b fv nx nu l nv nw">&lt;script&gt;</span><span id="a8b2" class="na ir ht mr b fv nx nu l nv nw">import gql from 'graphql-tag'</span><span id="3368" class="na ir ht mr b fv nx nu l nv nw">export default {</span><span id="8612" class="na ir ht mr b fv nx nu l nv nw">name: 'HelloWorld',</span><span id="7091" class="na ir ht mr b fv nx nu l nv nw">data () {</span><span id="6919" class="na ir ht mr b fv nx nu l nv nw">    return {</span><span id="fb41" class="na ir ht mr b fv nx nu l nv nw">       // Initialize your apollo data</span><span id="3ce2" class="na ir ht mr b fv nx nu l nv nw">       tokenNames: [],</span><span id="6753" class="na ir ht mr b fv nx nu l nv nw">    }</span><span id="affa" class="na ir ht mr b fv nx nu l nv nw">},</span><span id="8112" class="na ir ht mr b fv nx nu l nv nw">apollo: {</span><span id="7b88" class="na ir ht mr b fv nx nu l nv nw">    // Simple query that will update the 'hello' vue property</span><span id="2699" class="na ir ht mr b fv nx nu l nv nw">    tokenNames: gql`query getTokenNames{</span><span id="0090" class="na ir ht mr b fv nx nu l nv nw">            tokenNames{</span><span id="c435" class="na ir ht mr b fv nx nu l nv nw">               id,</span><span id="c347" class="na ir ht mr b fv nx nu l nv nw">               name</span><span id="0bca" class="na ir ht mr b fv nx nu l nv nw">            }</span><span id="aa7f" class="na ir ht mr b fv nx nu l nv nw">         }`,</span><span id="98a6" class="na ir ht mr b fv nx nu l nv nw">    },</span><span id="019a" class="na ir ht mr b fv nx nu l nv nw">}</span><span id="29dc" class="na ir ht mr b fv nx nu l nv nw">&lt;/script&gt;</span></pre><p id="c88a" class="pw-post-body-paragraph jo jp ht jq b jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl hm dt translated">结果看起来有点难看，但对于演示来说已经足够了</p><figure class="kn ko kp kq fq kr fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff ob"><img src="../Images/a460e51eb0be81cbeba6f3d51659b033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Bmm_thoXq3_lGpB6gIBxg.png"/></div></div></figure><h1 id="527d" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">结束</h1><p id="0a1f" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">这是一个漫长…的结束。故事。我将离开几个星期。</p><blockquote class="oc"><p id="cd39" class="od oe ht bd of og oh oi oj ok ol kl ek translated">加入Coinmonks <a class="ae lc" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae lc" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="7c22" class="iq ir ht bd is it iu iv iw ix iy iz ja jb om jd je jf on jh ji jj oo jl jm jn dt translated">另外，阅读</h1><ul class=""><li id="3c2d" class="li lj ht jq b jr js jv jw jz op kd oq kh or kl ln lo lp lq dt translated"><a class="ae lc" href="https://coincodecap.com/crypto-exchanges-in-germany" rel="noopener ugc nofollow" target="_blank">德国最佳加密交易所</a> | <a class="ae lc" href="https://coincodecap.com/arbitrum" rel="noopener ugc nofollow" target="_blank"> Arbitrum:第二层解决方案</a></li><li id="c096" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated"><a class="ae lc" rel="noopener" href="/coinmonks/binance-trading-bots-d0d57bb62c4c">币安交易机器人</a> | <a class="ae lc" rel="noopener" href="/coinmonks/okex-review-6b369304110f"> OKEx审查</a> | <a class="ae lc" href="https://coincodecap.com/atani-review" rel="noopener ugc nofollow" target="_blank">阿塔尼审查</a></li><li id="3f9f" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated"><a class="ae lc" rel="noopener" href="/coinmonks/best-crypto-signals-telegram-5785cdbc4b2b">最佳加密交易信号电报</a> | <a class="ae lc" rel="noopener" href="/coinmonks/moonxbt-review-6e4ab26d037"> MoonXBT评论</a></li><li id="4c0e" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated"><a class="ae lc" href="https://coincodecap.com/buy-shiba-bitbns" rel="noopener ugc nofollow" target="_blank">如何在Bitbns上购买柴犬(SHIB)币？</a> | <a class="ae lc" href="https://coincodecap.com/buy-floki-inu-token" rel="noopener ugc nofollow" target="_blank">购买Floki </a></li><li id="1807" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated"><a class="ae lc" href="https://coincodecap.com/coinflex-review" rel="noopener ugc nofollow" target="_blank"> CoinFLEX评论</a> | <a class="ae lc" href="https://coincodecap.com/aex-exchange-review" rel="noopener ugc nofollow" target="_blank"> AEX交易所评论</a> | <a class="ae lc" href="https://coincodecap.com/upbit-review" rel="noopener ugc nofollow" target="_blank"> UPbit评论</a></li><li id="f895" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated"><a class="ae lc" href="https://coincodecap.com/best-cryptocurrency-blogs" rel="noopener ugc nofollow" target="_blank">十大最佳加密货币博客</a> | <a class="ae lc" href="https://coincodecap.com/youhodler-review" rel="noopener ugc nofollow" target="_blank"> YouHodler评论</a></li></ul></div></div>    
</body>
</html>