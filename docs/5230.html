<html>
<head>
<title>Solidity — Storage vs Memory vs Calldata</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚固性—存储与内存对比呼叫数据</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-storage-vs-memory-vs-calldata-8c7e8c38bce?source=collection_archive---------0-----------------------#2022-04-20">https://medium.com/coinmonks/solidity-storage-vs-memory-vs-calldata-8c7e8c38bce?source=collection_archive---------0-----------------------#2022-04-20</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/e1da9cc1e185108bcb1a3b48f81bbdec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ILxMCcLWMWQ4VMjstcC7wg.jpeg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Photo by <a class="ae jf" href="https://unsplash.com/@steve_j?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Steve Johnson</a> on <a class="ae jf" href="https://unsplash.com/s/photos/storage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5a91" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">无论何时，当您在Solidity中编写智能合同时，您必须了解EVM是如何处理您的变量和数据的。您所做的选择将影响天然气成本(调用您的功能或部署您的合同)以及存储布局。</p><p id="c068" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">考虑到Ethereum中的每一个块空间都被高度重视(因此Eth的成本，尽管最近在下降)，这严重影响了您的代码和最终契约的效率，这有望被频繁调用。每个函数调用都使用气体；当总结整个函数调用的潜在寿命时，每一点节省都有帮助。</p></div><div class="ab cl ke kf hb kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hm hn ho hp hq"><h1 id="fbd7" class="kl km ht bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">储存；储备</h1><p id="a89a" class="pw-post-body-paragraph jg jh ht ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hm dt translated"><code class="eh lo lp lq lr b">Storage</code>最容易理解——所有状态变量都存储在<strong class="ji hu">中</strong>。因为状态可以在契约中改变(例如，在函数中)，所以<code class="eh lo lp lq lr b">storage</code>变量必须是可变的。但是它们的<em class="ls">位置</em>是持久的，它们保存在区块链。</p><p id="397e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh lo lp lq lr b">storage</code>中的状态变量以紧凑的方式排列——如果可能的话，多个值将占据相同的<code class="eh lo lp lq lr b">storage</code>位置。除了动态大小的数组和结构的特殊情况之外，其他变量都被打包成32字节的块。</p><p id="9da3" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果这些变量少于32字节，它们将被合并以占据同一个槽。否则，他们将被推到下一个<code class="eh lo lp lq lr b">storage</code>位置。数据按其在合同中的声明顺序，从<code class="eh lo lp lq lr b">0</code>槽(至槽<code class="eh lo lp lq lr b">1</code>、<code class="eh lo lp lq lr b">2</code>、<code class="eh lo lp lq lr b">3</code>等)开始连续存储(即一个接一个)。</p><p id="c47e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">动态数组和结构总是占据一个新的槽，并且跟随它们的任何变量也将被初始化以开始一个新的<code class="eh lo lp lq lr b">storage</code>槽。</p><p id="22e4" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">因为动态数组和结构的大小都是先验未知的(例如，直到您在契约中为它们赋值)，所以它们不能与它们的数据一起存储在其他状态变量之间。取而代之的是，假设它们占用32个字节，并且其中的元素从一个单独的<code class="eh lo lp lq lr b">storage</code>槽开始存储，该槽是使用Keccak-256哈希计算的。</p><p id="d5d9" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">但是，常量状态变量是<em class="ls">而不是</em>保存到<code class="eh lo lp lq lr b">storage</code>槽中。相反，它们被直接注入到契约字节码中——每当这些变量被读取时，契约会自动将它们切换为它们所分配的常量值。</p><h1 id="4198" class="kl km ht bd kn ko lt kq kr ks lu ku kv kw lv ky kz la lw lc ld le lx lg lh li dt translated">记忆</h1><p id="a08f" class="pw-post-body-paragraph jg jh ht ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hm dt translated"><code class="eh lo lp lq lr b"><strong class="ji hu">Memory</strong></code> <strong class="ji hu">是为函数范围内定义的变量保留的。它们只在一个函数被调用时存在，因此是临时变量，不能在这个作用域之外被访问(也就是在你的契约中除了这个函数之外的任何地方)。然而，它们在函数中是可变的。</strong></p><p id="9115" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">Solidity为<code class="eh lo lp lq lr b">memory</code>预留了4个32字节的槽位，具体字节范围由:1) 64字节的暂存空间，用于哈希方法；2) 32字节用于当前分配的<code class="eh lo lp lq lr b">memory</code>大小，这是空闲的<code class="eh lo lp lq lr b">memory</code>指针，Solidity总是在这里放置新的对象；以及3)32字节零槽——用作动态<code class="eh lo lp lq lr b">memory</code>数组的初始值，并且永远不应该被写入。</p><p id="2c35" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">由于这些布局差异，数组和结构会根据是在<code class="eh lo lp lq lr b">storage</code>还是<code class="eh lo lp lq lr b">memory</code>中而占据不同的空间。</p><h2 id="a0e6" class="ly km ht bd kn lz ma mb kr mc md me kv jr mf mg kz jv mh mi ld jz mj mk lh ml dt translated">示例:</h2><pre class="mm mn mo mp fq mq lr mr ms aw mt dt"><span id="da71" class="ly km ht lr b fv mu mv l mw mx">uint8[4] arr;</span><span id="88ed" class="ly km ht lr b fv my mv l mw mx">struct Str {<br/>    uint v1;<br/>    uint v2;<br/>    uint8 v3;<br/>    uint8 v4;<br/>}</span></pre><p id="ce77" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在这两种情况下，数组<code class="eh lo lp lq lr b">arr</code>和结构<code class="eh lo lp lq lr b">Str</code>在<code class="eh lo lp lq lr b">memory</code>中占据128个字节(即4项，每项32字节)。然而，作为<code class="eh lo lp lq lr b">storage</code>，<code class="eh lo lp lq lr b">arr</code>仅占用32字节(1个槽)，而<code class="eh lo lp lq lr b">Str</code>占用96字节(3个槽，每个槽32字节)。</p><h1 id="e20f" class="kl km ht bd kn ko lt kq kr ks lu ku kv kw lv ky kz la lw lc ld le lx lg lh li dt translated">呼叫数据</h1><p id="f946" class="pw-post-body-paragraph jg jh ht ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hm dt translated"><code class="eh lo lp lq lr b"><strong class="ji hu">Calldata</strong></code> <strong class="ji hu">是一个不可变的临时位置，用于存储函数参数，其行为很像</strong> <code class="eh lo lp lq lr b"><strong class="ji hu">memory</strong></code> <strong class="ji hu">。</strong></p><p id="4d3d" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">建议尽量使用<code class="eh lo lp lq lr b">calldata</code>，因为这样可以避免不必要的复制，确保数据不被更改。带有<code class="eh lo lp lq lr b">calldata</code>数据位置的数组和结构也可以从函数中返回。</p><p id="8892" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这种类型的数据被认为是ABI规范定义的格式，即填充到32字节的倍数(不同于内部函数调用)。构造函数的参数略有不同，因为它们直接附加在契约代码的末尾(也是ABI编码)。</p><h1 id="b16e" class="kl km ht bd kn ko lt kq kr ks lu ku kv kw lv ky kz la lw lc ld le lx lg lh li dt translated">比较</h1><p id="1de1" class="pw-post-body-paragraph jg jh ht ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hm dt translated">每当你定义一个引用类型变量(数组或结构)时，你还需要定义它的数据位置——除非它是一个状态变量，在这种情况下，它被自动解释为<code class="eh lo lp lq lr b">storage</code>。自从Solidity v0.6.9以来，<code class="eh lo lp lq lr b">memory</code>和<code class="eh lo lp lq lr b">calldata</code>在所有函数中都是允许的，而不管它们的可见性类型(即外部、公共等)。</p><p id="3951" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">赋值将导致创建副本，或者仅仅是对同一数据块的引用—类似于Javascript中的对象或数组:</p><ul class=""><li id="683d" class="mz na ht ji b jj jk jn jo jr nb jv nc jz nd kd ne nf ng nh dt translated">在<code class="eh lo lp lq lr b">storage</code>和<code class="eh lo lp lq lr b">memory</code>(或从<code class="eh lo lp lq lr b">calldata</code>)之间的分配总是创建一个单独的副本。</li><li id="f97b" class="mz na ht ji b jj ni jn nj jr nk jv nl jz nm kd ne nf ng nh dt translated">从<code class="eh lo lp lq lr b">memory</code>到<code class="eh lo lp lq lr b">memory</code>的赋值仅创建引用。因此，改变一个内存变量会改变引用相同数据的所有其他内存变量。</li><li id="5209" class="mz na ht ji b jj ni jn nj jr nk jv nl jz nm kd ne nf ng nh dt translated">从<code class="eh lo lp lq lr b">storage</code>到局部存储变量的赋值也只分配一个引用。</li><li id="37f7" class="mz na ht ji b jj ni jn nj jr nk jv nl jz nm kd ne nf ng nh dt translated">所有其他分配给<code class="eh lo lp lq lr b">storage</code>的任务总是复制。</li></ul><p id="8ffb" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">对于函数中的数组参数，建议使用<code class="eh lo lp lq lr b">calldata</code>而不是<code class="eh lo lp lq lr b">memory</code>，因为这样可以节省大量气体。例如，通过使用<code class="eh lo lp lq lr b">calldata</code>，在输入数组上循环的求和函数可以节省大约1829 gas (~3.5%)。</p><pre class="mm mn mo mp fq mq lr mr ms aw mt dt"><span id="bd68" class="ly km ht lr b fv mu mv l mw mx">// Gas used: 50992<br/>function func1 (uint[] memory nums) external {<br/>  for (uint i = 0; i &lt; nums.length; ++i) {<br/>     ...<br/>  }<br/>}</span><span id="ceb6" class="ly km ht lr b fv my mv l mw mx">// Gas used: 49163<br/>function func2 (uint[] calldata nums) external {<br/>  for (uint i = 0; i &lt; nums.length; ++i) {<br/>     ...<br/>  }<br/>}</span></pre><p id="e313" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">就这些——一些关于Solidity中数据位置的信息。感谢阅读！</p></div><div class="ab cl ke kf hb kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hm hn ho hp hq"><h2 id="ab55" class="ly km ht bd kn lz ma mb kr mc md me kv jr mf mg kz jv mh mi ld jz mj mk lh ml dt translated">参考资料:</h2><ul class=""><li id="b8d5" class="mz na ht ji b jj lj jn lk jr nn jv no jz np kd ne nf ng nh dt translated"><a class="ae jf" href="https://docs.soliditylang.org/en/v0.8.13/types.html#data-location-and-assignment-behaviour" rel="noopener ugc nofollow" target="_blank">https://docs . soliditylang . org/en/v 0 . 8 . 13/types . html # data-location-and-assignment-behavior</a></li><li id="e64e" class="mz na ht ji b jj ni jn nj jr nk jv nl jz nm kd ne nf ng nh dt translated"><a class="ae jf" href="https://docs.soliditylang.org/en/v0.8.13/types.html#reference-types" rel="noopener ugc nofollow" target="_blank">https://docs . solidy lang . org/en/v 0 . 8 . 13/types . html # reference-types</a></li><li id="2cb4" class="mz na ht ji b jj ni jn nj jr nk jv nl jz nm kd ne nf ng nh dt translated"><a class="ae jf" href="https://docs.soliditylang.org/en/v0.8.13/internals/layout_in_storage.html" rel="noopener ugc nofollow" target="_blank">https://docs . solidy lang . org/en/v 0 . 8 . 13/internals/layout _ in _ storage . html</a></li><li id="a1d2" class="mz na ht ji b jj ni jn nj jr nk jv nl jz nm kd ne nf ng nh dt translated"><a class="ae jf" href="https://twitter.com/Web3Oscar/status/1514509414501343234" rel="noopener ugc nofollow" target="_blank">https://twitter.com/Web3Oscar/status/1514509414501343234</a></li><li id="ca43" class="mz na ht ji b jj ni jn nj jr nk jv nl jz nm kd ne nf ng nh dt translated"><a class="ae jf" href="https://twitter.com/PatrickAlphaC/status/1514257121302429696" rel="noopener ugc nofollow" target="_blank">https://Twitter . com/Patrick alpha c/status/1514257121302429696</a></li></ul><blockquote class="nq"><p id="f72e" class="nr ns ht bd nt nu nv nw nx ny nz kd ek translated">加入Coinmonks <a class="ae jf" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jf" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="d86b" class="kl km ht bd kn ko lt kq kr ks lu ku kv kw oa ky kz la ob lc ld le oc lg lh li dt translated">另外，阅读</h1><ul class=""><li id="dd82" class="mz na ht ji b jj lj jn lk jr nn jv no jz np kd ne nf ng nh dt translated"><a class="ae jf" href="https://coincodecap.com/bookmap-review-2021-best-trading-software" rel="noopener ugc nofollow" target="_blank"> Bookmap点评</a> | <a class="ae jf" href="https://coincodecap.com/crypto-exchange-usa" rel="noopener ugc nofollow" target="_blank">美国5大最佳加密交易所</a></li><li id="c68e" class="mz na ht ji b jj ni jn nj jr nk jv nl jz nm kd ne nf ng nh dt translated">最佳加密<a class="ae jf" rel="noopener" href="/coinmonks/hardware-wallets-dfa1211730c6">硬件钱包</a> | <a class="ae jf" rel="noopener" href="/coinmonks/bitbns-review-38256a07e161"> Bitbns评论</a></li><li id="30fa" class="mz na ht ji b jj ni jn nj jr nk jv nl jz nm kd ne nf ng nh dt translated"><a class="ae jf" href="https://coincodecap.com/crypto-exchange-in-singapore" rel="noopener ugc nofollow" target="_blank">新加坡十大最佳加密交易所</a> | <a class="ae jf" href="https://coincodecap.com/buy-axs-token" rel="noopener ugc nofollow" target="_blank">购买AXS </a></li><li id="f729" class="mz na ht ji b jj ni jn nj jr nk jv nl jz nm kd ne nf ng nh dt translated"><a class="ae jf" href="https://coincodecap.com/red-dog-casino-review" rel="noopener ugc nofollow" target="_blank">红狗赌场评论</a> | <a class="ae jf" href="https://coincodecap.com/swyftx-review" rel="noopener ugc nofollow" target="_blank"> Swyftx评论</a> | <a class="ae jf" href="https://coincodecap.com/coingate-review" rel="noopener ugc nofollow" target="_blank"> CoinGate评论</a></li><li id="b0b8" class="mz na ht ji b jj ni jn nj jr nk jv nl jz nm kd ne nf ng nh dt translated"><a class="ae jf" href="https://coincodecap.com/best-crypto-to-invest-in-india-in-2021" rel="noopener ugc nofollow" target="_blank">投资印度的最佳密码</a>|<a class="ae jf" href="https://coincodecap.com/wazirx-p2p" rel="noopener ugc nofollow" target="_blank">WazirX P2P</a>|<a class="ae jf" href="https://coincodecap.com/hi-dollar-review" rel="noopener ugc nofollow" target="_blank">Hi Dollar Review</a></li></ul></div></div>    
</body>
</html>