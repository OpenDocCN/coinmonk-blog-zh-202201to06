<html>
<head>
<title>Create NFTs on NEAR Protocol Using Rust — KryptoMind</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Rust-KryptoMind在NEAR协议上创建NFT</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/create-nfts-on-near-protocol-using-rust-kryptomind-c30e42ced86d?source=collection_archive---------43-----------------------#2022-06-28">https://medium.com/coinmonks/create-nfts-on-near-protocol-using-rust-kryptomind-c30e42ced86d?source=collection_archive---------43-----------------------#2022-06-28</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/e0742aa850f571c505d2895fc7dbb02f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yr-Sy3xIp5XwW_z4nNFrag.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">NEAR Protocol</figcaption></figure><h1 id="3b6d" class="jf jg ht bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dt translated">介绍</h1><p id="dd97" class="pw-post-body-paragraph kd ke ht kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hm dt translated">在区块链上，不可替代的代币充当独特的所有权记录。NFT通常与一件有价值且不常见的物品相关联，例如一件艺术品、一张演出门票、一只可收藏的猫、一个主机名或一个真实的实体。根据合同的不同，可以铸造、购买、出售或销毁NFT。基于以太坊的NFT是非常罕见的。NFTs可以在NEAR上实现。</p><blockquote class="lb lc ld"><p id="6d2c" class="kd ke le kf b kg lf ki kj kk lg km kn lh li kq kr lj lk ku kv ll lm ky kz la hm dt translated">交易新手？试试<a class="ae ln" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae ln" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote><p id="e18e" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn ko li kq kr ks lk ku kv kw lm ky kz la hm dt translated">关于NFTs有很多规则！但是到目前为止，最流行的是ERC721标准，它描述了诸如如何开发和传输NFT之类的东西。这持续了很长时间，但是像所有的ERC标准一样，它只是为以太坊平台定义的。一旦近EVM仿真准备就绪，ERC721就可以移植到NEAR。尽管如此，目前NEAR团队已经实现了一个NFT参考实现，它需要一个不同的NFT标准:NEP-4，它以一种独立于语言的方式进行描述</p><h1 id="227d" class="jf jg ht bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dt translated">近似协议</h1><p id="6ad5" class="pw-post-body-paragraph kd ke ht kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hm dt translated">NEAR协议是新一代第一层区块链，它解决了吞吐量有限、事务速率慢和兼容性差等问题。它是基于分片的，这意味着当网络使用率高时，节点被分成更小的称为“分片”的部分，计算在这些部分之间并行进行。该网络可以扩展以满足更多用户的需求。</p><h1 id="032d" class="jf jg ht bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dt translated">什么是NEP -4？</h1><p id="b9a7" class="pw-post-body-paragraph kd ke ht kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hm dt translated">NEP-4是一个非常简单的标准，它只支持NFT的所有权和转让。但是，它确实包括向其他用户或其他智能合同授权的能力。这是一个强大的功能，因为它意味着未来可以通过使用智能合约进行跨合约调用来进行改进，而不是升级我们今天编写的合约。NEAR上的其他NFT项目已经开始帮助NEP-4，所以短期内这是一个不错的选择。</p><p id="18b8" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn ko li kq kr ks lk ku kv kw lm ky kz la hm dt translated">本教程将向您展示如何为Near协议构建一个智能契约，以创建NFTs。</p><h1 id="c045" class="jf jg ht bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dt translated">先决条件</h1><p id="c9d0" class="pw-post-body-paragraph kd ke ht kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hm dt translated">来建立我们需要的近乎智能的契约。</p><h2 id="cc0c" class="lo jg ht bd jh lp lq lr jl ls lt lu jp ko lv lw jt ks lx ly jx kw lz ma kb mb dt translated">生锈:</h2><p id="eca7" class="pw-post-body-paragraph kd ke ht kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hm dt translated">我们将使用Rust的高性能通用编程语言开发一个智能合约。</p><h2 id="c9b7" class="lo jg ht bd jh lp lq lr jl ls lt lu jp ko lv lw jt ks lx ly jx kw lz ma kb mb dt translated">接近CLI:</h2><p id="ed02" class="pw-post-body-paragraph kd ke ht kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hm dt translated">使用Near CLI命令行界面连接到Near区块链并与之交互。</p><h2 id="4c59" class="lo jg ht bd jh lp lq lr jl ls lt lu jp ko lv lw jt ks lx ly jx kw lz ma kb mb dt translated">附近的钱包:</h2><p id="48d5" class="pw-post-body-paragraph kd ke ht kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hm dt translated">在开始我们的项目之前，我们需要一个近钱包。</p><h2 id="7637" class="lo jg ht bd jh lp lq lr jl ls lt lu jp ko lv lw jt ks lx ly jx kw lz ma kb mb dt translated">设置</h2><p id="886b" class="pw-post-body-paragraph kd ke ht kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la hm dt translated">首先，创建一个货物项目。</p><pre class="mc md me mf fq mg mh mi mj aw mk dt"><span id="d532" class="lo jg ht mh b fv ml mm l mn mo">cargo new nft --lib</span></pre><p id="0244" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn ko li kq kr ks lk ku kv kw lm ky kz la hm dt translated">转到项目文件夹nft你会看到。</p><p id="3987" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn ko li kq kr ks lk ku kv kw lm ky kz la hm dt translated">src/lib.rs —这是我们将要编写智能契约的地方</p><p id="c856" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn ko li kq kr ks lk ku kv kw lm ky kz la hm dt translated">Cargo.toml —这是我们的项目配置文件</p><p id="51e5" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn ko li kq kr ks lk ku kv kw lm ky kz la hm dt translated">转到cargo.toml并添加</p><pre class="mc md me mf fq mg mh mi mj aw mk dt"><span id="5980" class="lo jg ht mh b fv ml mm l mn mo">[lib]<br/>crate-type = ["cdylib", "rlib"]<br/>[dependencies]<br/>near-sdk = "*"<br/>near-contract-standards = "*"</span></pre><h1 id="d842" class="jf jg ht bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc dt translated">入门指南</h1><pre class="mc md me mf fq mg mh mi mj aw mk dt"><span id="b555" class="lo jg ht mh b fv ml mm l mn mo">use near_sdk::{<br/>    near_bindgen,<br/>    borsh::{self, BorshDeserialize, BorshSerialize}<br/>};<br/>near_sdk::setup_alloc!();<br/>#[near_bindgen]<br/>#[derive(BorshDeserialize, BorshDeserialize)]<br/>pub struct Contract {}<br/>#[near_bindgen]<br/>impl Contract {}</span></pre><p id="a105" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn ko li kq kr ks lk ku kv kw lm ky kz la hm dt translated">让我们简化这个看起来很奇怪的代码，而不采取任何行动。因为NEAR采用了有状态方法，所以我们的契约状态将保存在struct Contract中，并且我们将在实现契约中编写状态改变方法。</p><p id="308a" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn ko li kq kr ks lk ku kv kw lm ky kz la hm dt translated">应该注意的是，在这种情况下，我们使用特定的宏和派生特征。使用#[near bindgen]宏改变状态，以便它可以在近链上活动。Borsh crate中用于反序列化和序列化状态的特性是BorshDeserialize和BorshDeserialize。</p><p id="28d5" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn ko li kq kr ks lk ku kv kw lm ky kz la hm dt translated">让我们现在指定我们的国家为NFT。你知道NFT有一些附加的元数据。根据这个描述，我们的状态出现如下。</p><pre class="mc md me mf fq mg mh mi mj aw mk dt"><span id="c151" class="lo jg ht mh b fv ml mm l mn mo">use near_contract_standards::non_fungible_token::{<br/>    metadata::NFTContractMetadata, NonFungibleToken,<br/>};<br/>pub struct Contract {<br/>    token: NonFungibleToken,<br/>    metadata: LazyOption&lt;NFTContractMetadata&gt;,<br/>}</span></pre><p id="ec67" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn ko li kq kr ks lk ku kv kw lm ky kz la hm dt translated">必须始终设置此状态的默认值；因此需要一个初始化函数。</p><pre class="mc md me mf fq mg mh mi mj aw mk dt"><span id="d72d" class="lo jg ht mh b fv ml mm l mn mo">#[derive(BorshSerialize, BorshStorageKey)]<br/>pub enum StorageKey {<br/>    NonFungibleToken,<br/>    Metadata,<br/>    TokenMetadata,<br/>    Enumeration,<br/>    Approval<br/>}<br/>#[near_bindgen]<br/>impl Contract {<br/>    #[init]<br/>    pub fn new(owner_id: ValidAccountId) -&gt; Self {<br/>        Self {<br/>            token: NonFungibleToken::new(<br/>                StorageKey::NonFungibleToken,<br/>                owner_id,<br/>                Some(StorageKey::TokenMetadata),<br/>                Some(StorageKey::Enumeration),<br/>                Some(StorageKey::Approval)<br/>             ),<br/>             metadata: LazyOption::new(<br/>                StorageKey::Metadata,<br/>                Some(&amp;NFTContractMetadata {<br/>                    spec: NFT_METADATA_SPEC.to_string(),<br/>                    name: "Example Name".to_string(),<br/>                    symbol: "Example".to_string(),<br/>                    icon: Some("ANY_SVG".to_string()),<br/>                    base_uri: None,<br/>                    reference: None,<br/>                    reference_hash: None,<br/>                 })<br/>             ),<br/>        }<br/>    }<br/>}</span></pre><p id="f0b1" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn ko li kq kr ks lk ku kv kw lm ky kz la hm dt translated">#[init]启用宏的函数将总是首先运行。它通常用于建立默认状态。</p><p id="65ba" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn ko li kq kr ks lk ku kv kw lm ky kz la hm dt translated">我们的初始化器和状态的一切都已经建立了。让我们实现功能NFT铸造。</p><pre class="mc md me mf fq mg mh mi mj aw mk dt"><span id="d45a" class="lo jg ht mh b fv ml mm l mn mo">impl Contract {<br/>    <br/>    ......<br/>    <br/>    #[payable]    <br/>    pub fn nft_mint(<br/>        &amp;mut self,<br/>        token_id: TokenId,<br/>        receiver_id: ValidAccountId,<br/>        token_metadata: TokenMetadata,<br/>    ) -&gt; Token {<br/>        self.token.mint(token_id, receiver_id, Some(token_metadata))<br/>    }<br/>}</span></pre><p id="8aa6" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn ko li kq kr ks lk ku kv kw lm ky kz la hm dt translated">这应该部署到链中。要进行构建，请输入以下命令:</p><pre class="mc md me mf fq mg mh mi mj aw mk dt"><span id="4cc3" class="lo jg ht mh b fv ml mm l mn mo">cargo build --target wasm32-unknown-unknown --release</span></pre><p id="4542" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn ko li kq kr ks lk ku kv kw lm ky kz la hm dt translated">运行以下命令进行部署</p><pre class="mc md me mf fq mg mh mi mj aw mk dt"><span id="c62b" class="lo jg ht mh b fv ml mm l mn mo">near deploy --wasmFile target/wasm32-unknown-unknown/release/nft.wasm --accountId "your near account username"</span></pre><p id="ae5f" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn ko li kq kr ks lk ku kv kw lm ky kz la hm dt translated">这将为您提供一个程序id，您可以使用它来访问智能合同的RPC。您可以使用附近的CLI或javascript客户端与合同进行通信。</p><p id="c769" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn ko li kq kr ks lk ku kv kw lm ky kz la hm dt translated">Kryptomind是一家总部位于美国的NFT铸造公司，已经为其客户完成了几个盈利的NFT项目。为了获得最出色的成果，我们的工作方法采用了最新的技术和方法。我们希望尽可能简化铸造NFT的复杂过程。在Kryptomind，我们忠诚的专家团队努力满足您的目标和要求。</p></div><div class="ab cl mp mq hb mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hm hn ho hp hq"><p id="3554" class="pw-post-body-paragraph kd ke ht kf b kg lf ki kj kk lg km kn ko li kq kr ks lk ku kv kw lm ky kz la hm dt translated"><em class="le">原载于2022年6月28日</em><a class="ae ln" href="https://kryptomind.com/create-nfts-on-near-protocol-using-rust/" rel="noopener ugc nofollow" target="_blank"><em class="le">【https://kryptomind.com】</em></a><em class="le">。</em></p></div></div>    
</body>
</html>