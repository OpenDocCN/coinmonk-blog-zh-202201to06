<html>
<head>
<title>Storage Variable Clashing in StarkNet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">StarkNet中的存储变量冲突</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/storage-variable-clashing-in-starknet-ce5f28e60886?source=collection_archive---------4-----------------------#2022-04-26">https://medium.com/coinmonks/storage-variable-clashing-in-starknet-ce5f28e60886?source=collection_archive---------4-----------------------#2022-04-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="68af" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">StarkNet智能合同和最佳预防实践如何导致存储冲突</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/7b6253f9ec60f45251110b09537d331c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ERFEPOMO5K-vXBR8OwDlyA.png"/></div></div></figure><h2 id="2bda" class="ju jv ht bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">🗄️:仓库是如何处理的？</h2><p id="3774" class="pw-post-body-paragraph ks kt ht ku b kv kw iu kx ky kz ix la kf lb lc ld kj le lf lg kn lh li lj lk hm dt translated">StarkNet上的合同存储通过简单的键/值对来处理。根据<a class="ae ll" href="https://starknet.io/documentation/contracts/#contracts_storage" rel="noopener ugc nofollow" target="_blank"> StarkNet文档:</a></p><blockquote class="lm ln lo"><p id="e6cc" class="ks kt lp ku b kv lq iu kx ky lr ix la ls lt lc ld lu lv lf lg lw lx li lj lk hm dt translated"><strong class="ku hu">存储布局</strong></p><p id="7c9a" class="ks kt lp ku b kv lq iu kx ky lr ix la ls lt lc ld lu lv lf lg lw lx li lj lk hm dt translated">协定存储是一个持久性存储空间，您可以在其中读取、写入、修改和保存数据。存储是一个具有2个⁵槽的映射，其中每个槽是一个毛毡，并被初始化为0。</p><p id="54ce" class="ks kt lp ku b kv lq iu kx ky lr ix la ls lt lc ld lu lv lf lg lw lx li lj lk hm dt translated"><strong class="ku hu">存储基本功能</strong></p><p id="4cd2" class="ks kt lp ku b kv lq iu kx ky lr ix la ls lt lc ld lu lv lf lg lw lx li lj lk hm dt translated">读取存储的基本函数返回存储在<code class="eh ly lz ma mb b">key</code>中的<code class="eh ly lz ma mb b">value</code></p><p id="37a0" class="ks kt lp ku b kv lq iu kx ky lr ix la ls lt lc ld lu lv lf lg lw lx li lj lk hm dt translated"><code class="eh ly lz ma mb b">let (value) = storage_read(key)</code></p><p id="b270" class="ks kt lp ku b kv lq iu kx ky lr ix la ls lt lc ld lu lv lf lg lw lx li lj lk hm dt translated">写入存储器的基本功能是将<code class="eh ly lz ma mb b">value</code>写入<code class="eh ly lz ma mb b">key</code></p><p id="a0ad" class="ks kt lp ku b kv lq iu kx ky lr ix la ls lt lc ld lu lv lf lg lw lx li lj lk hm dt translated"><code class="eh ly lz ma mb b">storage_write(key, value)</code></p></blockquote><p id="7354" class="pw-post-body-paragraph ks kt ht ku b kv lq iu kx ky lr ix la kf lt lc ld kj lv lf lg kn lx li lj lk hm dt translated">用<code class="eh ly lz ma mb b">@storage_var</code>修饰的存储变量有一点复杂。StarkNet编译器将它们的名称和值(用Cairo代码)映射到StarkNet自己的<code class="eh ly lz ma mb b">sn_keccak</code>方法生成的地址(按原样或通过散列链进行嵌套映射)。然而，这里重要的一点是，存储变量被简单地视为散列的键/值对。</p><h2 id="69c0" class="ju jv ht bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">StarkNet中的合同可扩展性</h2><p id="2073" class="pw-post-body-paragraph ks kt ht ku b kv kw iu kx ky kz ix la kf lb lc ld kj le lf lg kn lh li lj lk hm dt translated">OpenZeppelin开创了<a class="ae ll" href="https://github.com/OpenZeppelin/cairo-contracts/blob/main/docs/Extensibility.md" rel="noopener ugc nofollow" target="_blank">可扩展性模式</a>，它包含了从久经考验的库中安全导入功能和状态的契约指南。基本思想是契约从库中导入和公开(用<code class="eh ly lz ma mb b">@external</code>和<code class="eh ly lz ma mb b">@view</code>decorator)它们想要使用的方法。例如，考虑流行的ERC20库。部署ERC20令牌的所有方法和状态管理都已经存在于库中。用户只需要在合同中公开必要的方法，瞧！您的合同已准备好部署。</p><blockquote class="lm ln lo"><p id="b1ad" class="ks kt lp ku b kv lq iu kx ky lr ix la ls lt lc ld lu lv lf lg lw lx li lj lk hm dt translated">库不公开它们的方法的原因是Cairo会自动导出它们，不管它们是否被导入。这可能很危险。</p></blockquote><p id="6a06" class="pw-post-body-paragraph ks kt ht ku b kv lq iu kx ky lr ix la kf lt lc ld kj lv lf lg kn lx li lj lk hm dt translated">这种模式的有趣问题是:如果库用存储变量设置自己的状态，那么当一个契约从多个共享相同存储变量名称的库导入时会发生什么？</p><h2 id="1cf9" class="ju jv ht bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">💥来自不同库的存储冲突</h2><p id="21c6" class="pw-post-body-paragraph ks kt ht ku b kv kw iu kx ky kz ix la kf lb lc ld kj le lf lg kn lh li lj lk hm dt translated">让我们来看看这两个库:</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="915c" class="pw-post-body-paragraph ks kt ht ku b kv lq iu kx ky lr ix la kf lt lc ld kj lv lf lg kn lx li lj lk hm dt translated">虽然示例方法共享相同的名称，但是它们属于它们各自的名称空间，即<code class="eh ly lz ma mb b">LIBRARY_A.increase_balance</code>和<code class="eh ly lz ma mb b">LIBRARY_B_increase_balance</code>。然而，存储变量<code class="eh ly lz ma mb b">balance</code>不包含在任何一个名称空间中。记住这一点很重要。</p><p id="f267" class="pw-post-body-paragraph ks kt ht ku b kv lq iu kx ky lr ix la kf lt lc ld kj lv lf lg kn lx li lj lk hm dt translated">现在，让我们看一个将从这些库导入并公开它们的方法的契约。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="f084" class="pw-post-body-paragraph ks kt ht ku b kv lq iu kx ky lr ix la kf lt lc ld kj lv lf lg kn lx li lj lk hm dt translated">注意，两个库的存储都没有显式地导入到契约中——只有名称空间。现在，让我们测试一下<em class="lp"> contract_c </em>的公开方法，看看库各自的存储发生了什么。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="045c" class="pw-post-body-paragraph ks kt ht ku b kv lq iu kx ky lr ix la kf lt lc ld kj lv lf lg kn lx li lj lk hm dt translated">结果是:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff me"><img src="../Images/7d6ea0b76223162cfdda33f966f71bd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UxRbIf00CqdycZVR8lCBOQ.png"/></div></div></figure><p id="774d" class="pw-post-body-paragraph ks kt ht ku b kv lq iu kx ky lr ix la kf lt lc ld kj lv lf lg kn lx li lj lk hm dt translated">等等，发生什么事了？StarkNet编译器没有<em class="lp">而不是</em>区分这两个<code class="eh ly lz ma mb b">balance</code>存储变量，尽管它们似乎“私下”属于各自的库。换句话说，编译器将两个<code class="eh ly lz ma mb b">balance</code>存储变量视为对同一个变量的引用。</p><p id="f6af" class="pw-post-body-paragraph ks kt ht ku b kv lq iu kx ky lr ix la kf lt lc ld kj lv lf lg kn lx li lj lk hm dt translated">然而，如果同名存储变量有任何不同，StarkNet编译器<em class="lp">将</em>失败。这些差异包括变量名、返回值名和键的数量。这里有一个简单的例子来说明:</p><pre class="jj jk jl jm fq mf mb mg mh aw mi dt"><span id="144e" class="ju jv ht mb b fv mj mk l ml mm"># library_a<br/>...</span><span id="cb37" class="ju jv ht mb b fv mn mk l ml mm">@storage_var<br/>func balance() -&gt; (<strong class="mb hu">res</strong>: felt):<br/>end<br/>...<br/>-----------------------------------------</span><span id="9081" class="ju jv ht mb b fv mn mk l ml mm"># library_b<br/>...</span><span id="3ce0" class="ju jv ht mb b fv mn mk l ml mm">@storage_var<br/>func balance() -&gt; (<strong class="mb hu">var</strong>: felt):<br/>end<br/>...</span></pre><p id="0f09" class="pw-post-body-paragraph ks kt ht ku b kv lq iu kx ky lr ix la kf lt lc ld kj lv lf lg kn lx li lj lk hm dt translated">如果我们如上修改<em class="lp"> library_b </em>中的返回变量名，并尝试编译<em class="lp"> contract_c </em>，编译将会失败。任何此类差异都将返回此AssertionError:</p><pre class="jj jk jl jm fq mf mb mg mh aw mi dt"><span id="194c" class="ju jv ht mb b fv mj mk l ml mm">f'Found two versions of auto-generated file "{input_file.filename}":\n'<br/>AssertionError: Found two versions of auto-generated file "autogen/starknet/storage_var/balance/impl.cairo":<br/>...</span></pre><p id="64ae" class="pw-post-body-paragraph ks kt ht ku b kv lq iu kx ky lr ix la kf lt lc ld kj lv lf lg kn lx li lj lk hm dt translated">要点:如果一个契约从多个库导入，而这些库恰好共享一个存储变量名(即<code class="eh ly lz ma mb b">balance</code>)，那么如果编译器没有捕捉到这些变量，它们很可能会发生冲突。</p><h2 id="1f88" class="ju jv ht bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">🛡 ️Prevent存储变量冲突</h2><p id="5faf" class="pw-post-body-paragraph ks kt ht ku b kv kw iu kx ky kz ix la kf lb lc ld kj le lf lg kn lh li lj lk hm dt translated">在撰写本文时，最好的解决方案是在存储变量名前加上库的名称或命名空间。比如:<code class="eh ly lz ma mb b">ERC20_balances</code>、<code class="eh ly lz ma mb b">ReentrancyGuard_start</code>、<code class="eh ly lz ma mb b">Ownable_owner</code>。</p><p id="0e24" class="pw-post-body-paragraph ks kt ht ku b kv lq iu kx ky lr ix la kf lt lc ld kj lv lf lg kn lx li lj lk hm dt translated">为了验证概念，让我们将示例库的存储变量改为<code class="eh ly lz ma mb b">LIBRARY_A_balance</code>和<code class="eh ly lz ma mb b">LIBRARY_B_balance</code>。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="fbdb" class="pw-post-body-paragraph ks kt ht ku b kv lq iu kx ky lr ix la kf lt lc ld kj lv lf lg kn lx li lj lk hm dt translated">运行完全相同的测试后，结果如下:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mo"><img src="../Images/696b3db883660a1ed4758ed6e7fa1282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJ8GgbGW2xL34oDl6RRBkQ.png"/></div></div></figure><h2 id="a592" class="ju jv ht bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">结论</h2><p id="0355" class="pw-post-body-paragraph ks kt ht ku b kv kw iu kx ky kz ix la kf lb lc ld kj le lf lg kn lh li lj lk hm dt translated">鉴于StarkNet网络和Cairo编程语言是如此新颖和先进，最佳实践将不可避免地随着现有模式和惯例的发展和新的模式和惯例的出现而改变。同时，给你的存储变量加上前缀！</p><p id="4c57" class="pw-post-body-paragraph ks kt ht ku b kv lq iu kx ky lr ix la kf lt lc ld kj lv lf lg kn lx li lj lk hm dt translated">特别感谢马丁·特里、朱丽莎·邓蒂斯和<a class="ae ll" href="https://openzeppelin.com/" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin </a>激发了这项研究。点击查看原讨论<a class="ae ll" href="https://github.com/OpenZeppelin/cairo-contracts/pull/236#discussion_r838265315" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="e83e" class="pw-post-body-paragraph ks kt ht ku b kv lq iu kx ky lr ix la kf lt lc ld kj lv lf lg kn lx li lj lk hm dt translated">有兴趣了解更多关于StarkNet和Cairo的信息吗？查看这些优秀的资源:</p><ul class=""><li id="1122" class="mp mq ht ku b kv lq ky lr kf mr kj ms kn mt lk mu mv mw mx dt translated"><a class="ae ll" href="https://www.cairo-lang.org/docs/" rel="noopener ugc nofollow" target="_blank"> StarkNet和Cairo官方文档</a></li><li id="1d67" class="mp mq ht ku b kv my ky mz kf na kj nb kn nc lk mu mv mw mx dt translated"><a class="ae ll" href="https://community.starknet.io/" rel="noopener ugc nofollow" target="_blank">斯塔克尼萨满</a></li><li id="ee3e" class="mp mq ht ku b kv my ky mz kf na kj nb kn nc lk mu mv mw mx dt translated"><a class="ae ll" href="https://blog.openzeppelin.com/getting-started-with-openzeppelin-contracts-for-cairo/" rel="noopener ugc nofollow" target="_blank">Cairo open zeppelin合同入门</a></li><li id="fc86" class="mp mq ht ku b kv my ky mz kf na kj nb kn nc lk mu mv mw mx dt translated">为了更全面的名单:<a class="ae ll" href="https://github.com/gakonst/awesome-starknet" rel="noopener ugc nofollow" target="_blank">真棒StarkNet </a></li></ul><blockquote class="nd"><p id="0201" class="ne nf ht bd ng nh ni nj nk nl nm lk ek translated">加入Coinmonks <a class="ae ll" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae ll" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="1fcb" class="nn jv ht bd jw no np nq ka nr ns nt ke iz nu ja ki jc nv jd km jf nw jg kq nx dt translated">另外，阅读</h1><ul class=""><li id="6a2a" class="mp mq ht ku b kv kw ky kz kf ny kj nz kn oa lk mu mv mw mx dt translated"><a class="ae ll" href="https://coincodecap.com/best-ethereum-wallets" rel="noopener ugc nofollow" target="_blank">最佳以太坊钱包</a> | <a class="ae ll" href="https://coincodecap.com/telegram-crypto-bots" rel="noopener ugc nofollow" target="_blank">电报上的加密货币机器人</a></li><li id="11b0" class="mp mq ht ku b kv my ky mz kf na kj nb kn nc lk mu mv mw mx dt translated">交易杠杆代币的最佳交易所 | <a class="ae ll" href="https://coincodecap.com/buy-floki-inu-token" rel="noopener ugc nofollow" target="_blank">购买弗洛基</a></li><li id="5973" class="mp mq ht ku b kv my ky mz kf na kj nb kn nc lk mu mv mw mx dt translated"><a class="ae ll" href="https://coincodecap.com/3commas-vs-pionex-vs-cryptohopper" rel="noopener ugc nofollow" target="_blank"> 3Commas对Pionex对Cryptohopper </a> | <a class="ae ll" href="https://coincodecap.com/bingbon-review" rel="noopener ugc nofollow" target="_blank"> Bingbon评论</a></li><li id="e44b" class="mp mq ht ku b kv my ky mz kf na kj nb kn nc lk mu mv mw mx dt translated"><a class="ae ll" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">加密复制交易平台</a> | <a class="ae ll" rel="noopener" href="/coinmonks/buy-bitcoin-on-wazirx-2d12b7989af1">如何在WazirX上购买比特币</a></li><li id="324b" class="mp mq ht ku b kv my ky mz kf na kj nb kn nc lk mu mv mw mx dt translated"><a class="ae ll" href="https://coincodecap.com/coinloan-review" rel="noopener ugc nofollow" target="_blank"> CoinLoan评论</a>|<a class="ae ll" rel="noopener" href="/coinmonks/crypto-com-review-f143dca1f74c">Crypto.com评论</a></li></ul></div></div>    
</body>
</html>