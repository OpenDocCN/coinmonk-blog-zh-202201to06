<html>
<head>
<title>Proxy Pattern and Upgradeable Smart Contracts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代理模式和可升级智能合约</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/proxy-pattern-and-upgradeable-smart-contracts-45d68d6f15da?source=collection_archive---------1-----------------------#2022-02-12">https://medium.com/coinmonks/proxy-pattern-and-upgradeable-smart-contracts-45d68d6f15da?source=collection_archive---------1-----------------------#2022-02-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="9402" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当智能合约被部署到以太坊区块链时，它们是不可变的，因此不可升级。然而，代码可以重新构建成不同的契约，从而允许逻辑升级，而存储保持不变。说了这么多，用户同意令牌逻辑应该是可升级的吗？</p><p id="7a50" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">不变性带来的缺点是错误不会被修复，气体优化不会被实现，现有的功能不会被改进…抛弃EVM的这个属性也是一个糟糕的解决方案，因为它会剥夺以太坊的一个核心特性。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff jo"><img src="../Images/82f5525598ffce09d4749c6260568e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*LFsY3A1StQDFOCOHrAZsgQ.png"/></div></figure><h2 id="b3d2" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq dt translated">何时使用它</h2><p id="a543" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hm dt translated">-适应不断变化的环境:修复错误，克服不可变合同的限制<br/> -虚拟升级(现有合同仍然不能更改)。这意味着，尽管原始合同保持不变，但可以部署新版本，并且其地址替换存储中的旧地址<br/>——以避免破坏引用升级合同<br/>的其他合同的依赖性——用户可能不知道新合同版本的发布(它带有新地址)</p><h2 id="795f" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq dt translated">它是如何工作的</h2><p id="2d88" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hm dt translated">首先，外部调用者对代理进行函数调用。第二，代理将调用委托给函数代码所在的委托。第三，结果被返回给代理，代理将结果转发给调用者。因为“delegatecall”用于委托调用，所以被调用的函数在代理的上下文中执行。这意味着代理的存储被用于函数执行，因此导致了委托契约的存储只能被附加的限制。<a class="ae kw" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7.md" rel="noopener ugc nofollow" target="_blank">EIP协议第七版</a>引入了“委派呼叫”操作码</p><p id="067e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">给定模式的逻辑，代理也被称为分派器，它将调用委托给特定的模块。这些模块被称为委托(因为工作是由代理契约委托给它们的)。</p><h2 id="83ae" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq dt translated">代理的存储用于函数执行是什么意思？</h2><p id="eb23" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hm dt translated">我们知道这种行为的结果是限制了委托契约的存储只能被附加。现在，在升级的情况下，现有的存储变量不能被改变或省略。相反，只能添加新的变量。</p><p id="7118" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这样做的原因是，更改委托中的存储结构会打乱代理中的存储，而代理需要的是以前的结构。</p><p id="dd8e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae kw" href="https://github.com/fravoll/solidity-patterns/blob/master/ProxyDelegate/StorageOverwriteExample.sol" rel="noopener ugc nofollow" target="_blank">这里有一个例子</a></p><h2 id="ff06" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq dt translated">语境呢？</h2><p id="6c97" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hm dt translated">因为使用了调用者的存储，所以执行上下文保持不变。因此，“消息发送者”和“消息值”不会改变。</p><h2 id="9eef" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq dt translated">将智能合约分为几个相关的智能合约</h2><p id="bcc3" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hm dt translated">这是除了Solidity之外的语言中常用的方法。例如，你可以有一个代币销售合同，在这种情况下，计算需要发送到以太钱包的代币数量的规则没有明确规定。在这种情况下，金额计算是在一个单独的合同中完成的，如果需要，以后可以升级该合同。</p><h2 id="f9d3" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq dt translated">契约函数调用的基础</h2><p id="9759" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hm dt translated">以太坊中的每个交易都有一个可选的“数据”字段，在传输以太网时，该字段必须留空。然而，当与一个契约进行交互时，必须包含一个叫做‘调用数据’的东西。<br/> -函数标识符(散列函数签名的前4个字节)，例如` keccak256("transfer(address，uint256)")` <br/> -函数标识符之后的函数参数，根据<a class="ae kw" href="https://docs.soliditylang.org/en/latest/abi-spec.html#argument-encoding" rel="noopener ugc nofollow" target="_blank"> ABI规范</a>进行编码</p><p id="7b0d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Solidity编译器有一个分支逻辑，它分析调用数据，并根据从调用数据中提取的函数标识符决定调用哪个函数。因为坚固性不允许我们在那个深度水平上做决定，我们将在后面展示我们将被迫使用汇编来写一些逻辑。</p><h2 id="9f6a" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq dt translated">如何实现代理委托模式</h2><p id="5bd7" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hm dt translated">本质上，业务逻辑是在从代理契约调用的函数中实现的。作为这种链接的结果，用不同的on交换实现契约成为可能。这是因为代理契约只知道实现实际业务逻辑的契约的地址。<br/>因为可靠性是一个高层次的抽象，它能给我们的只是一个后备功能。这是一个特殊的函数，每当调用一个不受协定支持的函数时，都会调用这个函数。</p><p id="b65c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最终，我们对于可升级契约的目标是获得“调用数据”并将其原样传递给实现契约，而不需要解析或修改它。</p><p id="d861" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，我们需要将呼叫数据加载到内存中</p><pre class="jp jq jr js fq kx ky kz la aw lb dt"><span id="e346" class="jw jx ht ky b fv lc ld l le lf"><br/>let ptr := mload(0x40)<br/>calldatacopy(ptr, 0, calldatasize())</span></pre><p id="debb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">EVM的内存是在插槽中处理的。每个槽都有一个索引，占用32个字节。上面的“calldatasize()”函数获取调用数据大小，并将特定大小的调用数据复制到位于索引“ptr”处的内存槽中，如果不适合，则占用其他内存槽。` mload '从指定的索引中读取32个字节。“0x40”是一个特殊的槽，它指向下一个空闲内存槽的索引，因此我们可以将呼叫数据保存到内存的一个空闲槽中。接下来，sload函数将读取该地址的值。接下来的两个零分别是“out”和“outsize ”,它们允许定义在内存中的什么位置存储返回数据</p><pre class="jp jq jr js fq kx ky kz la aw lb dt"><span id="0d30" class="jw jx ht ky b fv lc ld l le lf">The way to relay the call would be something like this:</span><span id="1fbb" class="jw jx ht ky b fv lg ld l le lf"><br/><br/>let result := delegatecall(<br/> gas(),<br/> sload(implementation.slot), <br/> ptr,<br/> calldatasize(),<br/> 0,<br/> 0<br/>)<br/></span></pre><p id="4bef" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">“gas”表示当前合同调用中剩余多少汽油，并告诉另一个合同允许花费多少汽油。“实现”状态变量是可靠性的一个特征，它允许容易地得到状态变量的存储槽地址。</p><h2 id="7558" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq dt translated">“委派电话”的实际含义是什么</h2><p id="4f76" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hm dt translated">“delegatecall”用于在代理结构的环境中在委托人处执行功能。这意味着“msg.data”被转发(前4个字节中的功能标识符)。在被转发后，为了被执行并触发每个函数调用的转发机制，它被放在代理契约的回退函数中。然而，“delegatecall”只返回一个布尔值，告诉我们执行是否成功。</p><p id="921d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了解决这个限制，使用了内联汇编。这允许用一种类似于EVM使用的语言对栈进行更细粒度的控制。使用内联汇编，我们可以剖析“delegatecall”的返回值，并将结果返回给调用者。</p><h2 id="c7ce" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq dt translated">我们能避免使用内联汇编的需要吗？</h2><p id="4979" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hm dt translated">这可以通过事件将结果返回给调用者来避免。由于事件不能被监听或从契约中监听，我们将使用前端并根据那里的结果采取行动。</p><h2 id="2f1a" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq dt translated">如果不调用“delegatecall ”,会是什么样子？</h2><p id="e40c" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hm dt translated">当我们希望代理契约返回从被调用方返回的任何内容，并且我们事先不知道返回的数据类型时，我们可以使用如下所示的代码片段:</p><pre class="jp jq jr js fq kx ky kz la aw lb dt"><span id="ab25" class="jw jx ht ky b fv lc ld l le lf"><br/>fallback() external {<br/> assembly {<br/> let ptr := mload(0x40)<br/> calldatacopy(ptr, 0, calldatasize())<br/> <br/> let result := delegatecall(<br/> gas(),<br/> sload(implementation.slot),<br/> ptr,<br/> calldatasize(),<br/> 0,<br/> 0<br/> )<br/> <br/> let size := returndatasize()<br/> <br/> returndatacopy(ptr, 0, size)<br/> <br/> switch result<br/>   case 0 {<br/>   revert(ptr, size)<br/> }<br/> default {<br/>   return(ptr, size)<br/> }<br/> }<br/>}</span></pre><h2 id="394e" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq dt translated">如何实现委托？</h2><p id="217d" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hm dt translated">委托可以像任何其他常规协定一样实现。它不需要知道使用其代码的代理。唯一需要注意的是，在升级合同时，存储顺序必须相同。请记住，只允许添加。</p><p id="f0a1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，升级机制，即存储委托的当前版本，可以发生在外部存储器中，也可以发生在代理本身中。<br/> -如果地址存储在代理中，则需要实现保护功能。这使得授权地址可以更新代理地址。</p><p id="e381" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是一个将委托的当前版本存储在自己的存储中的示例</p><pre class="jp jq jr js fq kx ky kz la aw lb dt"><span id="9f50" class="jw jx ht ky b fv lc ld l le lf"><br/>contract Proxy{<br/> address delegate; // store the address of the delegate<br/> address owner = msg.sender // store the address of the owner</span><span id="dd8a" class="jw jx ht ky b fv lg ld l le lf">/// <a class="ae kw" href="http://twitter.com/notice" rel="noopener ugc nofollow" target="_blank">@notice</a> this function allows a new version of the delegate being used without the caller having to worry about it<br/> function upgradeDelegate(address _newDelegateAddress) public {<br/>   require(msg.sender == owner);<br/>   delegate = _newDelegateAddress;<br/> }</span><span id="62a5" class="jw jx ht ky b fv lg ld l le lf">function () external payable {<br/>  assembly {<br/>  let _target := sload(0)<br/>  calldatacopy(0x0, 0x0, calldatasize)<br/>  let result := delegatecall(gas, _target, 0x0, calldatasize, 0x0, 0)<br/>  returndatacopy(0x0, 0x0, returndatasize)<br/>  switch result case 0 {revert(0,0)} default {return (0,   returndatasize)}<br/> }<br/> }<br/>}</span></pre><p id="d4ab" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">转发机制出现在第二个函数中，这是为每个未知的函数标识符调用的回退函数。因此，对代理的每个函数调用都会触发这个函数并执行汇编代码。</p><p id="d873" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">-第14行加载存储器中的第一个变量，即委托的地址，并将其存储在存储器变量“target”<br/>-第15行将函数签名和任何参数复制到存储器<br/> -第16行对“target”地址进行“delegatecall”，包括已经存储在存储器<br/>中的函数数据-第17行将返回值复制到存储器<br/>-switch语句检查执行布尔结果。<br/> —如果结果是肯定的，则结果被返回到函数<br/>的调用方—否则，任何状态改变被恢复</p><pre class="jp jq jr js fq kx ky kz la aw lb dt"><span id="49e0" class="jw jx ht ky b fv lc ld l le lf"><br/>contract Delegate {<br/> uint public n = 1;</span><span id="98a9" class="jw jx ht ky b fv lg ld l le lf">function add() public {<br/> n = 5;<br/> }<br/>}<br/></span><span id="62fc" class="jw jx ht ky b fv lg ld l le lf"><br/>contract Caller {<br/> Delegate proxy;</span><span id="ca35" class="jw jx ht ky b fv lg ld l le lf">function caller(address _proxyAddress) public {<br/> proxy = Delegate(_proxyAddress);<br/> }</span><span id="786d" class="jw jx ht ky b fv lg ld l le lf">function go() public {<br/> proxy.adds();<br/> }<br/>}<br/></span></pre><h2 id="c62b" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq dt translated">调用与委托调用、状态与逻辑</h2><p id="6926" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hm dt translated">智能合同的状态是持久的，它存储在区块链。此状态可通过状态变量访问。“call”和“delegatecall”都用于调用另一个合约。然而，它们在如何处理被调用方协定的状态<br/>上有所不同:-当使用“call”时，调用方和被调用方具有它们自己的独立状态(默认情况下这是预期的)<br/> -当使用“delegatecall”时，被调用方使用调用方的状态，这意味着您使用“delegatecall”调用的协定使用调用方协定的状态。</p><h2 id="db14" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq dt translated">被呼叫者合约初始化</h2><p id="f3d7" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hm dt translated">值得一提的是，当通过代理使用时，被调用方协定构造函数不能用于初始化。当我们使用构造函数初始化状态时，我们希望它在代理协定的状态内初始化。解决方法如下所示:</p><pre class="jp jq jr js fq kx ky kz la aw lb dt"><span id="b24e" class="jw jx ht ky b fv lc ld l le lf">contract BusinessLogic {<br/> bool initialized;<br/> uint 256 someNumber;</span><span id="6740" class="jw jx ht ky b fv lg ld l le lf">function init() public {<br/> require(!initialized, “already initialized”);<br/> someNumber = 0x42;<br/> initialized = true;<br/> }<br/>}<br/></span></pre><h2 id="6f5e" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq dt translated">使用这种模式的影响</h2><p id="9a41" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hm dt translated">1.由于内联装配<br/> 2，复杂性增加。模式的复杂性增加了bug或意外行为的可能性<br/> 3。存储变化:字段不能重新排列或删除<br/> 4。潜在的用户信任损失。有了可升级的合约，区块链的一个关键好处，就是不变性，被避免了。<br/> 5 .用户必须信任负责的实体，不要在他们的升级中引入任何不想要的行为<br/> 6。有必要仔细划分对更改活动合同地址的函数的访问权限</p><h2 id="ba39" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq dt translated">使用案例</h2><p id="47d8" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hm dt translated">-包含大量合约的大型Dapps。一个例子可能是预测市场，在那里，用户赌未来事件的结果。在这种情况下，可升级协定的地址不存储在代理本身中，而是存储在某种地址解析器中。<br/> -解决合同中发现的错误<br/> -解决可能导致合同资金损失的错误</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff lh"><img src="../Images/b684302052a0138f99ef2f78b071d365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*wnOFANLMXlO4ZP5nPxTElw.png"/></div></figure><h2 id="dbe0" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq dt translated">例子</h2><p id="ca39" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hm dt translated">-<a class="ae kw" href="https://github.com/0v1se/contracts-upgradeable/blob/master/contracts/Upgradeable.sol" rel="noopener ugc nofollow" target="_blank">可升级契约</a>验证目标(活动契约版本的地址)是否存储在与当前版本相同的槽中。<br/> - <a class="ae kw" href="https://github.com/0v1se/contracts-upgradeable/blob/master/test/contracts/Target.sol" rel="noopener ugc nofollow" target="_blank">可以对其他存储域</a> <br/>实施验证-在将这些合同部署到网络之前，需要<a class="ae kw" href="https://github.com/0v1se/contracts-upgradeable/blob/master/test/upgradeable.js" rel="noopener ugc nofollow" target="_blank">测试</a>所有选项。否则，在下一次更新后，您可能会没有一个有效的合同，并且您也不可能更新它。<br/> - <a class="ae kw" href="https://github.com/Jeiwan/upgradeable-proxy-from-scratch" rel="noopener ugc nofollow" target="_blank">整个工作流程</a></p><h2 id="4f60" class="jw jx ht bd jy jz ka kb kc kd ke kf kg jb kh ki kj jf kk kl km jj kn ko kp kq dt translated">结论</h2><p id="1952" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hm dt translated">为了创建可升级的智能契约，代理模式似乎是一个全面的策略。它允许开发人员将可升级机制从契约设计中分离出来。这简化了逻辑设计，并且不容易出错。没有一种策略是完美的，做出正确的选择将取决于用例。所有的策略和设计模式本身都很复杂，应用程序开发人员必须始终避免安全漏洞。</p><blockquote class="li"><p id="5f58" class="lj lk ht bd ll lm ln lo lp lq lr jn ek translated">加入Coinmonks <a class="ae kw" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae kw" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h2 id="594f" class="jw jx ht bd jy jz ls kb kc kd lt kf kg jb lu ki kj jf lv kl km jj lw ko kp kq dt translated">也阅读</h2><div class="lx ly fm fo lz ma"><a href="https://coincodecap.com/blockfi-review" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab ej"><div class="mc ab md cl cj me"><h2 class="bd hu fv z el mf eo ep mg er et hs dt translated">BlockFi评论:2022年的利弊和利率</h2><div class="mh l"><h3 class="bd b fv z el mf eo ep mg er et ek translated">今天，我们提出了一个全面的BlockFi评论，这是一个成立于2017年的加密贷款平台，拥有其…</h3></div><div class="mi l"><p class="bd b gc z el mf eo ep mg er et ek translated">coincodecap.com</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo ju ma"/></div></div></a></div><div class="lx ly fm fo lz ma"><a rel="noopener follow" target="_blank" href="/coinmonks/buy-bitcoin-in-india-feb50ddfef94"><div class="mb ab ej"><div class="mc ab md cl cj me"><h2 class="bd hu fv z el mf eo ep mg er et hs dt translated">如何在印度购买比特币？2021年购买比特币的7款最佳应用[手机版]</h2><div class="mh l"><h3 class="bd b fv z el mf eo ep mg er et ek translated">如何使用移动应用程序购买比特币印度</h3></div><div class="mi l"><p class="bd b gc z el mf eo ep mg er et ek translated">medium.com</p></div></div><div class="mj l"><div class="mp l ml mm mn mj mo ju ma"/></div></div></a></div><div class="lx ly fm fo lz ma"><a rel="noopener follow" target="_blank" href="/coinmonks/best-crypto-tax-tool-for-my-money-72d4b430816b"><div class="mb ab ej"><div class="mc ab md cl cj me"><h2 class="bd hu fv z el mf eo ep mg er et hs dt translated">加密税务软件——五大最佳比特币税务计算器[2021]</h2><div class="mh l"><h3 class="bd b fv z el mf eo ep mg er et ek translated">不管你是刚接触加密还是已经在这个领域呆了一段时间，你都需要交税。</h3></div><div class="mi l"><p class="bd b gc z el mf eo ep mg er et ek translated">medium.com</p></div></div><div class="mj l"><div class="mq l ml mm mn mj mo ju ma"/></div></div></a></div><div class="lx ly fm fo lz ma"><a href="https://coincodecap.com/crypto-to-buy-in-2022" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab ej"><div class="mc ab md cl cj me"><h2 class="bd hu fv z el mf eo ep mg er et hs dt translated">9个2022年最值得购买的密码| CoinCodeCap</h2><div class="mh l"><h3 class="bd b fv z el mf eo ep mg er et ek translated">9个2022年最值得购买的加密产品阅读加密产品评论和比较，了解比特币交易和…</h3></div><div class="mi l"><p class="bd b gc z el mf eo ep mg er et ek translated">coincodecap.com</p></div></div><div class="mj l"><div class="mr l ml mm mn mj mo ju ma"/></div></div></a></div><div class="lx ly fm fo lz ma"><a href="https://coincodecap.com/best-hardware-wallet-bitcoin" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab ej"><div class="mc ab md cl cj me"><h2 class="bd hu fv z el mf eo ep mg er et hs dt translated">存储比特币的最佳加密硬件钱包2022 | CoinCodeCap</h2><div class="mh l"><h3 class="bd b fv z el mf eo ep mg er et ek translated">硬件钱包是我们存储加密资产的唯一可靠选择。在本文中，我们将讨论8个…</h3></div><div class="mi l"><p class="bd b gc z el mf eo ep mg er et ek translated">coincodecap.com</p></div></div><div class="mj l"><div class="ms l ml mm mn mj mo ju ma"/></div></div></a></div><div class="lx ly fm fo lz ma"><a rel="noopener follow" target="_blank" href="/coinmonks/pionex-review-exchange-with-crypto-trading-bot-1e459d0191ea"><div class="mb ab ej"><div class="mc ab md cl cj me"><h2 class="bd hu fv z el mf eo ep mg er et hs dt translated">Pionex评论2021 |免费加密交易机器人和交换</h2><div class="mh l"><h3 class="bd b fv z el mf eo ep mg er et ek translated">Pionex是为交易自动化提供工具的后起之秀。Pionex上提供了9个加密交易机器人…</h3></div><div class="mi l"><p class="bd b gc z el mf eo ep mg er et ek translated">medium.com</p></div></div><div class="mj l"><div class="mt l ml mm mn mj mo ju ma"/></div></div></a></div><div class="lx ly fm fo lz ma"><a rel="noopener follow" target="_blank" href="/coinmonks/top-3-telegram-channels-for-crypto-traders-in-2021-8385f4411ff4"><div class="mb ab ej"><div class="mc ab md cl cj me"><h2 class="bd hu fv z el mf eo ep mg er et hs dt translated">2022年密码交易员的三大电报渠道</h2><div class="mh l"><h3 class="bd b fv z el mf eo ep mg er et ek translated">加密信号是来自专业交易者的交易想法，以特定的价格或价格买卖特定的加密货币</h3></div><div class="mi l"><p class="bd b gc z el mf eo ep mg er et ek translated">medium.com</p></div></div><div class="mj l"><div class="mu l ml mm mn mj mo ju ma"/></div></div></a></div><div class="lx ly fm fo lz ma"><a href="https://coincodecap.com/free-crypto-portfolio-trackers" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab ej"><div class="mc ab md cl cj me"><h2 class="bd hu fv z el mf eo ep mg er et hs dt translated">2022年5个最佳免费加密投资组合追踪器</h2><div class="mh l"><h3 class="bd b fv z el mf eo ep mg er et ek translated">在这篇文章中，我们将带你通过一些最好的免费加密投资组合追踪器，让你选择最好的…</h3></div><div class="mi l"><p class="bd b gc z el mf eo ep mg er et ek translated">coincodecap.com</p></div></div><div class="mj l"><div class="mv l ml mm mn mj mo ju ma"/></div></div></a></div></div></div>    
</body>
</html>