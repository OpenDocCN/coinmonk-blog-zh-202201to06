<html>
<head>
<title>Solidity For Developers: Libraries In Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发者的可靠性:可靠性中的库</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-for-developers-libraries-in-solidity-f8c7e348dc24?source=collection_archive---------14-----------------------#2022-03-08">https://medium.com/coinmonks/solidity-for-developers-libraries-in-solidity-f8c7e348dc24?source=collection_archive---------14-----------------------#2022-03-08</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="2997" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">了解Solidity中库的基本原理，并学习创建自己的库</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/74127a746d0ca3411c5357334b4041d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RlnSHtKFzujKD_7G"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Photo by <a class="ae jy" href="https://unsplash.com/@theshubhamdhage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Shubham Dhage</a> on <a class="ae jy" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e1b1" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">作为一种编程语言，Solidity与一些更常见的语言如Java、JavaScript和Cpp有许多相似之处。然而，有很多特性是Solidity所独有的，库恰好是其中之一。</p><blockquote class="kv kw kx"><p id="dd25" class="jz ka ky kb b kc kd iu ke kf kg ix kh kz kj kk kl la kn ko kp lb kr ks kt ku hm dt translated"><em class="ht">这篇文章是我的系列文章</em> <a class="ae jy" rel="noopener" href="/@akshatm408/list/solidity-for-developers-d604c4fd1e2a"> <strong class="kb hu"> <em class="ht">的一部分</em> </strong> </a> <em class="ht">，在这里我用一种对开发者来说既简单又不枯燥的方式解释了可靠性。</em></p></blockquote><h2 id="f601" class="lc ld ht bd le lf lg lh li lj lk ll lm ki ln lo lp km lq lr ls kq lt lu lv lw dt translated">什么是图书馆？</h2><p id="50b6" class="pw-post-body-paragraph jz ka ht kb b kc lx iu ke kf ly ix kh ki lz kk kl km ma ko kp kq mb ks kt ku hm dt translated">库是智能合约的简化版本。就像智能合约一样，您可以在其他合约中使用库的功能。但是与智能契约不同，库不能有任何状态变量，也不能继承其他契约。</p><p id="90f6" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">这个库的目的很简单，它位于区块链上，包含可以被其他契约使用的代码。</p><h1 id="916c" class="mc ld ht bd le md me mf li mg mh mi lm iz mj ja lp jc mk jd ls jf ml jg lv mm dt translated">在Solidity中创建一个图书馆</h1><p id="83b1" class="pw-post-body-paragraph jz ka ht kb b kc lx iu ke kf ly ix kh ki lz kk kl km ma ko kp kq mb ks kt ku hm dt translated">对于本文的全部内容，我们将使用<a class="ae jy" href="https://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Remix IDE </a>，因为它使得整个契约的部署、执行和调试变得非常容易。</p><h2 id="c041" class="lc ld ht bd le lf lg lh li lj lk ll lm ki ln lo lp km lq lr ls kq lt lu lv lw dt translated">创建文件</h2><p id="b3d2" class="pw-post-body-paragraph jz ka ht kb b kc lx iu ke kf ly ix kh ki lz kk kl km ma ko kp kq mb ks kt ku hm dt translated">要创建一个新文件，打开Remix导航选项卡并点击<strong class="kb hu"> <em class="ky">新文件</em> </strong>按钮。出于我们的目的，我们将该文件命名为<strong class="kb hu"> <em class="ky"> example.sol. </em> </strong></p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/12fc1759430e6a376af42bd5f40ab0a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*GJn8LszzkffFRPCpRPkjzA.png"/></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Creating The File</figcaption></figure><h2 id="1ec0" class="lc ld ht bd le lf lg lh li lj lk ll lm ki ln lo lp km lq lr ls kq lt lu lv lw dt translated">定义杂注</h2><p id="b019" class="pw-post-body-paragraph jz ka ht kb b kc lx iu ke kf ly ix kh ki lz kk kl km ma ko kp kq mb ks kt ku hm dt translated">编写任何可靠性代码的第一步是定义编译指令。这些年来，坚固性发生了很大的变化，编译指示定义了我们的坚固性代码有效的EVM编译器的版本。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/3b4be310eb2a0c9374dd1477f19d31b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*YO9ZJK6O0PS99JvDHdMTIA.png"/></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Defining The Pragma</figcaption></figure><h2 id="21a5" class="lc ld ht bd le lf lg lh li lj lk ll lm ki ln lo lp km lq lr ls kq lt lu lv lw dt translated">库声明</h2><p id="7f07" class="pw-post-body-paragraph jz ka ht kb b kc lx iu ke kf ly ix kh ki lz kk kl km ma ko kp kq mb ks kt ku hm dt translated">就像智能合约一样，我们用<strong class="kb hu"> <em class="ky">库</em> </strong>关键字声明库，后跟标识符。我们将我们的库命名为<strong class="kb hu"> <em class="ky">加法器</em> </strong></p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/a8f1ccbacbc7d6ed664d2a7702cfa2a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*MPNx92cjbPLN4BErKnBWPw.png"/></div></figure><h2 id="0772" class="lc ld ht bd le lf lg lh li lj lk ll lm ki ln lo lp km lq lr ls kq lt lu lv lw dt translated">图书馆方法</h2><p id="c4b5" class="pw-post-body-paragraph jz ka ht kb b kc lx iu ke kf ly ix kh ki lz kk kl km ma ko kp kq mb ks kt ku hm dt translated">我们的库将包含一个函数，它执行一个uint数组中所有数字的求和。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mq"><img src="../Images/7aa4876e5767519f16ffe23a8e366e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mH7c7WqTeVrpMOFnBkNHJQ.png"/></div></div></figure><h2 id="0ac5" class="lc ld ht bd le lf lg lh li lj lk ll lm ki ln lo lp km lq lr ls kq lt lu lv lw dt translated">定义函数</h2><p id="9c74" class="pw-post-body-paragraph jz ka ht kb b kc lx iu ke kf ly ix kh ki lz kk kl km ma ko kp kq mb ks kt ku hm dt translated">就像在JavaScript中一样，Solidity中的函数是使用<strong class="kb hu"> <em class="ky"> function </em> </strong>关键字声明的。该函数接受一个参数，该参数是一个uint数组，带有内存修饰符。</p><h2 id="3f1c" class="lc ld ht bd le lf lg lh li lj lk ll lm ki ln lo lp km lq lr ls kq lt lu lv lw dt translated">“纯”修饰词</h2><p id="7203" class="pw-post-body-paragraph jz ka ht kb b kc lx iu ke kf ly ix kh ki lz kk kl km ma ko kp kq mb ks kt ku hm dt translated">内存修饰符告诉编译器，我们的变量将要访问区块链的内存，pure是一个修饰符，本质上意味着这个函数不读，也不写任何状态变量。</p><h2 id="72f9" class="lc ld ht bd le lf lg lh li lj lk ll lm ki ln lo lp km lq lr ls kq lt lu lv lw dt translated">定义退货类型</h2><p id="6176" class="pw-post-body-paragraph jz ka ht kb b kc lx iu ke kf ly ix kh ki lz kk kl km ma ko kp kq mb ks kt ku hm dt translated">最后一个关键字<strong class="kb hu"><em class="ky">returns(uint)</em></strong>描述了这个函数返回的值的类型，在我们的例子中，我们返回一个数组中所有整数的和，所以我们返回一个uint类型的变量。</p><h2 id="1fa2" class="lc ld ht bd le lf lg lh li lj lk ll lm ki ln lo lp km lq lr ls kq lt lu lv lw dt translated">最后一眼</h2><p id="87b4" class="pw-post-body-paragraph jz ka ht kb b kc lx iu ke kf ly ix kh ki lz kk kl km ma ko kp kq mb ks kt ku hm dt translated">这是我们完成的图书馆的最后一眼。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mr ms l"/></div></figure><h1 id="2f7f" class="mc ld ht bd le md me mf li mg mh mi lm iz mj ja lp jc mk jd ls jf ml jg lv mm dt translated">在智能合同中使用库</h1><p id="02cf" class="pw-post-body-paragraph jz ka ht kb b kc lx iu ke kf ly ix kh ki lz kk kl km ma ko kp kq mb ks kt ku hm dt translated">随着我们库的完成，我们现在可以在智能合同中使用它。如果这个库与契约存在于同一个文件中，就没有必要进行任何导入。</p><h2 id="2091" class="lc ld ht bd le lf lg lh li lj lk ll lm ki ln lo lp km lq lr ls kq lt lu lv lw dt translated">访问同一文件中的库</h2><p id="5f11" class="pw-post-body-paragraph jz ka ht kb b kc lx iu ke kf ly ix kh ki lz kk kl km ma ko kp kq mb ks kt ku hm dt translated">访问存在于同一文件中的契约中的库需要任何种类的so import语句。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff mt"><img src="../Images/25ab87232ee2d691fcba56371a55cdb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ScQG5EmzZfVyjJJdyII_YQ.png"/></div></div></figure><p id="28d8" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">为了访问这个库，我们创建了一个简单的智能契约，其中包含一个调用我们的库的add函数的函数。因为库和契约存在于同一个文件中，所以不需要任何import语句。</p><h2 id="8a15" class="lc ld ht bd le lf lg lh li lj lk ll lm ki ln lo lp km lq lr ls kq lt lu lv lw dt translated">理解合同</h2><p id="07a4" class="pw-post-body-paragraph jz ka ht kb b kc lx iu ke kf ly ix kh ki lz kk kl km ma ko kp kq mb ks kt ku hm dt translated">给定的契约只有一个函数，<strong class="kb hu"> <em class="ky"> give_sum </em> </strong>函数接受整数数组类型的单个参数，并使用库方法<strong class="kb hu"> <em class="ky"> add </em> </strong>来产生总和。</p><p id="49c4" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">external是一个访问说明符，它声明这个方法函数只能从当前契约的外部调用。</p><h2 id="9122" class="lc ld ht bd le lf lg lh li lj lk ll lm ki ln lo lp km lq lr ls kq lt lu lv lw dt translated">从不同的文件访问</h2><p id="6b35" class="pw-post-body-paragraph jz ka ht kb b kc lx iu ke kf ly ix kh ki lz kk kl km ma ko kp kq mb ks kt ku hm dt translated">要从不同的合同中访问该库，我们需要使用<strong class="kb hu"><em class="ky">【import】</em></strong>语句。在Solidity中，我们可以导入URL和文件路径。</p><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="mr ms l"/></div></figure><p id="c740" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">在import语句中，我们导入与当前契约位于同一文件夹中的库，为此我们使用相对路径。</p><h1 id="565c" class="mc ld ht bd le md me mf li mg mh mi lm iz mj ja lp jc mk jd ls jf ml jg lv mm dt translated">运行智能合同</h1><p id="29e5" class="pw-post-body-paragraph jz ka ht kb b kc lx iu ke kf ly ix kh ki lz kk kl km ma ko kp kq mb ks kt ku hm dt translated">要运行我们的智能契约，我们必须部署契约后面的<strong class="kb hu"> <em class="ky">加法器</em> </strong>库。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/f542a4523d91d872410bb71be52258f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*h3E1Rsk-23D8rId-lE1Yyg.png"/></div></figure><p id="7e9a" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">在部署了这两个文件之后，我们可以看到我们已经在<strong class="kb hu"><em class="ky">Deployed Contracts</em></strong>部分部署了这两个契约。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/05e173bde193e9ef698b2ae413cdece5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*T8FUtLqlPk8fd0R0qsgtiQ.png"/></div></figure><p id="6eb4" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">我们现在可以通过传递一个整数数组来测试我们的智能契约。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/8df7347cc60d7e0c6940dc022ba812e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*xXcO3Q04qf8CWEivHZys1Q.png"/></div></figure><p id="c3de" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">事实上，这很有效。这意味着我们的库已经成功地执行了不同的合同。</p><h1 id="c256" class="mc ld ht bd le md me mf li mg mh mi lm iz mj ja lp jc mk jd ls jf ml jg lv mm dt translated">结论</h1><p id="ba49" class="pw-post-body-paragraph jz ka ht kb b kc lx iu ke kf ly ix kh ki lz kk kl km ma ko kp kq mb ks kt ku hm dt translated">这很好地总结了什么是库，以及如何创建自己的库。如前所述，它们只是智能合约的简化版本，使用库而不是继承智能合约的一个很大的好处是，它们节省了汽油成本。</p><p id="3c5d" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">如果你喜欢这篇文章，或者碰巧发现它对你有帮助，一定要看看我的列表 <a class="ae jy" rel="noopener" href="/@akshatm408/list/solidity-for-developers-d604c4fd1e2a"> <strong class="kb hu">开发者的可靠性</strong> </a> <strong class="kb hu">。</strong></p><h1 id="5f25" class="mc ld ht bd le md me mf li mg mh mi lm iz mj ja lp jc mk jd ls jf ml jg lv mm dt translated">其他文章</h1><p id="e626" class="pw-post-body-paragraph jz ka ht kb b kc lx iu ke kf ly ix kh ki lz kk kl km ma ko kp kq mb ks kt ku hm dt translated"><a class="ae jy" href="https://coinsbench.com/automate-crypto-trading-with-python-1e2bcd6e7031" rel="noopener ugc nofollow" target="_blank"> <strong class="kb hu">用Python创建加密交易机器人</strong> </a></p><p id="5b25" class="pw-post-body-paragraph jz ka ht kb b kc kd iu ke kf kg ix kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated"><a class="ae jy" rel="noopener" href="/@akshatm408/generating-passwords-with-python-2ed088d5f1"> <strong class="kb hu">用Python生成密码</strong> </a></p></div></div>    
</body>
</html>