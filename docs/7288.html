<html>
<head>
<title>How did I manage to create a smart contract in web3?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何在web3中创建智能合同的？</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/how-did-i-manage-to-create-a-smart-contract-in-web3-56ae8064bd9e?source=collection_archive---------21-----------------------#2022-05-23">https://medium.com/coinmonks/how-did-i-manage-to-create-a-smart-contract-in-web3-56ae8064bd9e?source=collection_archive---------21-----------------------#2022-05-23</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/4b0ca3ed92972a1ce8b7224922f78166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HwGP_DWw26wqHZgU"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Photo by <a class="ae jf" href="https://unsplash.com/@theshubhamdhage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Shubham Dhage</a> on <a class="ae jf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b7be" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我已经研究web3很长时间了。我不知道什么是web3，也不知道为什么这个概念在今天如此流行。所以我决定进入并学习它。说实话，当我第一次面对这个新领域的许多复杂的话题时，我放弃了这个目标，并认为我学不会web3，这个领域不适合我。因为为了在web3上开发一个真正的后端项目，有必要熟悉web3的基础理论。</p><p id="4d71" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在我的web3调查期间，我发现了web3领域中最好和最有结构的训练营之一，它是由<a class="ae jf" href="https://www.patika.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="ji hu">帕蒂卡</strong> </a>创建的，之后，我决定将这个训练营用于学习web3。</p><p id="c378" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我通常不喜欢web2上的前端，所以我也想学习web3上的后端。Patika为此创造了良好的条件，并教授如何通过近协议创建web3后端的智能合约。</p></div><div class="ab cl ke kf hb kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hm hn ho hp hq"><h1 id="f813" class="kl km ht bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">我的旅程开始了…</h1><p id="1d58" class="pw-post-body-paragraph jg jh ht ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hm dt translated">在“Patika”训练营中，我首先学习了web3的基础知识，如区块链、去中心化术语、Dapp、智能合约、FT-NFT、DeFi、DAO、比特币、以太坊等等。学习完以上基础理论知识后，我开始在SDK附近学习创建智能合约。</p><h1 id="6f7a" class="kl km ht bd kn ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li dt translated">什么是近？</h1><p id="815a" class="pw-post-body-paragraph jg jh ht ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hm dt translated">NEAR是对开发人员最友好的构建去中心化应用程序的平台，也是开发人员增长第三快的加密货币生态系统！</p><p id="52a2" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">Near为开发者提供了两种类型的SDK来创建去中心化的应用:Rust和AssemblyScript SDKs。</p><h1 id="1fd0" class="kl km ht bd kn ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li dt translated">什么是汇编脚本？</h1><blockquote class="lt lu lv"><p id="25e8" class="jg jh lw ji b jj jk jl jm jn jo jp jq lx js jt ju ly jw jx jy lz ka kb kc kd hm dt translated">它类似于TypeScript，但具有WebAssembly类型，由于提前编译严格类型化的代码而具有一些约束，但也有一些源于WebAssembly功能集的附加功能。虽然不是所有的TypeScript都可以被支持，但是它与JavaScript的密切关系使它成为已经习惯于为Web编写代码的开发人员的熟悉选择，并且它还有可能与现有的Web平台概念无缝集成，以产生精简的WebAssembly模块</p></blockquote><p id="3bc3" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在申请near Bootcamp之前，我在node.js和typescript方面的技能一般，所以我很舒服地使用了AssemblyScript。如果你想了解更多，你可以访问这个<a class="ae jf" href="https://www.assemblyscript.org/introduction.html" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><h1 id="2ae1" class="kl km ht bd kn ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li dt translated">我的智能合同</h1><p id="d944" class="pw-post-body-paragraph jg jh ht ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hm dt translated">我创建了一个简单的CRUD智能契约，它的名字是“Artenc”<strong class="ji hu">:</strong></p><h2 id="21f3" class="ma km ht bd kn mb mc md kr me mf mg kv jr mh mi kz jv mj mk ld jz ml mm lh mn dt translated"><strong class="ak">想法:</strong></h2><p id="7a76" class="pw-post-body-paragraph jg jh ht ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hm dt translated">“Artenc”是付费百科。任何写文章的人都可以把他们的文章放在这个百科全书里。随着文章被用户使用，作者添加的文章数量增加，作者得到奖励。这样一来，合同持有者和文章作者都能获利。</p><p id="eb3c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">详情:</strong></p><p id="293b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">首先，我们需要适当地构建项目。几乎不需要从头开始创建合同结构，因为它们是模板化的。您创建的合同的主要逻辑在<strong class="ji hu">汇编文件夹</strong>中。在这个文件夹中，您可以设置自己的逻辑和结构，使程序按照您想要的方式运行。所以我就直接解释一下基本逻辑，不涉及其他部分。我在程序集文件夹中创建了3个文件。</p><pre class="mo mp mq mr fq ms mt mu mv aw mw dt"><span id="a8fe" class="ma km ht mt b fv mx my l mz na">assembly<br/>  ├── index.ts   # contains code for the contract<br/>  └── model.ts #contains code for the model(s) accessible to the       contract<br/>  └── utils.ts #contains code for helper functions</span></pre><p id="7e88" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">指标</strong>、<strong class="ji hu">模型</strong>和<strong class="ji hu">效用</strong>。</p><p id="fbdc" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">index.ts文件是程序的主要入口点。就是我们的基本逻辑在这里被创造，其他方面在这里被调用。正如我前面提到的，单例模式在创建智能契约时更常用。这就是我在这里使用单例模式的原因。</p><p id="4498" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们首先从near assembly script SDK导入我们需要的API。</p><ol class=""><li id="2b9e" class="nb nc ht ji b jj jk jn jo jr nd jv ne jz nf kd ng nh ni nj dt translated"><strong class="ji hu">上下文</strong>包含执行上下文信息。例如，发送者、添加的令牌等。</li><li id="e49f" class="nb nc ht ji b jj nk jn nl jr nm jv nn jz no kd ng nh ni nj dt translated"><strong class="ji hu"> ContractPromiseBatch </strong>类包含许多方法。我们将使用这个类的<strong class="ji hu"> transfer </strong>方法。</li><li id="0526" class="nb nc ht ji b jj nk jn nl jr nm jv nn jz no kd ng nh ni nj dt translated"><strong class="ji hu"> PersistentSet </strong>是一种数据结构，它将存储包装成一个集合。</li></ol><p id="f23c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">然后，我们从model.ts文件中导入所需的数据类，并从util.ts模块中导入必要的助手方法。我们将在后面创建这些函数。</p><h1 id="646d" class="kl km ht bd kn ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li dt translated">模型. ts文件。</h1><p id="4702" class="pw-post-body-paragraph jg jh ht ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hm dt translated">这里我们创建了我们需要的两个主要数据类。这里，第一个类存储一篇文章的所有数据。第二类是没有<code class="eh np nq nr mt b">url </code>属性但有其他公共属性的类。</p><p id="674c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">你必须支付一定的NEAR token才能获得文章的url。下面我展示了通用的model.ts文件:</p><figure class="mo mp mq mr fq iu"><div class="bz el l di"><div class="ns nt l"/></div></figure><h1 id="b500" class="kl km ht bd kn ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li dt translated">index.ts文件</h1><p id="9d3e" class="pw-post-body-paragraph jg jh ht ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hm dt translated">我们将首先在“index.ts”文件中创建我们的合同类。这个类是控制契约逻辑的主要部分。</p><p id="695e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我已将我们的合同数据存储在<strong class="ji hu">持久集</strong>中。这是AssemblyScript中的集合类型。PersistentSet抽象了存储类，并为我们提供了许多连接到存储的有用方法。请注意，当我们将数据存储在PersistentSet上时，自动数据在部署到区块链时存储在存储中。</p><p id="2db9" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">最初，我们在契约类内分配私有属性<strong class="ji hu">契约_所有者</strong>、<strong class="ji hu">最小_费用</strong>、<strong class="ji hu">金额</strong>。然后我们在构造函数中设置这些信息。当使用<strong class="ji hu"> init </strong>函数初始化契约时，构造函数将运行并设置这些值。我们很快就会看到这一点。</p><p id="1deb" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这里的<code class="eh np nq nr mt b">@nearBindgen</code>是一个装饰器，用于在自定义类被保存到区块链上的存储之前对它们进行序列化。</p><figure class="mo mp mq mr fq iu"><div class="bz el l di"><div class="ns nt l"/></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">The initial state of our contract class</figcaption></figure><p id="904e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">一切都准备好了，我们可以继续我们的“crud方法”了。NEAR中有两类方法:<strong class="ji hu">查看方法</strong>和<strong class="ji hu">调用方法</strong>。视图方法只是只读操作，不会对区块链进行任何更改。调用方法对区块链进行更改，并且运行是有偿的。</p></div><div class="ab cl ke kf hb kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hm hn ho hp hq"><h1 id="c0bf" class="kl km ht bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated"><strong class="ak">添加方法。</strong></h1><p id="db83" class="pw-post-body-paragraph jg jh ht ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hm dt translated">我们的第一个方法是<code class="eh np nq nr mt b">add </code>方法，用于添加新文章。</p><figure class="mo mp mq mr fq iu"><div class="bz el l di"><div class="ns nt l"/></div></figure><p id="b98f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh np nq nr mt b">add</code>方法从用户处获取url和title参数，首先验证用户至少支付了1 NEAR，然后提供所需信息。如果一切顺利，将从article类创建一个新的Article实例，并检查该对象是否已经存在于<strong class="ji hu"> PersistentSet </strong>中。如果在这个阶段它是OK的，那么一个新的文章被添加到存储中。</p><h1 id="3a1a" class="kl km ht bd kn ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li dt translated"><strong class="ak">更新文章方法</strong></h1><p id="6d6e" class="pw-post-body-paragraph jg jh ht ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hm dt translated"><code class="eh np nq nr mt b">updateArticle</code>方法是一个调用方法，所以我们在这三个方法中都需要来自用户的令牌。该方法从用户处检索要更新的字段，并将它们传递给助手<strong class="ji hu"> update </strong>方法，以更新存储中的文章并返回更新后的版本。</p><figure class="mo mp mq mr fq iu"><div class="bz el l di"><div class="ns nt l"/></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">updateArticle method</figcaption></figure><p id="cd86" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh np nq nr mt b">update</code> helper方法在<strong class="ji hu"> PersistentSet </strong>上的文章中搜索给定的<strong class="ji hu"> id </strong>，并检查请求用户是否确实是文章的所有者，如果是，则进行更新。在这里使用for循环在性能方面是不好的，但是其他方法在AssemblyScript中不起作用，我不得不使用for循环。(需要改进)</p><figure class="mo mp mq mr fq iu"><div class="bz el l di"><div class="ns nt l"/></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">update helper method</figcaption></figure><h1 id="c7a8" class="kl km ht bd kn ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li dt translated"><strong class="ak">删除文章方法。</strong></h1><p id="7a71" class="pw-post-body-paragraph jg jh ht ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hm dt translated"><code class="eh np nq nr mt b">deleteArticle</code>方法只允许合同所有者删除文章。根据给定的id查找和删除文章。</p><figure class="mo mp mq mr fq iu"><div class="bz el l di"><div class="ns nt l"/></div></figure><h1 id="5eff" class="kl km ht bd kn ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li dt translated"><strong class="ak">使用useArtice方法。</strong></h1><p id="ef5b" class="pw-post-body-paragraph jg jh ht ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hm dt translated">这是本文的主要方法。当用户调用这个方法时，它首先找到作者的文章并检查它们的编号。如果作者至少有5篇文章，它根据文章的数量确定金额并通过发送到帮助方法<code class="eh np nq nr mt b">sendNearToWriter,</code>来奖励作者，并将作者的所有文章返回给用户。</p><figure class="mo mp mq mr fq iu"><div class="bz el l di"><div class="ns nt l"/></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">useArticle method</figcaption></figure><p id="6f54" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">帮助器方法从存储中查找并返回作者的文章</p><figure class="mo mp mq mr fq iu"><div class="bz el l di"><div class="ns nt l"/></div></figure><p id="8f6b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">方法sendNearToWriter将收到的金额作为参数从合同账户转移到作者的钱包。</p><figure class="mo mp mq mr fq iu"><div class="bz el l di"><div class="ns nt l"/></div></figure><h1 id="67a1" class="kl km ht bd kn ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li dt translated">其他查看方法。</h1><figure class="mo mp mq mr fq iu"><div class="bz el l di"><div class="ns nt l"/></div></figure><h1 id="c16d" class="kl km ht bd kn ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li dt translated">让我们检查一下合同是否有效</h1><p id="2bd4" class="pw-post-body-paragraph jg jh ht ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hm dt translated">您必须安装near CLI才能运行合同。让我们启动合同并指定合同的作者</p><p id="8c60" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我为项目的scripts文件夹中的每个方法编写了一个bash脚本。通过运行这些脚本，您可以很容易地测试所有的方法和契约。</p><p id="7895" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们运行第一个<code class="eh np nq nr mt b">.scripts/init.sh</code>。该脚本通过运行contract类的构造函数来启动协定。可以在<a class="ae jf" href="https://github.com/ebdurrehm/artenc/tree/main/scripts" rel="noopener ugc nofollow" target="_blank"> GitHub上熟悉一下脚本的代码。</a></p><figure class="mo mp mq mr fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nu"><img src="../Images/3d73bec67d17a5c9d3b6a39f0932d6ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v41YrSiWkBhAwAHZ"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">this command initiates the contract and assigns the contract owner (near-account)</figcaption></figure><p id="0b62" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">那么我们在合同中增加5条吧</p><figure class="mo mp mq mr fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nv"><img src="../Images/6b82dae6905042509ece73dc20c289f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rlkzCDOJqlWgP7rP"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Here we add 5 articles to the contract by running a script.</figcaption></figure><p id="1bb6" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">然后运行脚本来测试<strong class="ji hu"> useArticle </strong>方法:</p><figure class="mo mp mq mr fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nw"><img src="../Images/07a62fdee75b694206a1e31576bd1dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VgHw8a-Zp5WCaZQe"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">This script returns all articles by abdur23.testnet. And also because the author has at least 5 articles, NEAR is transferred to his account.</figcaption></figure><p id="af6c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果我们打开终端中给定的链接，我们将看到如下所示:</p><figure class="mo mp mq mr fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nx"><img src="../Images/40e1b26578372094d9e73d1d54e5f5d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VwMTPIHQPxjTtsIB"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">In fact, 2 NEARs were transferred to the author’s account</figcaption></figure><p id="6d39" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">要查看作者的所有常规文章，让我们运行以下脚本:</p><figure class="mo mp mq mr fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ny"><img src="../Images/4ae566103d6f3798271196ba1039d37f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9N8LixZOOiz5Dkh0"/></div></div></figure><p id="6683" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">正如您所看到的，因为这是一个免费的方法，所以文章的URL对用户是不可见的。</p><p id="40f0" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们看看合同中目前有多少条款:</p><figure class="mo mp mq mr fq iu fe ff paragraph-image"><div class="fe ff nz"><img src="../Images/cf9b664a4cb84fb5c6d0fe815714e44c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/0*me70zo3_8tjHZlMk"/></div></figure><p id="872b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们看看该合同的余额中目前有多少个接近令牌:</p><figure class="mo mp mq mr fq iu fe ff paragraph-image"><div class="fe ff oa"><img src="../Images/626df2b4b5931fece3250b56345a9349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/0*B_WmrK07Ks-AeG0y"/></div></figure><p id="33a9" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">让我们更新存储中的任何商品:</p><figure class="mo mp mq mr fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ob"><img src="../Images/cd0465c25bcbf6ae17f2829651112f69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NzmDHpyPjz9emNHk"/></div></div></figure><p id="c5ea" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">使用我们的最后一个方法，即<strong class="ji hu"> deleteArticle </strong>方法，从存储中删除文章:</p><figure class="mo mp mq mr fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff oc"><img src="../Images/500014f15b398950ed31b598b059a15d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bRu9K7qyYGNo2RMJ"/></div></div></figure><p id="aa98" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我推荐你关注项目的GitHub repo，这样你就可以同时读取所有的脚本和helper方法。</p><p id="cbf7" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">你可以通过testnet区块链网络直接运行这个项目(<strong class="ji hu"> artenc.abdur23.testnet </strong>)。同时，如果您愿意，您可以将这个项目直接部署到mainnet网络中。可以看github repo里的详细解释。</p><p id="c36e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">你也可以通过在这个后端项目上创建前端来创建一个全栈的web3应用。为此，您将需要NEAR的javascript API。</p></div><div class="ab cl ke kf hb kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hm hn ho hp hq"><p id="3700" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">谢谢你看完。我不是web3专业人士，所以我可能会在这篇文章中犯技术性错误。如果你发现任何错误，请让我知道。</p><div class="od oe fm fo of og"><a href="https://github.com/ebdurrehm/artenc/" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab ej"><div class="oi ab oj cl cj ok"><h2 class="bd hu fv z el ol eo ep om er et hs dt translated">GitHub - ebdurrehm/artenc:作家文章百科|创作一篇文章挣钱…</h2><div class="on l"><h3 class="bd b fv z el ol eo ep om er et ek translated">作家文章百科|创作一篇文章，为你文章的数量和使用赚(近)钱…</h3></div><div class="oo l"><p class="bd b gc z el ol eo ep om er et ek translated">github.com</p></div></div><div class="op l"><div class="oq l or os ot op ou iz og"/></div></div></a></div><blockquote class="ov"><p id="88a8" class="ow ox ht bd oy oz pa pb pc pd pe kd ek translated">加入Coinmonks <a class="ae jf" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jf" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="7c83" class="kl km ht bd kn ko lo kq kr ks lp ku kv kw pf ky kz la pg lc ld le ph lg lh li dt translated">另外，阅读</h1><ul class=""><li id="dc76" class="nb nc ht ji b jj lj jn lk jr pi jv pj jz pk kd pl nh ni nj dt translated"><a class="ae jf" href="https://coincodecap.com/swap-crypto-on-uniswap" rel="noopener ugc nofollow" target="_blank">如何在Uniswap上交换加密？</a> | <a class="ae jf" href="https://coincodecap.com/a-ads-review" rel="noopener ugc nofollow" target="_blank"> A-Ads审查</a></li><li id="7fb3" class="nb nc ht ji b jj nk jn nl jr nm jv nn jz no kd pl nh ni nj dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/wazirx-vs-coindcx-vs-bitbns-149f4f19a2f1">WazirX vs CoinDCX vs bit bns</a>|<a class="ae jf" rel="noopener" href="/coinmonks/blockfi-vs-coinloan-vs-nexo-cb624635230d">block fi vs coin loan vs Nexo</a></li><li id="033c" class="nb nc ht ji b jj nk jn nl jr nm jv nn jz no kd pl nh ni nj dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/localbitcoins-review-6cc001c6ed56">本地比特币审核</a> | <a class="ae jf" href="https://coincodecap.com/cryptocurrency-savings-accounts" rel="noopener ugc nofollow" target="_blank">加密货币储蓄账户</a></li><li id="f7dc" class="nb nc ht ji b jj nk jn nl jr nm jv nn jz no kd pl nh ni nj dt translated"><a class="ae jf" href="https://coincodecap.com/margin-trading" rel="noopener ugc nofollow" target="_blank">什么是保证金交易</a> | <a class="ae jf" href="https://coincodecap.com/dca" rel="noopener ugc nofollow" target="_blank">美元成本平均法</a></li><li id="a518" class="nb nc ht ji b jj nk jn nl jr nm jv nn jz no kd pl nh ni nj dt translated"><a class="ae jf" href="https://coincodecap.com/uphold-card-review" rel="noopener ugc nofollow" target="_blank">支持卡审核</a> | <a class="ae jf" href="https://coincodecap.com/trust-wallet-vs-metamask" rel="noopener ugc nofollow" target="_blank">信任钱包vs元掩码</a></li><li id="86db" class="nb nc ht ji b jj nk jn nl jr nm jv nn jz no kd pl nh ni nj dt translated"><a class="ae jf" href="https://coincodecap.com/exness-review" rel="noopener ugc nofollow" target="_blank"> Exness回顾</a>|<a class="ae jf" href="https://coincodecap.com/bingbon-vs-bitget-vs-moonxbt" rel="noopener ugc nofollow" target="_blank">moon xbt Vs bit get Vs Bingbon</a></li></ul></div></div>    
</body>
</html>