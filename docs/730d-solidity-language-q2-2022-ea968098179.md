# 学习可靠性(你需要知道的一切)

> 原文：<https://medium.com/coinmonks/730d-solidity-language-q2-2022-ea968098179?source=collection_archive---------8----------------------->

## Solidity 编程语言介绍

## #计算机科学#区块链#以太坊#可靠性

![](img/8acdd459def539ae33c4e2f3f304438e.png)

Photo by [Uriel SC](https://unsplash.com/@urielsc26?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

# 介绍

**Solidity** 是一个**面向对象**、**静态类型**、**高级语言**，用于在 **EVM** (以太坊虚拟机)内实现**智能合约**。在其特性中，支持**继承**、 **ABI** (应用二进制接口)**基础库**、& **复杂类型**。

# 杂注

`pragma`关键字用于通知编译器 solidity 文件的**版本要求**。因为这个指令是本地的，所以用 solidity 编写的每个文件都必须声明自己的 pragma 语句。

```
pragma solidity ^X.X.X;
```

# 进口

`import`关键字用于**导入报表**。这将指定的`filepath`中的所有全局符号导入到当前的全局范围中。

还可以使用一个`symbolName`来引用这些导入的元素，而不会挤占名称空间。

```
import "filename" as symbolName;
```

# 契约

可靠性**契约**类似于面向对象语言中的**类**。

`contract`关键字用于声明合同。

契约可以声明**状态变量**，**函数**，**函数修饰符**，**事件**，**错误**，**结构类型**和**枚举类型**。它们还可以有一个**构造函数**，这个函数只被调用一次**:当契约最初被保存到 EVM 中时。**

**下面是合同的基本结构**

# **遗产**

**Solidity 通过**多重继承**支持**多态**，允许契约从**基础契约**和** **接口**继承可见成员。**

**`is`关键字用于声明继承，从最基本到最派生列出。**

**基本构造函数按照**线性化规则**执行，并要求**继承契约满足其参数**。这些构造函数可以在继承列表中调用，或者作为构造函数中的修饰符。**

***这里有一个多基数的合同:***

**`super`关键字可以用于**以**非声明**的方式访问继承的成员**。**

**当用于调用函数时，编译器将按照与声明相反的顺序在继承的契约链中搜索匹配的函数签名。**

***这里有一个使用超级清理的函数:***

# **摘要**

**Solidity 支持抽象，允许创建抽象契约。**

**`abstract`关键字用于声明**抽象契约**。**

**如果一个契约**声明或继承了一个未实现的函数**，以及如果它**不满足其基础构造函数**，则该契约需要被**标记为抽象的**。**

***这里是一个抽象契约，有一个未实现的功能:***

# **功能**

**坚固性支持标准功能。**

**`function`关键字用于声明函数。**

***下面是函数的基本结构:***

**Solidity 支持函数**重载**，但是由于 **ABI 编码器**的原因，应该小心外部函数类型。**

# **最重要的**

**坚固性支持**覆盖**，这是**多态**的一个特性。**

**`virtual` & `override`关键字是**可覆盖&被覆盖函数**各自的标签。**

**覆盖函数只能改变`external` - > `public`的可见性修饰符，而可变性只能改变更严格的修饰符(`nonpayable`->-`view`->`pure`)。**

**对于多重继承，重写函数的最派生的基协定必须显式重写具有相同函数签名的所有父协定。此外，如果一个契约从多个(不相关的)基础继承了相同的功能，则适用相同的要求。**

***下面是一个被覆盖函数的例子:***

# **支付功能**

**一个契约最多可以有一个 receive 函数，使用`receive() external payable { … }`声明(没有`function`关键字)。这个函数不能有参数，不能返回任何东西，必须有`external`可见性和`payable`状态可变性。它可以是虚拟的，可以重写，可以有修饰符。**

> ****⚠️Warning:** 接收功能只能依靠 2300 气体**

# **后备功能**

**一个契约最多可以有一个使用`fallback () external payable`或`fallback (bytes calldata _input) external payable returns (bytes memory _output)`声明的`fallback`函数(两者都没有`function`关键字)。该功能必须具有`external`可见性。它也可以是虚拟的，可以重写并可以有修饰符。**

> ****⚠️Warning:** 这个回退功能只能依靠 2300 气**

****功能修饰符****

**Solidity 支持**修饰符**，允许以声明方式改变函数的行为。它们类似于面向对象编程中的**装饰模式**。**

**`modify`关键字用于声明一个**函数修饰符**。**

**符号用于引用函数体，允许修饰符在可执行代码中包装函数。**

***下面是修饰语的基本结构:***

***下面是一个使用 modifies 的函数:***

**修饰符可以通过遵循与函数重写相同的规则来重写。**

# **接口**

**坚固性支持**接口**。接口可以保存**函数签名**、**结构类型**、&、**枚举类型**。**

**`interface`关键字用于声明一个接口。**

**接口内声明的所有函数必须是`external`。**

**默认情况下，所有函数都被隐式标记为`virtual`，首次实现时不需要显式的`override`。**

***这是一个界面的基本结构:***

**通过遵循与协定继承相同的规则，接口可以从其他接口继承。**

# **结构体**

**坚固性提供了一种将**复合类型**定义为**定制类型**的方法。**

**`struct`关键字用于声明一个结构。**

**复杂类型中对结构类型的所有局部引用都必须标记为`storage`。这存储了一个引用，该引用允许将结构成员赋值保持为状态。**

***这里是一个 struct 的基本结构:***

# **事件**

**Solidity 通过事件支持**日志**。所有**发出的事件**都存储在区块链内的**事务日志**中。**

**`event` & `emit`关键字分别用于**声明事件和**发出事件。**

**`index`关键字允许用主题记录事件**。所有不带 index 属性的参数都作为日志数据的一部分进行 ABI 编码。****

**默认情况下，事件的签名被散列化并成为一个主题。这可以通过用关键字`anonymous`声明事件来防止。匿名事件能够索引四个参数，而不是三个。**

> ****✏️指出:**事件的成本与数据量成线性比例。**

***下面是一个事件的基本结构:***

# **错误**

**坚固性在还原状态的同时抛出错误。**

**`error`关键字用于**声明错误**，而`revert()`函数用于**传递错误，同时恢复状态**。错误无法被捕获，除非它们是从外部调用中抛出的。**

**`require()`函数可用于评估一个条件，因为它在出错时隐式使用`revert()`。**

***下面是一个错误的基本结构:***

# **修饰语**

****修饰符**是修改变量和函数的**可见性&可变性**的特殊关键字。**

## **能见度**

**Solidity 有两类函数调用:**内部** & **外部**。内部呼叫是在合同内部进行的。**外部调用**，然而**直接调用 EVM**并依赖 **ABI 编码**。**

**四个可用的可见性修饰符是:`external`、`public`、`internal`、&、`private`:**

> **✏️ **注意:**外部函数比公共函数便宜**

*   **`external`函数是契约接口的一部分，也就是说只能外部调用。**
*   **`public`函数&变量是契约接口的一部分，可以在内部或外部调用。此外，getter 函数是为所有用这个修饰符声明的状态变量自动创建的。**
*   **`internal`函数&变量只能从契约或派生契约中调用。**
*   **`private`函数&变量仅在封装契约中可见。**

# **易变性**

**`constant`或`immutable`关键字可以用于更严格的**变量可变性**需求。**

> **✏️注意:这些限制性的修饰语比常规的状态变量要便宜**

*   **`constant`变量在声明时要求直接赋值。**
*   **`immutable`变量需要在编译时赋值。**

## **功能可变性**

**`view`和`pure`关键字可用于防止功能**读取**或**修改**状态。**

*   **`view`函数不能修改状态，但可以读取状态。**
*   **`pure`功能不能从状态中读取或写入。**

# **类型**

**Solidity 有一个**静态类型的**系统，而**不支持空性**。所有类型，无论是**初等**还是**复杂**，都可以归为三类之一:**值**、**引用**、& **映射**。**

## **值类型**

**一个**值类型**是一个**不会保持引用**的类型。该类型在被赋值时被**传递，而不是共享一个引用。****

**值类型类似于其他语言中的**原始类型**。**

***这里有一些值类型:***

**`bool`、`int`、`uint`、`string`、`address`、`bytes1`……`bytes32`、&、`enum`。**

## **参考类型**

**一个**引用类型**使用一个**引用**到**间接表示一个值**。这些值可以分配给**多个引用**，使得这些值可以从不同的名称空间进行修改。**

**引用类型包括**结构**，**数组**，& **映射**。**

**使用时，**引用类型**总是伴随着**位置说明符**来指示数据存储的位置。这样的说明符有三种:`calldata`、`memory`、&、`storage`。**

*   **`calldata`指定函数参数的临时数据位置。**
*   **`memory`指定外部调用存储器的临时数据位置。**
*   **`storage`指定状态变量的永久数据位置。**

## **映射类型**

****映射类型**的功能类似于**散列表**、**映射键值对**。键类型可以是任何内置值类型，其中值类型可以是任何实体类型。**

**映射类型使用语法`mapping(KeyType => ValueType)`。**

**访问映射类型中的值需要明确的键知识，因为所有键都存储为一个`keccak256`散列。这使得价值转储不可能，除非事先知道关键知识。**

**映射调用只有`storage`的数据位置。**

***这里有一个正在使用的映射类型:***

# **就是这样！**

**正如我在我的页面上所说的，这些是我个人笔记本上的笔记。如果有任何明显的错误，请随时留下评论，以便我可以修复它们。还有，如果有你想从我这里看到的内容，请告诉我！**

## **资源**

**Solidity 的文件:【https://docs.soliditylang.org/en/v0.8.15/ **