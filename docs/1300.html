<html>
<head>
<title>Cardano-client-lib: New composable functions to build transaction in Java— Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Cardano-client-lib:用Java构建事务的新的可组合函数——第一部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/cardano-client-lib-new-composable-functions-to-build-transaction-in-java-part-i-be3a8b4da835?source=collection_archive---------11-----------------------#2022-02-27">https://medium.com/coinmonks/cardano-client-lib-new-composable-functions-to-build-transaction-in-java-part-i-be3a8b4da835?source=collection_archive---------11-----------------------#2022-02-27</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/b159a9ee46e56e1ef84c3657aa5c242d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jnoVnR0NunTIJb0ug7qPeQ.png"/></div></div></figure><p id="35e9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><a class="ae jz" href="https://github.com/bloxbean/cardano-client-lib" rel="noopener ugc nofollow" target="_blank"><strong class="jd hu">Cardano-client-lib</strong></a>是针对<a class="ae jz" href="https://cardano.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jd hu"> Cardano </strong> </a>区块链的Java客户端库。它简化了从Java应用程序与卡尔达诺区块链的交互。使用这个库，您可以在Java应用程序中执行各种类型的事务。</p><p id="704b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">例如，您可以从一个地址转移到另一个地址，铸造令牌或NFT，并调用Java中的普路托斯智能合约。</p><p id="5c2e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这篇文章中，我将解释新引入的可组合函数API的概念。</p><blockquote class="ka kb kc"><p id="50cd" class="jb jc kd jd b je jf jg jh ji jj jk jl ke jn jo jp kf jr js jt kg jv jw jx jy hm dt translated">在本系列接下来的几篇文章中，我将介绍一些具体的例子，从常规转移到令牌铸造，再到使用可组合函数API的plutus契约调用。</p></blockquote><p id="bd01" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果您不熟悉<strong class="jd hu"> cardano-client-lib </strong>，它目前支持三种类型的API来构建/执行各种事务。</p><ol class=""><li id="8a48" class="kh ki ht jd b je jf ji jj jm kj jq kk ju kl jy km kn ko kp dt translated"><strong class="jd hu">高级API : </strong>提供简单的接口进行转账和代币交易。但是一些复杂的事务可能无法通过高级API完成。</li><li id="4e2f" class="kh ki ht jd b je kq ji kr jm ks jq kt ju ku jy km kn ko kp dt translated"><strong class="jd hu">低级API : </strong>这些是低级序列化API，用于为Cardano network构建事务。这些API非常灵活，适合复杂的场景。基本上，你可以用低级api实现任何复杂性，但同时这些API对初学者并不友好。</li><li id="88b1" class="kh ki ht jd b je kq ji kr jm ks jq kt ju ku jy km kn ko kp dt translated"><strong class="jd hu">可组合功能:</strong>这些API是在v0.2.0-beta2中引入的，它们在简单接口和灵活性之间提供了平衡。使用<strong class="jd hu">现成的</strong>可组合函数，您可以实现任何复杂性，同时，您可以编写自己的可组合函数来定制事务构建期间的行为。</li></ol><p id="eb68" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">所以在这篇文章中，我将重点介绍库中可组合函数的一般概念。</p></div><div class="ab cl kv kw hb kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hm hn ho hp hq"><h1 id="7d6a" class="lc ld ht bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz dt translated"><strong class="ak">可组合功能</strong></h1><p id="7b59" class="pw-post-body-paragraph jb jc ht jd b je ma jg jh ji mb jk jl jm mc jo jp jq md js jt ju me jw jx jy hm dt translated">该库的当前版本提供了一组<em class="kd"> FunctionalInterface </em>，可用于实现可组合的功能。这些函数可用于构建各种不同类型的事务。该库提供了这些函数的许多有用的现成实现。</p><p id="8bdc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">以下是主要的<em class="kd">功能界面</em></p><ol class=""><li id="3613" class="kh ki ht jd b je jf ji jj jm kj jq kk ju kl jy km kn ko kp dt translated"><strong class="jd hu"> TxBuilder </strong></li><li id="9b5e" class="kh ki ht jd b je kq ji kr jm ks jq kt ju ku jy km kn ko kp dt translated"><strong class="jd hu"> TxOutputBuilder </strong></li><li id="492c" class="kh ki ht jd b je kq ji kr jm ks jq kt ju ku jy km kn ko kp dt translated"><strong class="jd hu"> TxInputBuilder </strong></li><li id="de0a" class="kh ki ht jd b je kq ji kr jm ks jq kt ju ku jy km kn ko kp dt translated"><strong class="jd hu"> TxSigner </strong></li></ol><p id="bbcf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> TxBuilder : </strong>此功能接口帮助转换交易对象。该接口中的build方法将一个<em class="kd"> TxBuilderContext </em>和一个<em class="kd">事务</em>对象作为输入参数。该函数的作用是用附加属性转换输入事务对象或更新现有属性。</p><p id="41f0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> TxOutputBuilder : </strong>这个函数接口帮助构建一个<em class="kd"> TransactionOutput </em>对象，并将其添加到事务输出列表中。该接口中的<em class="kd"> accept </em>方法接受一个<em class="kd"> TxBuilderContext </em>和一个<em class="kd"> TransactionOutput </em>列表。</p><p id="5d98" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> TxInputBuilder : </strong>这个功能接口负责从预期的输出构建输入。</p><p id="9044" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> TxSigner : </strong>该接口负责提供交易签名功能。</p><h1 id="b7b5" class="lc ld ht bd le lf mf lh li lj mg ll lm ln mh lp lq lr mi lt lu lv mj lx ly lz dt translated">TxBuilderContext </h1><p id="61d6" class="pw-post-body-paragraph jb jc ht jd b je ma jg jh ji mb jk jl jm mc jo jp jq md js jt ju me jw jx jy hm dt translated">每个函数都将<em class="kd"> TxBuilderContext </em>作为第一个输入参数。<em class="kd"> TxBuilderContext </em>的主要职责是在事务构建过程中向函数提供<em class="kd"> UtxoSupplier </em>、<em class="kd"> ProtocolParamsSupplier、</em>UtxoSelectionStrategy等上下文数据以及一些临时数据。</p><h1 id="92e5" class="lc ld ht bd le lf mf lh li lj mg ll lm ln mh lp lq lr mi lt lu lv mj lx ly lz dt translated"><strong class="ak">函数助手</strong></h1><p id="fbdf" class="pw-post-body-paragraph jb jc ht jd b je ma jg jh ji mb jk jl jm mc jo jp jq md js jt ju me jw jx jy hm dt translated">该库通过帮助构建事务的助手类提供了许多现成的功能。所以你不需要从零开始，同时如果需要的话你可以写你自己的函数。</p><p id="0041" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在该库的当前版本中，可以使用以下助手类</p><ol class=""><li id="f285" class="kh ki ht jd b je jf ji jj jm kj jq kk ju kl jy km kn ko kp dt translated"><strong class="jd hu"> OutputBuilders : </strong>提供了创建<em class="kd"> TxOutputBuilder </em>函数的助手方法列表，该函数用于从<em class="kd"> TransactionOutput </em>或<em class="kd"> Output </em>对象创建<em class="kd"> TransactionOutput </em>。<em class="kd"> TxOutputBuilder </em>函数验证最小ada要求，并相应地更新<em class="kd">事务输出</em>中的ada数量。</li></ol><p id="74b0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该类中可用的一些帮助器方法有</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="ebc2" class="mt ld ht mp b fv mu mv l mw mx"><em class="kd">- </em>TxOutputBuilder createFromOutput(Output output)<br/></span><span id="caa1" class="mt ld ht mp b fv my mv l mw mx">- TxOutputBuilder createFromOutput(TransactionOutput txnOutput)<br/></span><span id="75d2" class="mt ld ht mp b fv my mv l mw mx">- TxOutputBuilder createFromMintOutput(Output output)<br/></span><span id="31d9" class="mt ld ht mp b fv my mv l mw mx">- TxOutputBuilder createFromMintOutput(TransactionOutput txnOutput)</span></pre><p id="51f6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您可以使用“<strong class="jd hu"> <em class="kd">和</em> </strong>”方法组合多个<em class="kd"> TxOutputBuilder </em>。</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="8517" class="mt ld ht mp b fv mu mv l mw mx">TxOutputBuilder txOutputBuilder = <strong class="mp hu">createFromOutput(output1)<br/>                                     .and(createFromOutput(output2))</strong></span></pre><blockquote class="ka kb kc"><p id="e806" class="jb jc kd jd b je jf jg jh ji jj jk jl ke jn jo jp kf jr js jt kg jv jw jx jy hm dt translated"><strong class="jd hu">注意:</strong>对于token minting交易，为了准确计算输出中所需的最小ada，mint outputs或createFromMintOutput()方法应该在所有常规输出或createFromOutput()方法之后调用。</p></blockquote><p id="032b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">2.<strong class="jd hu"> InputBuilders : </strong>提供助手方法来创建<em class="kd"> TxInputBuilder </em>函数，该函数用于使用<em class="kd"> TxOutputBuilder </em>的<em class="kd"> buildInputs </em>()方法从<em class="kd"> TransactionOutput </em>列表中构建所需的<em class="kd"> TransactionInput </em>。</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="72b6" class="mt ld ht mp b fv mu mv l mw mx">TxBuilder txBuilder = txOutputBuilder1<br/>                       .and(txOutputBuilder2)<br/>                       <strong class="mp hu">.buildInputs(createFromSender(senderAddress, changeAddress))</strong></span></pre><p id="0be2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该类中可用的一些帮助器方法有</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="6bee" class="mt ld ht mp b fv mu mv l mw mx">- TxInputBuilder createFromSender(String sender, String changeAddress)<br/></span><span id="b4a1" class="mt ld ht mp b fv my mv l mw mx">- TxInputBuilder createFromUtxos(List&lt;Utxo&gt; utxos)<br/></span><span id="7fb3" class="mt ld ht mp b fv my mv l mw mx">- TxInputBuilder createFromUtxos(Supplier&lt;List&lt;Utxo&gt;&gt; supplier)<br/></span><span id="0d24" class="mt ld ht mp b fv my mv l mw mx">- TxInputBuilder createFromUtxos(List&lt;Utxo&gt; utxos, String changeAddress)<br/></span><span id="0877" class="mt ld ht mp b fv my mv l mw mx">- TxInputBuilder createFromUtxos(List&lt;Utxo&gt; utxos, String changeAddress, Object datum)<br/></span><span id="8447" class="mt ld ht mp b fv my mv l mw mx">- TxInputBuilder createFromUtxos(List&lt;Utxo&gt; utxos, String changeAddress, String datumHash)</span></pre><p id="5307" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">3.<strong class="jd hu"> MintCreators : </strong>它提供了帮助方法来创建一个<em class="kd"> TxBuilder </em>函数，该函数用于将多资产铸造相关数据添加到<em class="kd">事务</em>对象中。</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="0acd" class="mt ld ht mp b fv mu mv l mw mx">TxBuilder txBuilder = txOuputBuilder1<br/>                        .and(txOuputBuilder2)<br/>                        .and(createFromMintOutput(mintOutput))<br/>                      .buildInputs(txInputBuilder)<br/>                     <strong class="mp hu"> .andThen(mintCreator(script, multiAsset)</strong></span></pre><blockquote class="ka kb kc"><p id="3eee" class="jb jc kd jd b je jf jg jh ji jj jk jl ke jn jo jp kf jr js jt kg jv jw jx jy hm dt translated"><strong class="jd hu">注意:</strong>对于mint交易，需要一个特定于mint输出的TxOutputBuilder。这可以通过调用output builders . createfrommintoutput方法之一来完成。</p></blockquote><p id="8680" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该类中可用的一些帮助器方法有</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="f113" class="mt ld ht mp b fv mu mv l mw mx">- TxBuilder mintCreator(Script script, MultiAsset multiAsset)<br/></span><span id="4144" class="mt ld ht mp b fv my mv l mw mx">- TxBuilder mintCreator(Script script, MultiAsset multiAsset, boolean inclScriptInAuxData)<br/></span></pre><p id="9fb5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">4.<strong class="jd hu"> AuxDataProviders : </strong>提供帮助方法来创建一个<em class="kd"> TxBuilder </em>函数，该函数用于向<em class="kd">事务</em>对象添加元数据。</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="f32e" class="mt ld ht mp b fv mu mv l mw mx">TxBuilder txBuilder = txOuputBuilder1<br/>                        .and(txOuputBuilder2)<br/>                      .buildInputs(txInputBuilder)<strong class="mp hu"><br/>                      .andThen(<em class="kd">metadataProvider</em>(metadata))</strong></span></pre><p id="0f7b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">5.<strong class="jd hu"> CollateralBuilders : </strong>提供助手方法来创建一个<em class="kd"> TxBuilder </em>函数，该函数用于将抵押品添加到plutus脚本事务中的<em class="kd">事务</em>对象。</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="9761" class="mt ld ht mp b fv mu mv l mw mx">TxBuilder txBuilder = txOuputBuilder1<br/>                        .and(txOuputBuilder2)<br/>                      .buildInputs(txInputBuilder)<br/>                      <strong class="mp hu">.andThen(<em class="kd">collateralFrom</em>(txHash, txIndex))</strong></span></pre><p id="84f0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该类中可用的一些帮助器方法有</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="6d20" class="mt ld ht mp b fv mu mv l mw mx">- TxBuilder collateralFrom(String txHash, int txIndex)<br/></span><span id="580f" class="mt ld ht mp b fv my mv l mw mx">- TxBuilder collateralFrom(List&lt;Utxo&gt; utxos)<br/></span><span id="0502" class="mt ld ht mp b fv my mv l mw mx">- TxBuilder collateralFrom(Supplier&lt;List&lt;Utxo&gt;&gt; supplier)</span></pre><p id="8e10" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">6.<strong class="jd hu">ScriptCallConextProviders:</strong>提供帮助器方法来创建<em class="kd"> TxBuilder </em>函数，该函数用于将plutus脚本特定数据添加到<em class="kd">事务</em>对象中。</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="913c" class="mt ld ht mp b fv mu mv l mw mx">TxBuilder txBuilder = txOuputBuilder1<br/>              .and(txOuputBuilder2)<br/>           .buildInputs(txInputBuilder)<br/>           .andThen(collateralFrom(txHash, txIndex))<br/>           <strong class="mp hu">.andThen(createFromScriptCallContext(scriptCallContext))</strong></span></pre><p id="bc19" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该类中可用的一些帮助器方法有</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="071c" class="mt ld ht mp b fv mu mv l mw mx">- TxBuilder createFromScriptCallContext(ScriptCallContext sc)<br/></span><span id="eeda" class="mt ld ht mp b fv my mv l mw mx">- TxBuilder scriptCallContext(PlutusScript plutusScript, Utxo utxo,              T datum, K redeemerData,RedeemerTag tag, ExUnits exUnits)<br/></span><span id="5448" class="mt ld ht mp b fv my mv l mw mx">- TxBuilder scriptCallContext(PlutusScript plutusScript, int scriptInputIndex, T datum, K redeemerData, RedeemerTag tag, ExUnits exUnits)</span></pre><p id="b3a0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">7.<strong class="jd hu"> FeeCalculators : </strong>提供帮助器方法来创建<em class="kd"> TxBuilder </em>函数，以计算费用并相应地更新<em class="kd">事务</em>对象。</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="cb38" class="mt ld ht mp b fv mu mv l mw mx">TxBuilder txBuilder = txOuputBuilder1<br/>                        .and(txOuputBuilder2)<br/>                      .buildInputs(txInputBuilder)<br/>                      .andThen(otherTxBuilder)<br/>                      ...<br/>                      <strong class="mp hu">.andThen(feeCalculator(changeAddress, noOfSigners))</strong></span></pre><blockquote class="ka kb kc"><p id="e45f" class="jb jc kd jd b je jf jg jh ji jj jk jl ke jn jo jp kf jr js jt kg jv jw jx jy hm dt translated"><strong class="jd hu">注:</strong>准确计算费用需要签名人数。例如，对于带有策略脚本的铸币交易，最小签名者数量是2。(铸造帐户，策略脚本密钥)</p></blockquote><p id="c1a9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这个助手类中创建<em class="kd"> TxBuilder </em>函数的助手方法有</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="aad1" class="mt ld ht mp b fv mu mv l mw mx">- TxBuilder feeCalculator(String changeAddress, int noOfSigners)<br/></span><span id="7fdd" class="mt ld ht mp b fv my mv l mw mx">- TxBuilder feeCalculator(int noOfSigners, UpdateOutputFunction updateOutputWithFeeFunc)</span></pre><p id="d612" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">8.<strong class="jd hu">ChangeOutputAdjustments:</strong>提供帮助器方法来创建<em class="kd"> TxBuilder </em>函数，该函数可以调整变更输出。此功能用于验证变更输出中的ada量是否满足最小ada要求。如果没有，它会尝试获取额外的输入，并在费用计算后调整变化输出。该功能在<em class="kd">费用计算</em>功能之后使用。</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="a389" class="mt ld ht mp b fv mu mv l mw mx">TxBuilder txBuilder = txOuputBuilder1<br/>             .and(txOuputBuilder2)<br/>             .buildInputs(txInputBuilder)<br/>             .andThen(otherTxBuilder)<br/>             ...<br/>             .andThen(feeCalculator(changeAddress, noOfSigners))<br/>             <strong class="mp hu">.andThen(<em class="kd">adjustChangeOutput</em>(senderAddress, changeAddress, noOfSigners))</strong></span></pre><p id="c5db" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">9.<strong class="jd hu"> SignerProviders : </strong>提供帮助器方法来创建<em class="kd"> TxSigner </em>函数来签署事务。</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="60bd" class="mt ld ht mp b fv mu mv l mw mx">TxSigner signer = <em class="kd">signerFrom</em>(sender1, sender2, ..., sendern)<br/>                   .andThen(signerFrom(secretKey1, ..., secretKeyn))</span></pre><p id="55a1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该类中可用的一些帮助器方法有</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="4d30" class="mt ld ht mp b fv mu mv l mw mx">- TxSigner signerFrom(Account... signers)</span><span id="b33a" class="mt ld ht mp b fv my mv l mw mx">- TxSigner signerFrom(SecretKey... secretKeys)</span><span id="bca0" class="mt ld ht mp b fv my mv l mw mx">- TxSigner signerFrom(Policy... policies)</span></pre><p id="3b22" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">10.<strong class="jd hu">MinAdaChecker:</strong>提供了一个helper方法来返回<em class="kd"> MinAdaChecker </em>函数。<em class="kd"> MinAdaChecker </em>函数返回<em class="kd"> TransactionOutput </em>满足最小ada要求所需的额外lovelace金额。该函数由其他函数的实现在内部使用。您可能不需要直接使用该功能。</p><h1 id="0bb0" class="lc ld ht bd le lf mf lh li lj mg ll lm ln mh lp lq lr mi lt lu lv mj lx ly lz dt translated"><strong class="ak">建立并签署交易</strong></h1><p id="e672" class="pw-post-body-paragraph jb jc ht jd b je ma jg jh ji mb jk jl jm mc jo jp jq md js jt ju me jw jx jy hm dt translated">在通过组合不同的函数创建了<em class="kd"> TxBuilder </em>之后，可以构建一个<em class="kd">事务</em>对象并对其进行签名。</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="f89e" class="mt ld ht mp b fv mu mv l mw mx">TxBuilder txBuilder = <em class="kd">createFromOutput</em>(output)<br/>        .buildInputs(<em class="kd">createFromSender</em>(senderAddress, senderAddress))<br/>        .andThen(<em class="kd">metadataProvider</em>(metadata))<br/>        .andThen(<em class="kd">feeCalculator</em>(senderAddress, 1))<br/>        .andThen(<em class="kd">adjustChangeOutput</em>(senderAddress, 1));</span><span id="1657" class="mt ld ht mp b fv my mv l mw mx">TxSigner signer = SignerProviders.signerFrom(sender);</span><span id="c6c5" class="mt ld ht mp b fv my mv l mw mx"><strong class="mp hu">/*** Create instance of UtxoSupplier &amp; ProtocolParamsSupplier ***/<br/></strong>UtxoSupplier utxoSupplier = new         DefaultUtxoSupplier(backendService.getUtxoService());</span><span id="4f53" class="mt ld ht mp b fv my mv l mw mx">ProtocolParamsSupplier protocolParamsSupplier = new DefaultProtocolParamsSupplier(backendService.getEpochService());</span><span id="72bd" class="mt ld ht mp b fv my mv l mw mx"><strong class="mp hu">/**** Build and Sign in one step ****/</strong><br/>Transaction signedTxn = <br/>     TxBuilderContext.<em class="kd">init</em>(utxoSupplier, protocolParamsSupplier)<br/>           .buildAndSign(txBuilder, signer);</span><span id="2d62" class="mt ld ht mp b fv my mv l mw mx"><strong class="mp hu">/**** OR, Build Txn and then sign using signer *****/</strong><br/>Transaction transaction = <br/>      TxBuilderContext.<em class="kd">init</em>(utxoSupplier, protocolParamsSupplier)<br/>           .build(txBuilder);<br/><br/>Transaction signedTxn = signer.sign(transaction);</span></pre><h1 id="ed8e" class="lc ld ht bd le lf mf lh li lj mg ll lm ln mh lp lq lr mi lt lu lv mj lx ly lz dt translated"><strong class="ak">向卡达诺网络提交交易</strong></h1><p id="884b" class="pw-post-body-paragraph jb jc ht jd b je ma jg jh ji mb jk jl jm mc jo jp jq md js jt ju me jw jx jy hm dt translated">一旦交易被签署，您就可以使用<em class="kd"> TransactionService </em>将它提交给网络。</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="9d10" class="mt ld ht mp b fv mu mv l mw mx">Result&lt;String&gt; result =           transactionService.submitTransaction(signedTxn.serialize());</span></pre><h1 id="e313" class="lc ld ht bd le lf mf lh li lj mg ll lm ln mh lp lq lr mi lt lu lv mj lx ly lz dt translated"><strong class="ak">添加您自己的TxBuilder实现</strong></h1><p id="e84b" class="pw-post-body-paragraph jb jc ht jd b je ma jg jh ji mb jk jl jm mc jo jp jq md js jt ju me jw jx jy hm dt translated">在某些场景下，需要提供自己的<em class="kd"> TxBuilder </em>等函数来转换事务对象。</p><p id="1315" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">举例:</strong> <br/>目前没有<em class="kd"> TxBuilder </em>函数在交易对象中设置<strong class="jd hu"> <em class="kd"> ttl </em> </strong>参数。但是您可以轻松地提供自己的实现来设置ttl或添加/更新其他参数。</p><pre class="mk ml mm mn fq mo mp mq mr aw ms dt"><span id="5e08" class="mt ld ht mp b fv mu mv l mw mx">TxBuilder txBuilder = txOuputBuilder1<br/>             .and(txOuputBuilder2)<br/>             .buildInputs(txInputBuilder)<br/>             .andThen(otherTxBuilder)<br/>             <strong class="mp hu">.andThen((context, transaction) -&gt; {<br/>                   transaction.getBody().setTtl(100000);</strong></span><span id="099e" class="mt ld ht mp b fv my mv l mw mx"><strong class="mp hu">                   //set or update other transaction parameters<br/>             })</strong><br/>             .andThen(feeCalculator(changeAddress, noOfSigners))</span></pre></div><div class="ab cl kv kw hb kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hm hn ho hp hq"><p id="1d19" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，在<strong class="jd hu">摘要</strong>中，要使用可组合函数API，请按照以下步骤构建一个事务</p><ol class=""><li id="8bff" class="kh ki ht jd b je jf ji jj jm kj jq kk ju kl jy km kn ko kp dt translated">定义预期输出</li><li id="e388" class="kh ki ht jd b je kq ji kr jm ks jq kt ju ku jy km kn ko kp dt translated">从输出创建一个或多个<em class="kd"> TxOutputBuilder </em></li><li id="4455" class="kh ki ht jd b je kq ji kr jm ks jq kt ju ku jy km kn ko kp dt translated">创建一个为发送者选择输入的<em class="kd"> TxInputBuilder </em></li><li id="0da0" class="kh ki ht jd b je kq ji kr jm ks jq kt ju ku jy km kn ko kp dt translated">对于多个发送者，可以重复步骤1至步骤3</li><li id="5acd" class="kh ki ht jd b je kq ji kr jm ks jq kt ju ku jy km kn ko kp dt translated">创建额外的<em class="kd">tx builder</em>以添加/更新交易中的不同属性。</li><li id="7e9e" class="kh ki ht jd b je kq ji kr jm ks jq kt ju ku jy km kn ko kp dt translated">创建<em class="kd"> TxSigner </em></li><li id="4775" class="kh ki ht jd b je kq ji kr jm ks jq kt ju ku jy km kn ko kp dt translated">调用<em class="kd">txbuildercontext . init()</em>初始化上下文，然后调用<em class="kd"> buildAndSign() </em>构建并签署事务。</li></ol></div><div class="ab cl kv kw hb kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="hm hn ho hp hq"><blockquote class="ka kb kc"><p id="157e" class="jb jc kd jd b je jf jg jh ji jj jk jl ke jn jo jp kf jr js jt kg jv jw jx jy hm dt translated">在本系列接下来的几篇文章中，我将通过一些具体的例子来介绍使用可组合函数API从常规转移到令牌铸造再到普路托斯契约调用。</p></blockquote><p id="d840" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">同时</strong>，你可以在这个<a class="ae jz" href="https://github.com/bloxbean/cardano-client-examples/tree/main/src/test/java/com/bloxbean/cardano/client/example/function" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到使用可组合函数的不同例子</p><h1 id="4b99" class="lc ld ht bd le lf mf lh li lj mg ll lm ln mh lp lq lr mi lt lu lv mj lx ly lz dt translated">资源</h1><ol class=""><li id="3cca" class="kh ki ht jd b je ma ji mb jm mz jq na ju nb jy km kn ko kp dt translated"><a class="ae jz" href="https://github.com/bloxbean/cardano-client-lib" rel="noopener ugc nofollow" target="_blank"> Cardano客户端库项目GitHub </a></li><li id="b84d" class="kh ki ht jd b je kq ji kr jm ks jq kt ju ku jy km kn ko kp dt translated"><a class="ae jz" href="https://github.com/bloxbean/cardano-client-examples" rel="noopener ugc nofollow" target="_blank"> Cardano客户端示例GitHub </a></li></ol><blockquote class="nc"><p id="ef4e" class="nd ne ht bd nf ng nh ni nj nk nl jy ek translated"><em class="nm">加入Coinmonks </em> <a class="ae jz" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank"> <em class="nm">电报频道</em> </a> <em class="nm">和</em> <a class="ae jz" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> <em class="nm"> Youtube频道</em> </a> <em class="nm">了解加密交易和投资</em></p></blockquote><h1 id="75ab" class="lc ld ht bd le lf mf lh li lj mg ll lm ln nn lp lq lr no lt lu lv np lx ly lz dt translated">另外，阅读</h1><ul class=""><li id="7969" class="kh ki ht jd b je ma ji mb jm mz jq na ju nb jy nq kn ko kp dt translated"><a class="ae jz" href="https://coincodecap.com/bookmap-review-2021-best-trading-software" rel="noopener ugc nofollow" target="_blank"> Bookmap点评</a> | <a class="ae jz" href="https://coincodecap.com/crypto-exchange-usa" rel="noopener ugc nofollow" target="_blank">美国5大最佳加密交易所</a></li><li id="63e3" class="kh ki ht jd b je kq ji kr jm ks jq kt ju ku jy nq kn ko kp dt translated">最佳加密<a class="ae jz" rel="noopener" href="/coinmonks/hardware-wallets-dfa1211730c6">硬件钱包</a> | <a class="ae jz" rel="noopener" href="/coinmonks/bitbns-review-38256a07e161"> Bitbns评论</a></li><li id="7760" class="kh ki ht jd b je kq ji kr jm ks jq kt ju ku jy nq kn ko kp dt translated"><a class="ae jz" href="https://coincodecap.com/crypto-exchange-in-singapore" rel="noopener ugc nofollow" target="_blank">新加坡十大最佳加密交易所</a> | <a class="ae jz" href="https://coincodecap.com/buy-axs-token" rel="noopener ugc nofollow" target="_blank">购买AXS </a></li><li id="d7f7" class="kh ki ht jd b je kq ji kr jm ks jq kt ju ku jy nq kn ko kp dt translated"><a class="ae jz" href="https://coincodecap.com/red-dog-casino-review" rel="noopener ugc nofollow" target="_blank">红狗赌场评论</a> | <a class="ae jz" href="https://coincodecap.com/swyftx-review" rel="noopener ugc nofollow" target="_blank"> Swyftx评论</a> | <a class="ae jz" href="https://coincodecap.com/coingate-review" rel="noopener ugc nofollow" target="_blank"> CoinGate评论</a></li><li id="a315" class="kh ki ht jd b je kq ji kr jm ks jq kt ju ku jy nq kn ko kp dt translated"><a class="ae jz" href="https://coincodecap.com/best-crypto-to-invest-in-india-in-2021" rel="noopener ugc nofollow" target="_blank">投资印度的最佳密码</a>|<a class="ae jz" href="https://coincodecap.com/wazirx-p2p" rel="noopener ugc nofollow" target="_blank">WazirX P2P</a>|<a class="ae jz" href="https://coincodecap.com/hi-dollar-review" rel="noopener ugc nofollow" target="_blank">Hi Dollar Review</a></li><li id="f875" class="kh ki ht jd b je kq ji kr jm ks jq kt ju ku jy nq kn ko kp dt translated"><a class="ae jz" href="https://coincodecap.com/5-best-crypto-trading-bots-in-canada" rel="noopener ugc nofollow" target="_blank">加拿大最佳加密交易机器人</a> | <a class="ae jz" href="https://coincodecap.com/kucoin-review" rel="noopener ugc nofollow" target="_blank">库币评论</a></li><li id="f659" class="kh ki ht jd b je kq ji kr jm ks jq kt ju ku jy nq kn ko kp dt translated"><a class="ae jz" href="https://coincodecap.com/huobi-crypto-trading-signals" rel="noopener ugc nofollow" target="_blank">用于Huobi的加密交易信号</a> | <a class="ae jz" rel="noopener" href="/coinmonks/hitbtc-review-c5143c5d53c2"> HitBTC审查</a></li><li id="ed93" class="kh ki ht jd b je kq ji kr jm ks jq kt ju ku jy nq kn ko kp dt translated"><a class="ae jz" href="https://coincodecap.com/ftx-futures-trading" rel="noopener ugc nofollow" target="_blank">如何在FTX交易所交易期货</a> | <a class="ae jz" href="https://coincodecap.com/okex-vs-binance" rel="noopener ugc nofollow" target="_blank"> OKEx vs币安</a></li></ul></div></div>    
</body>
</html>