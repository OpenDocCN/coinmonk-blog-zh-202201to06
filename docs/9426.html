<html>
<head>
<title>Deploying and querying subgraph using The Graph protocol</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用图协议部署和查询子图</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/deploying-and-querying-subgraph-using-the-graph-protocol-826a05db30ac?source=collection_archive---------7-----------------------#2022-06-27">https://medium.com/coinmonks/deploying-and-querying-subgraph-using-the-graph-protocol-826a05db30ac?source=collection_archive---------7-----------------------#2022-06-27</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/b8fa58e802f78107d9f51e9c92731162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rUoGmZRy7YQSJW5g"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Photo by <a class="ae jf" href="https://unsplash.com/@theshubhamdhage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Shubham Dhage</a> on <a class="ae jf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="94ee" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在本帖中，我们将揭示图是什么，以及我们如何使用它在它的<a class="ae jf" href="https://thegraph.com/hosted-service/" rel="noopener ugc nofollow" target="_blank">托管服务</a>上部署子图。首先让我们了解一下查询层。</p><h2 id="4c0e" class="ke kf ht bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated">查询层</h2><p id="2575" class="pw-post-body-paragraph jg jh ht ji b jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ld kb kc kd hm dt translated">虽然区块链和存储网络是堆栈的关键组件，但数据很少以可以在应用程序中直接使用的格式存储。在获取数据之前，应用程序需要对数据进行过滤、排序、分页、分组和连接。用户不喜欢查看微调器并等待屏幕加载。</p><p id="b642" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如今，团队正在构建集中式索引服务器。这些服务器从以太坊获取数据，存储在数据库中，并通过API公开。这是脆弱的，因为用户需要信任这些团队来继续正确地操作这些服务器。这些项目可能会停业，出于战略原因修改数据，被收购，或者只是犯错误。突然间，我们离web2的起点不远了。</p><blockquote class="le lf lg"><p id="1875" class="jg jh lh ji b jj jk jl jm jn jo jp jq li js jt ju lj jw jx jy lk ka kb kc kd hm dt translated">交易新手？试试<a class="ae jf" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a>或者<a class="ae jf" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote><h2 id="f91e" class="ke kf ht bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated">满足-图表</h2><p id="bc13" class="pw-post-body-paragraph jg jh ht ji b jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ld kb kc kd hm dt translated">该图通过一个分散式协议解决了这一问题，该协议可以索引并实现高性能、高效的区块链数据查询，而无需您启动自己的集中式索引器，从长远来看，这可能很难维护。这些API(<em class="lh">索引的“子图”</em>)可以用标准的GraphQL API进行查询。今天，有一个托管服务和一个具有相同功能的分散式协议。两者都由图节点的开源实现支持。</p><p id="9b34" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们将部署和查询<strong class="ji hu">无聊猿亚奇俱乐部</strong> (BAYC) NFT合同。合同地址为:<a class="ae jf" href="https://etherscan.io/token/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d" rel="noopener ugc nofollow" target="_blank"><em class="lh">0x BC 4c A0 EDA 7647 A8 ab 7 c 2061 C2 e 118 a18 a 936 f13 d</em></a></p></div><div class="ab cl ll lm hb ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hm hn ho hp hq"><h2 id="db20" class="ke kf ht bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated">托管服务设置</h2><ol class=""><li id="ab5f" class="ls lt ht ji b jj kz jn la jr lu jv lv jz lw kd lx ly lz ma dt translated">去<a class="ae jf" href="https://thegraph.com/hosted-service/" rel="noopener ugc nofollow" target="_blank">https://thegraph.com/hosted-service/</a>注册托管服务。</li><li id="b71e" class="ls lt ht ji b jj mb jn mc jr md jv me jz mf kd lx ly lz ma dt translated">进入<a class="ae jf" href="https://thegraph.com/hosted-service/dashboard" rel="noopener ugc nofollow" target="_blank">仪表板</a>，点击<em class="lh">“添加子图”</em>，根据需要填写必要的项目详情。</li></ol><figure class="mh mi mj mk fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mg"><img src="../Images/002953688df9fbd2cbccd4833310d202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NuNw7gYONVIb2xUFL2ahUQ.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">After filling up relevant fields</figcaption></figure><p id="a78e" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">转到您的CLI，使用<code class="eh ml mm mn mo b">mkdir graph-projects &amp;&amp; cd graph-projects</code>创建一个新目录。安装<code class="eh ml mm mn mo b">graph-cli</code>工具，然后使用<code class="eh ml mm mn mo b">graph init</code>命令初始化基于托管服务的图形:</p><pre class="mh mi mj mk fq mp mo mq mr aw ms dt"><span id="72be" class="ke kf ht mo b fv mt mu l mv mw">npm install @graphprotocol/graph-cli -g<br/>graph init --product hosted-service &lt;GITHUB_USER&gt;/&lt;SUBGRAPH_NAME&gt;</span></pre><ul class=""><li id="fba9" class="ls lt ht ji b jj jk jn jo jr mx jv my jz mz kd na ly lz ma dt translated"><code class="eh ml mm mn mo b">GITHUB_USER</code>:您的组织或GitHub用户的名称</li><li id="df63" class="ls lt ht ji b jj mb jn mc jr md jv me jz mf kd na ly lz ma dt translated"><code class="eh ml mm mn mo b">SUBGRAPH_NAME</code>:你想给你的子图起的名字(例如“Bayc ”)</li></ul><p id="2aa6" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">接下来，您将看到许多需要在CLI中提供的选项/配置。只需按照下图所示填写配置字段，然后等待安装完成。</p><figure class="mh mi mj mk fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nb"><img src="../Images/d16a9329037a3bc5716e91d6b72da8f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DDHRYOvFoDKymzLINkW4bQ.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">CLI after init command</figcaption></figure><p id="4c93" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">您现在可以看到正在创建的<code class="eh ml mm mn mo b">Bayc</code>目录，这也是您的子图名称。用<code class="eh ml mm mn mo b">cd Bayc</code>进入那个目录，然后执行<code class="eh ml mm mn mo b">npm init -y</code>初始化package.json。</p><figure class="mh mi mj mk fq iu fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/df00eafdb1e9f611a6d75209e96f9696.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*PXhfPMF8haKu7ay2lrADSg.png"/></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Directory structure (now)</figcaption></figure></div><div class="ab cl ll lm hb ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hm hn ho hp hq"><h2 id="bce7" class="ke kf ht bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated">什么是子图？</h2><blockquote class="le lf lg"><p id="a684" class="jg jh lh ji b jj jk jl jm jn jo jp jq li js jt ju lj jw jx jy lk ka kb kc kd hm dt translated">子图定义了图将从区块链中索引哪些数据，以及它将如何存储这些数据。一旦它被部署，它将形成区块链数据全局图的一部分，您可以使用GraphQL来检索它。子图定义由几个文件组成:</p></blockquote><ul class=""><li id="1688" class="ls lt ht ji b jj jk jn jo jr mx jv my jz mz kd na ly lz ma dt translated"><code class="eh ml mm mn mo b">subgraph.yaml</code>:包含子图清单的YAML文件(例如，要查询哪个区块链，合同地址等)。)</li><li id="910e" class="ls lt ht ji b jj mb jn mc jr md jv me jz mf kd na ly lz ma dt translated"><code class="eh ml mm mn mo b">schema.graphql</code>:GraphQL模式，定义了为子图存储什么数据，以及如何通过graph QL查询它</li><li id="8f51" class="ls lt ht ji b jj mb jn mc jr md jv me jz mf kd na ly lz ma dt translated"><code class="eh ml mm mn mo b">AssemblyScript Mappings</code> : <a class="ae jf" href="https://github.com/AssemblyScript/assemblyscript" rel="noopener ugc nofollow" target="_blank"> AssemblyScript </a>(类似于typescript，但更严格)代码，将事件数据转换为模式中定义的实体(例如本教程中的<code class="eh ml mm mn mo b">bored-ape-yatch-club.ts</code>)</li><li id="0940" class="ls lt ht ji b jj mb jn mc jr md jv me jz mf kd na ly lz ma dt translated"><em class="lh">遗憾的是，async/await尚未在AssemblyAcript中实现</em></li></ul></div><div class="ab cl ll lm hb ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hm hn ho hp hq"><h2 id="c9fc" class="ke kf ht bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated">创建子图清单</h2><p id="a168" class="pw-post-body-paragraph jg jh ht ji b jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ld kb kc kd hm dt translated">我们将从建立我们的<code class="eh ml mm mn mo b">subgraph.yaml</code>文件开始。Graph auto使用预定义的值为您创建yaml。我们将关注的是<strong class="ji hu">转会事件</strong>为<strong class="ji hu"> </strong>我们的BAYC smartcontract。删除<code class="eh ml mm mn mo b">eventHandlers:</code>中的其他事件，复制/粘贴相关字段。</p><figure class="mh mi mj mk fq iu"><div class="bz el l di"><div class="nd ne l"/></div></figure><p id="0344" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我们增加了<code class="eh ml mm mn mo b">startBlock</code>不允许索引器从genesis开始索引。因为那会很费时间。12287507块包括区块链以太坊的BAYC合同创建代码。</p><pre class="mh mi mj mk fq mp mo mq mr aw ms dt"><span id="d529" class="ke kf ht mo b fv mt mu l mv mw">event: Transfer(indexed address, indexed address, indexed uint256)              handler: handleTransfer</span></pre><p id="f8a9" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh ml mm mn mo b">datasources.mapping.eventHandlers.handler</code></p><p id="81df" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh ml mm mn mo b">dataSources.mapping.entities</code>由定义数据源将哪些实体写入存储的条目组成。<code class="eh ml mm mn mo b">schema.graphql</code>为每个实体定义模式。(稍后将详细介绍)</p><p id="8390" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh ml mm mn mo b">dataSources.mapping.abis</code>由源契约的ABI文件和您在映射中与之交互的任何其他智能契约组成。</p><p id="60c7" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh ml mm mn mo b">file: ./bored-ape-yatch-club.ts</code>具有中定义的所有映射器功能。yaml文件来处理业务逻辑，以便您的子图查询可以返回响应。我们将在本教程的后面填充这个<em class="lh"> handleTransfer() </em> mapper函数。</p></div><div class="ab cl ll lm hb ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hm hn ho hp hq"><h2 id="e1e2" class="ke kf ht bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated">定义子图模式</h2><p id="17cd" class="pw-post-body-paragraph jg jh ht ji b jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ld kb kc kd hm dt translated">现在，我们的YAML配置已经完成。我们需要定义我们的<code class="eh ml mm mn mo b">schema.graphql</code>实体定义。每一个查询都是针对我们的子图索引的实体和我们将要在子图模式中定义的数据模型进行的。将实体字段视为数据对象，您将得到响应。我们将在YAML文件中使用上述实体名称。</p><figure class="mh mi mj mk fq iu"><div class="bz el l di"><div class="nd ne l"/></div></figure><p id="d102" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">定义很简单！只要确保用<code class="eh ml mm mn mo b">@entity</code>关键字注释每种类型。然后在你的实体中添加你希望你的子图查询的字段，例如，tokenID，contentURI，baseURI，甚至是traits(traits将从IPFS查询中获取，敬请关注！).</p><p id="efcd" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">添加<code class="eh ml mm mn mo b">@derivedFrom</code>字段被称为<strong class="ji hu">反向查找。</strong>这样做将在实体上创建一个<em class="lh">虚拟字段</em>,它是从在另一个实体上定义的关系中派生出来的。根据文件:</p><blockquote class="le lf lg"><p id="b33e" class="jg jh lh ji b jj jk jl jm jn jo jp jq li js jt ju lj jw jx jy lk ka kb kc kd hm dt translated">您可以通过只存储关系的一端并派生另一端来提高索引和查询性能。几乎在所有情况下，都不建议存储关系的双方。</p></blockquote><p id="a7cb" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">通过在数组([]) 中引用<em class="lh">虚拟字段，派生字段也可以有<strong class="ji hu">一对多关系</strong>。这里(！)基本意思是<em class="lh">不可空字段</em>。在这种情况下，我们有不可空的<strong class="ji hu">令牌</strong>，它是从另一个实体字段<strong class="ji hu"> </strong>即<strong class="ji hu">所有者中派生出来的。</strong>BoredApeTokens</em>中的owner字段应该引用<em class="lh"> BoredApeUser </em>实体，以便维护关系/引用。</p><pre class="mh mi mj mk fq mp mo mq mr aw ms dt"><span id="2be1" class="ke kf ht mo b fv mt mu l mv mw">tokens: [BoredApeTokens!]! @derivedFrom(field: "owner")</span></pre><p id="0f01" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在图中，我们还可以通过启用全文搜索查询，使用文本搜索输入来过滤和排列实体。您可以通过在GraphQL模式中包含带有<code class="eh ml mm mn mo b"><em class="lh">fulltext</em></code> <em class="lh"> </em>指令的<code class="eh ml mm mn mo b">_Schema_</code>类型来添加全文查询。您可以选择在查询中对哪个实体进行<code class="eh ml mm mn mo b">include</code>，以及该实体的具体<code class="eh ml mm mn mo b">fields</code>。</p><pre class="mh mi mj mk fq mp mo mq mr aw ms dt"><span id="8230" class="ke kf ht mo b fv mt mu l mv mw">type _Schema_  @fulltext(    <br/>     name: "apeFilter"    <br/>     language: en    <br/>     algorithm: rank    <br/>     include: [{    <br/>          entity: "BoredApeToken"        <br/>          fields: [{ name: "eyes" }, { name: "background" }]   <br/>     }]  <br/>)</span></pre></div><div class="ab cl ll lm hb ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hm hn ho hp hq"><h2 id="372a" class="ke kf ht bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated">编写映射</h2><p id="a82f" class="pw-post-body-paragraph jg jh ht ji b jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ld kb kc kd hm dt translated">作为将响应(即区块链数据)转换为模式中定义的实体的业务逻辑，映射是必要的。在编写映射之前，有必要运行:</p><pre class="mh mi mj mk fq mp mo mq mr aw ms dt"><span id="a298" class="ke kf ht mo b fv mt mu l mv mw">npm run codegen</span></pre><p id="8be3" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">对于<code class="eh ml mm mn mo b">subgraph.yaml</code>中提到的ABI文件中的每一个智能契约，命令都会生成一个AssemblyScript类，帮助我们:</p><ul class=""><li id="68ab" class="ls lt ht ji b jj jk jn jo jr mx jv my jz mz kd na ly lz ma dt translated">对实体字段的读写权限</li><li id="dd50" class="ls lt ht ji b jj mb jn mc jr md jv me jz mf kd na ly lz ma dt translated">一个save()方法来写实体存储</li><li id="8556" class="ls lt ht ji b jj mb jn mc jr md jv me jz mf kd na ly lz ma dt translated">类型安全的实体加载</li></ul><p id="c863" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">另外，确保您已经在<code class="eh ml mm mn mo b">eventHandlers:</code>内的YAML文件中声明了映射。在我们带有Bayc契约的示例子图中，<code class="eh ml mm mn mo b">src/bored-ape-yacht-club.ts</code>包括智能契约的<code class="eh ml mm mn mo b">Transfer</code>事件的映射处理程序定义。</p><p id="0d58" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这里是为<code class="eh ml mm mn mo b">handleTransfer</code>映射处理器写的代码，它接受<code class="eh ml mm mn mo b">Transfer</code>事件引用作为参数。</p><figure class="mh mi mj mk fq iu"><div class="bz el l di"><div class="nd ne l"/></div></figure><p id="045c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">映射用<code class="eh ml mm mn mo b">new BoredApeToken(event.params.tokenId.toString())</code>创建一个新的<code class="eh ml mm mn mo b">BoredApeToken</code>实体。实体字段通过使用相应的<em class="lh">事件</em>参数对象来填充。变量<code class="eh ml mm mn mo b">entityToken</code>代表这个实体实例，并具有相应的<code class="eh ml mm mn mo b">id</code>值<code class="eh ml mm mn mo b">event.params.tokenId.toString()</code>。</p><p id="0f10" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">映射中的<strong class="ji hu"> <em class="lh"> load </em> </strong>处理程序访问Graph节点并试图加载一个已经存在的<code class="eh ml mm mn mo b">BoredApeToken</code>。如果BoredApeToken尚不存在，则按需创建。在使用<code class="eh ml mm mn mo b">entityToken.save()</code>将实体保存回节点的存储之前，它被更新以匹配新的事件参数。类似的情况也适用于我们模式中的其他实体<code class="eh ml mm mn mo b">BoredApeUser</code>，但是因为派生字段是在查询时构建的，所以您不应该在映射中编写这样的代码，就像您在上面的代码中看到的那样。我们还没有在映射中为<code class="eh ml mm mn mo b">BoredApeUser</code>模式中的<strong class="ji hu">令牌</strong>字段添加值。</p><p id="7743" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">通过使用ipfs散列，我们的子图将能够使用ipfs.cat和ipfs.map从IPFS读取相应的文件。在我们的例子中，我们使用ipfs.cat来获取<em class="lh"> bayc契约元数据。</em></p><pre class="mh mi mj mk fq mp mo mq mr aw ms dt"><span id="86e1" class="ke kf ht mo b fv mt mu l mv mw">let data = ipfs.cat(hash);      <br/>if (!data) return;      <br/>let value = json.fromBytes(data).toObject();</span></pre><p id="cafb" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">文件数据将作为<code class="eh ml mm mn mo b">Bytes</code>返回，这通常需要进一步的处理。我们使用了<code class="eh ml mm mn mo b">json.fromBytes(data)</code>,它将给定的blob数据转换成json表示。<code class="eh ml mm mn mo b">toObject()</code>将json转换成对象格式，方便我们查询元数据。例如，如果我们想要来自元数据的图像字段，我们可以做类似<code class="eh ml mm mn mo b">value.get("image")</code>的事情，如果我们想要来自元数据的属性字段(对象数组)，我们可以写- <code class="eh ml mm mn mo b">value.get("attributes")</code> …然后我们可以做进一步的处理来填充我们的模式字段:</p><pre class="mh mi mj mk fq mp mo mq mr aw ms dt"><span id="b444" class="ke kf ht mo b fv mt mu l mv mw">let attributes: JSONValue[] = [];        <br/>let atts = value.get("attributes");        <br/>if (atts) {          <br/>   attributes = atts.toArray();        <br/>}        </span><span id="f4be" class="ke kf ht mo b fv nf mu l mv mw">for (let i = 0; i &lt; attributes.length; i++) {          <br/>   let item = attributes[i].toObject();          <br/>   let trait: string = "";          <br/>   let t = item.get("trait_type");          <br/>   if (t) {            <br/>      trait = t.toString();          <br/>   }          <br/>   <br/>   let value: string = "";          <br/>   let v = item.get("value");          <br/>   if (v) {            <br/>      value = v.toString();          <br/>   }  <br/>        <br/>   if (trait == "Mouth") {            <br/>      entityToken.mouth = value;          <br/>   } <br/>         <br/>   if (trait == "Eyes") {            <br/>      entityToken.eyes = value;          <br/>   }<br/>   ...<br/>   ...<br/>}</span><span id="da14" class="ke kf ht mo b fv nf mu l mv mw">...<br/>entityToken.save();</span></pre><p id="e766" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">映射部分就到此为止。现在我们所要做的就是将我们的代码部署到图中的<strong class="ji hu">托管服务</strong>。</p></div><div class="ab cl ll lm hb ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hm hn ho hp hq"><p id="835b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">首先，用<code class="eh ml mm mn mo b">npm run build</code>构建代码，构建完成后，就该为图认证设置访问令牌了。进入您的CLI，键入:</p><pre class="mh mi mj mk fq mp mo mq mr aw ms dt"><span id="a2b1" class="ke kf ht mo b fv mt mu l mv mw">graph auth --product hosted-service &lt;ACCESS_TOKEN&gt;</span></pre><p id="5212" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">其中<access_token>是您之前在项目仪表板中设置托管服务时获得的令牌字符串。</access_token></p><p id="6272" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">成功完成后，是时候将您的代码部署到您的托管服务了:</p><pre class="mh mi mj mk fq mp mo mq mr aw ms dt"><span id="8c2f" class="ke kf ht mo b fv mt mu l mv mw">graph deploy --product hosted-service &lt;GITHUB_USER&gt;/&lt;SUBGRAPH NAME&gt;</span></pre><figure class="mh mi mj mk fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ng"><img src="../Images/7d0f10c26120906e1ea9762a60ae4afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IAh5NXEaJ7FveWHA0kcNWg.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Playground after deployment (appears in dash)</figcaption></figure><p id="511c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">就是这样，法国人！它现在被部署到您的托管服务的最新版本。</p><blockquote class="le lf lg"><p id="6999" class="jg jh lh ji b jj jk jl jm jn jo jp jq li js jt ju lj jw jx jy lk ka kb kc kd hm dt translated">注:有时更新可能不可见，在这种情况下，您可以前往<strong class="ji hu">？version=pending </strong> route(只需将它附加在游乐场页面的末尾)</p></blockquote><p id="3ad1" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">现在，您可以尝试操场和干涉您的子图查询。这只是关于如何部署/编写子图的基本概述。我建议您更多地将GraphQL作为一种语言来探索，并通过成为子图开发人员来尝试为dapps提取尽可能多的数据:)</p><p id="4db7" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">下面是演示:<a class="ae jf" href="https://thegraph.com/hosted-service/subgraph/gautamraju15/bayc-indexer" rel="noopener ugc nofollow" target="_blank">https://the graph . com/hosted-service/subgraph/gautamaraju 15/bayc-indexer</a>(注意:sub graph的名字是bayc-indexer，因为它已经被我部署了)</p><p id="10c0" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">干杯。</p></div></div>    
</body>
</html>