<html>
<head>
<title>Exploring Prim’s Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Prim算法</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/exploring-prims-algorithm-3fc8170fbf11?source=collection_archive---------33-----------------------#2022-04-10">https://medium.com/coinmonks/exploring-prims-algorithm-3fc8170fbf11?source=collection_archive---------33-----------------------#2022-04-10</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/a5486779f95ef557ce647f34c70ed9d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*QQoK3e2z5M3tNsK1c_04Dg.png"/></div></figure><p id="f1af" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">大多数感兴趣的算法都是对数据进行操作的。有一些组织数据的安排在算法的设计和分析中起着关键的作用。简而言之，我们可以说数据结构就是组织数据的简单方式。</p><p id="a0e8" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">数据结构有两种类型，线性或非线性。链表和数组是线性数据结构的例子。树和图是一些类型的非线性数据结构。</p><p id="14d1" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">算法是解决问题的方法。在这篇博客中，我们将探索Prims算法，该算法用于从图中寻找最小生成树。</p><p id="a728" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在开始Prims算法之前，让我们先了解几个术语:</p><ol class=""><li id="be8f" class="jv jw ht iz b ja jb je jf ji jx jm jy jq jz ju ka kb kc kd dt translated">图:图是一种数据结构，本质上是非线性的，由节点和边组成。这里的节点有时也称为顶点，边是连接图中任意两个节点的线或弧。</li></ol><figure class="kf kg kh ki fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="fe ff ke"><img src="../Images/7252a763a0e1aaa9b8df1c0e2df04905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oz3iNR4MaH_NDoozJPRXDw.png"/></div></div></figure><p id="e33e" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">2.树:树也是一种非线性数据结构，其结构类似于图形。树的主要区别在于树的两个顶点之间只有一条路径。两个顶点之间不能有多条路线。</p><figure class="kf kg kh ki fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="fe ff kn"><img src="../Images/1b0c1016be465807d8e4207cba79fd0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nYUOm4z7ogX7uNej3s7iSg.png"/></div></div></figure><p id="fbfb" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">3.最小生成树:最小生成树是图中连接每个顶点并使边的总数最小的边的子集。赋予生成树的边的权重的总和就是生成树的权重。</p><figure class="kf kg kh ki fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="fe ff ko"><img src="../Images/1236c55369d41c32ba83f2991c76bf2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NV-Hk155zwcAFSm-x7RdGQ.png"/></div></div></figure><p id="ef48" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在我们进入讨论的主要话题，Prim的算法。这是一种贪婪算法，用来寻找最小生成树。Prim的算法识别包括图中每个顶点的边的子集，并允许边权重的总和最小化。我们从随机选取任何一个节点开始，然后通过连接其他节点继续前进，确保我们没有制作一个图，也就是说，从一个节点到另一个节点只有一条路。</p><p id="fde3" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">算法:</p><p id="8995" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">步骤1:随机选择一个起始节点。</p><p id="0fb9" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">第二步:重复第三步和第四步，直到出现边缘节点。</p><p id="0b6d" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">步骤3:选择连接树节点和边缘节点的具有最小权重的边“e”</p><p id="beb1" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">步骤4:将选择的节点和边添加到最小生成树T中</p><p id="40cf" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">[循环结束]</p><p id="fc2d" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">第五步:退出</p><p id="d433" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在，让我们看一个例子:</p><figure class="kf kg kh ki fq iu fe ff paragraph-image"><div class="fe ff kp"><img src="../Images/af4cf38b571c2981cf414df44070dc4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*6Q8DDXfkLcjRVousbsyH8w.png"/></div></figure><p id="b70e" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">第一步</strong> —首先，我们必须从上图中随机选择一个节点。我们选b吧。</p><figure class="kf kg kh ki fq iu fe ff paragraph-image"><div class="fe ff kq"><img src="../Images/82751df63f58d29b6d442645764a4478.png" data-original-src="https://miro.medium.com/v2/resize:fit:182/format:webp/1*HvyEox2WB4EOXGmwG41Zog.png"/></div></figure><p id="21ad" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">第二步— </strong>现在我们必须选择并组合从顶点B开始的最短边，从顶点B开始有两条边:B到C，权重为10，B到D，权重为4。边BD具有所有边中最轻的权重。因此，将其添加到MST中。</p><figure class="kf kg kh ki fq iu fe ff paragraph-image"><div class="fe ff kr"><img src="../Images/43c99816848b62106cb3f950fc828e33.png" data-original-src="https://miro.medium.com/v2/resize:fit:388/format:webp/1*pDf0o8qK2dagh1-664ylyQ.png"/></div></figure><p id="26f9" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">第三步</strong> —在所有的边中，选择权重最小的一条。在这种情况下，边DE和CD是这种边的例子。将它们添加到MST，并调查C旁边的区域，即E和a。结果，选择边DE并将其添加到MST。</p><figure class="kf kg kh ki fq iu fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/fb1805930cdfa3e6d424e912c96904cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*borzpY5HA-fgMMOg8MsGiw.png"/></div></figure><p id="2bf1" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">步骤4 </strong> —现在，我们可以看到CD上的重量最小，选择边缘CD，并将其添加到MST。</p><figure class="kf kg kh ki fq iu fe ff paragraph-image"><div class="fe ff kt"><img src="../Images/8c1a66ba4bd6a0da393cfc1e509e922c.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*2BwV2t2YeDbJhzpSaB5ORw.png"/></div></figure><p id="9829" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated"><strong class="iz hu">步骤5 </strong> —现在，我们可以看到节点A是唯一剩下的节点，它只连接到C，因此我们选择边缘CA并将其添加到MST。</p><p id="0198" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在我们可以计算MST的成本，如下所示-</p><p id="85ab" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">MST的成本= 4 + 2 + 1 + 3 = 10个单位。</p><p id="a404" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我希望这篇博客能让你对Prim的算法有更好的理解。</p></div></div>    
</body>
</html>