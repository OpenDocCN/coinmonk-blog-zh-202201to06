# 初学者的可靠性

> 原文：<https://medium.com/coinmonks/solidity-for-beginners-89fd67465cb?source=collection_archive---------19----------------------->

这些年来，网络发生了巨大的变化，它现在的应用程序与早期相比已经面目全非。web 的发展通常分为三个阶段:Web 1.0、Web 2.0 和 Web 3.0。

旨在实现去中心化并使用区块链来实现这一壮举的 web 3.0 现在几乎处于初级阶段，任何现在进入它的人都是众所周知的早起鸟，为了在 web 3 上开发应用程序和编写智能合同，使用了两种语言，即 solidity 和 vyper，流行的语言是 solidity，这篇文章将涵盖从 solidity 开始时需要知道的基本知识。

# **什么是扎实？**

Solidity 是一种 etheruem 智能合约语言，是一种面向对象的高级语言，用于实现智能合约。智能合约是在以太坊状态下控制账户行为的程序。

Solidity 是静态类型的，支持继承、库和复杂的用户定义类型等特性。有了 Solidity，你可以为投票、众筹、盲目拍卖和多重签名钱包等用途创建合同。

Solidity 对于编写智能合同和构建去中心化的应用程序很有用，智能合同是存储在区块链上的数字合同，当满足预定的条款和条件时会自动执行，solidity 的语法也类似于 javascript 的语法。

# **坚实度数据类型**

Solidity 是静态类型的编程语言，这意味着需要指定变量的类型。对于那些来自 javascript 后台的数据，solidity 中不存在空的和未定义的数据类型，但是每种类型都有自己的默认值，即地址的默认值是**0x 0000000000000000000000000000000。**

固体数据类型可以根据数据位置进行分类。如果变量存储自己的数据；它是一种值类型。如果它保存数据的位置；它是一个引用类型。

**实值中的值类型**

我们知道值类型是那些存储自己数据的类型，它们是:

## **布尔型**

可能的值是真和假的常数。操作员是…

● !(逻辑否定)
● & &(逻辑合取，“与”)
● ||(逻辑析取，“或”)
● ==(等式)
●！=(不等式)

# **整数**

这些分为 int 和 uint，int 代表有符号整数，这些只是正数的范围，uint 代表无符号整数，包括正数和负数。

## **字符串文字和类型**

字符串文字由双引号或单引号组成(“foo”或“bar”)，也可以分成多个连续的部分(“foobar”相当于“foobar”)，这在处理长字符串时很有用。它们不像 C 中那样隐含尾随零；“foo”代表三个字节，而不是四个。与整数文字一样，它们的类型可以变化，但是如果合适的话，它们可以隐式地转换为 bytes1、…、bytes32、bytes 和 string。

# **地址**

地址有两种来源，它们几乎完全相同

*   地址:保存一个 20 字节的值(以太坊地址的大小)。
*   应付地址:与地址相同，多了两个会员转送。

这种区别背后的想法是，`address payable`是一个可以发送以太网的地址，而普通的`addres`不能发送以太网。

## **固定大小的字节数组**

值类型 bytes1、bytes2、bytes3、…、bytes32 保存从 1 到 32 的字节序列。byte 是 bytes1 的别名。

**参考类型**

引用类型的值可以通过多个不同的名称来修改。这与值类型形成对比，在值类型中，无论何时使用值类型的变量，都会得到一个独立的副本。因此，引用类型必须比值类型处理得更小心。目前，引用类型包括结构、数组和映射。如果使用引用类型，则必须始终显式提供存储该类型的数据区域。

*   **结构**

Solidity 允许用户以结构化的形式创建自己的数据类型。该结构包含一组具有不同数据类型的元素。通常，它用于表示一个记录。为了定义一个结构*，使用了 struct* 关键字，它创建了一个新的数据类型。

*   **枚举**

枚举是在 Solidity 中创建用户定义类型的一种方式。它们可以在所有整数类型之间显式转换，但不允许隐式转换。整数的显式转换在运行时检查值是否在枚举的范围内，否则会导致断言失败。枚举需要至少一个成员，声明时其默认值是第一个成员。

*   **数组**

数组是存储相同数据类型的元素的固定集合的数据结构，其中每个元素都有一个称为索引的特定位置。我们不需要创建大量相同类型的单独变量，只需声明一个所需大小的数组，并将元素存储在数组中，并可以使用索引来访问。在 Solidity 中，数组可以是固定大小或动态大小的。

# **变量类型**

变量的类型是根据它们在智能契约中声明的来分类的，这可以比作 javascript 中的范围概念，其中我们有局部和全局变量，但是在 solidity 中我们有:

*   **状态变量:**这些变量未在任何函数中声明，可由智能合约中的任何函数访问，它们永久存储在智能合约中
*   **局部变量:**这些在函数中声明的变量只能在声明它们的函数中被访问，它们会一直存在，直到函数被执行

**全局变量:**这些是一些特殊的变量，可以在全局范围内使用，并给出有关事务和区块链属性的信息。

**内存和位置**

**存储:**是所有契约状态变量驻留的地方。每个契约都有自己的存储，它在函数调用之间是持久的，使用起来非常昂贵。默认情况下，结构、数组或映射类型的局部变量引用存储。
**内存**:用于保存临时值。它在(外部)函数调用之间被擦除，使用起来更便宜。

# 功能类型

函数是一组可重用的代码，可以在程序中的任何地方调用。这消除了反复编写相同代码的需要。它帮助程序员编写模块化代码。下面将讨论 solidity 中的各种函数类型

*   **外部函数:**外部函数是合同接口的一部分，也就是说可以从其他合同和交易中调用。不能在内部调用外部函数 f(即 f()不起作用，但 this.f()起作用)。外部函数在接收大型数据数组时有时会更有效，因为数据不是从 calldata 复制到内存中的。
*   **公共函数:**公共函数是契约接口的一部分，可以在内部调用，也可以通过消息调用。对于公共状态变量，会生成一个自动 getter 函数。
*   **内部函数:**这些函数和状态变量只能在内部访问(即从当前合同或从其派生的合同中)，而不能使用这个。
*   **私有函数:**私有函数和状态变量仅对定义它们的契约可见，在派生契约中不可见。

此外，根据函数与状态变量的交互方式，函数可以分为纯函数和视图函数。

*   **查看功能:**这是读取和修改状态变量的功能。
*   **纯函数:**这些函数不读取或修改智能合约中的状态变量。

最后，函数中需要了解的另一个概念是函数修饰符，它们用于在智能契约中改变函数的行为。

我们已经到了这篇文章的结尾，但这只是对 solidity 编程语言的简要概述，下面列出了你需要知道的其他概念和你需要浏览的资源。

*   坚固性的处理误差
*   坚实中的继承
*   事件
*   后备功能
*   构造器

**资源**

*   【Youtube 新手坚实度教程
*   [官方担保文件](https://docs.soliditylang.org/en/v0.8.11/introduction-to-smart-contracts.html)
*   [以太网固化文件](https://ethereum.org/en/developers/docs/)
*   [智能合约程序员 Youtube](https://www.youtube.com/channel/UCJWh7F3AFyQ_x01VKzr9eyA)

如果你喜欢这篇文章，请多鼓掌并与他人分享。