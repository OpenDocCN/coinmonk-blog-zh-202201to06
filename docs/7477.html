<html>
<head>
<title>Solidity: Merkle Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚固性:Merkle树</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-merkle-tree-41c2d2b1071f?source=collection_archive---------1-----------------------#2022-05-26">https://medium.com/coinmonks/solidity-merkle-tree-41c2d2b1071f?source=collection_archive---------1-----------------------#2022-05-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="f5f8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt jo translated"><span class="l jp jq jr bm js jt ju jv jw di"> T </span>今天我们来看一个有趣的话题——使用智能合同(可靠性)实现Merkle树。你能用它做什么？例如，您可以为NFT集合实现白名单逻辑。</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff jx"><img src="../Images/1628b1d89ec7eb95a6789b365fdbe8c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WyC8r-Ogpt9F_mcMyDfGdQ.png"/></div></div></figure><h1 id="36e6" class="kj kk ht bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">介绍</h1><p id="191b" class="pw-post-body-paragraph iq ir ht is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hm dt translated">假设我们有8个合并到一个块中的事务。我们需要确保:<br/> <em class="lm"> 1)这个块没有被篡改<br/> 2)其中的所有事务都真正被表示了</em></p><p id="91e2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">要做到这一点-&gt;为每笔交易(或任何其他数据)计算其散列(H₁，H₂…).这将被视为一张“表”。然后，我们基于两个散列产生一个新的散列(第2层),依此类推，直到根散列。</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff ln"><img src="../Images/a481c3535af2f547103a2998b6c5d438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m6G6HMatDQaT-pSlR9avKw.png"/></div></div></figure><p id="2106" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们如何确保事务(例如T₅)确实在块(根)中？<br/> <em class="lm">我们有一个将要比较的根哈希。</em></p><ol class=""><li id="29a2" class="lo lp ht is b it iu ix iy jb lq jf lr jj ls jn lt lu lv lw dt translated">我们取事务hashes(H₅和H₆)并重新计算散列H₅-₆</li><li id="d1cf" class="lo lp ht is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw dt translated">我们取hashes(H₅-₆和H₇-₈)并重新计算H₅-₆-₇-₈</li><li id="8bd4" class="lo lp ht is b it lx ix ly jb lz jf ma jj mb jn lt lu lv lw dt translated">取(H₁-₂-₃-₄和H₅-₆-₇-₈)，计算新的根哈希，并与原始根哈希进行比较</li></ol><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff ln"><img src="../Images/c387c5b586552c075d17a24a0d6a871f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*geWRnZZDjCT1n_goWKIn9w.png"/></div></div></figure><p id="bb8b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果根哈希值匹配，则事务是正确的，并且其中没有任何更改。<br/>注意，我们不需要所有的事务散列。</p><blockquote class="mc md me"><p id="f080" class="iq ir lm is b it iu iv iw ix iy iz ja mf jc jd je mg jg jh ji mh jk jl jm jn hm dt translated">重要提示:树中的叶子数量不是任意的，它被限制在以下值内2ⁿ <br/>下图中的例子不适用</p></blockquote><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff ln"><img src="../Images/e6b9f7098d1826164c6a5a4ff51fcf2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Wct0lmU0Rkzsa9yIBWEdA.png"/></div></div></figure><h1 id="291c" class="kj kk ht bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">Merkle树编写可靠性代码</h1><p id="a2f3" class="pw-post-body-paragraph iq ir ht is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hm dt translated">下面是使用solidity编写的智能合同实现哈希树的代码。别怕，下面我就把这段代码拆开😉</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="8270" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">考虑变量:</strong> <br/> <code class="eh mk ml mm mn b">bytes32[] public hashes</code> —一个数组，我们将在其中存储我们所有的散列，它们将代表树；<br/> <code class="eh mk ml mm mn b">string[4] transactions = [...]</code> —模拟交易的字符串数组。这可以是任何种类的数据；</p><p id="01c6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">让我们写一个哈希函数:</strong></p><pre class="jy jz ka kb fq mo mn mp mq aw mr dt"><span id="498d" class="ms kk ht mn b fv mt mu l mv mw">function makeHash(string memory input) public pure returns(bytes32){        <br/>  return keccak256(<br/>    abi.encodePacked(input)<br/>  ); <br/>}</span></pre><p id="2a90" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="lm"> keccak256 </em>返回一个预定义长度为<strong class="is hu"> 32字节</strong>的hash，但是它需要传递一个正确编码的值，这是我们用<em class="lm"> abi.encodePacked() </em>得到的。</p><h2 id="76d6" class="ms kk ht bd kl mx my mz kp na nb nc kt jb nd ne kx jf nf ng lb jj nh ni lf nj dt translated"><strong class="ak">我们将在构造函数中产生散列:</strong></h2><ol class=""><li id="49da" class="lo lp ht is b it lh ix li jb nk jf nl jj nm jn lt lu lv lw dt translated">遍历事务数组，为所有事务生成散列，并将它们添加到散列数组中</li></ol><pre class="jy jz ka kb fq mo mn mp mq aw mr dt"><span id="4f2a" class="ms kk ht mn b fv mt mu l mv mw">constructor() {        <br/>  for(uint i = 0; i &lt; transactions.length; i++) {                   <br/>    hashes.push(makeHash(transactions[i]));  // H1 H2 H3 H4        <br/>  }<br/>  ...<br/>}</span></pre><p id="d896" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">2.现在我们需要组合这些散列。请记住，在每一个连续的级别，叶子的数量会减半。数一数给定时刻有多少片叶子<code class="eh mk ml mm mn b">uint count = transactions.length //number of leaves</code>。<br/>让我们实现<em class="lm"> while(count &gt; 0)循环{…} </em>。因为我们要去更高的水平，我们需要添加一个新的变量<code class="eh mk ml mm mn b">uint offset = 0;</code></p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff ln"><img src="../Images/5d05278c0586602539f710b4b2fdf007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EmXlbL4aB70hltAUPvfcIQ.png"/></div></div></figure><p id="faf3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于哈希的组合，我们实现了<em class="lm"> for() </em>循环。照片显示了循环的迭代(红色—第一，第二；绿色—第三；紫色—第四次迭代，不会执行)。</p><div class="jy jz ka kb fq ab cb"><figure class="nn kc no np nq nr ns paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><img src="../Images/495fd1d54e471bed326301e2d645849f.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Nfym8xbNEk-MUdaod0r7Mg.png"/></div></figure><figure class="nn kc no np nq nr ns paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><img src="../Images/cf25e5fb3880c787d004f76c0adeb543.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*3QT-o8xEcrkcNWj0bcZvXA.png"/></div></figure><figure class="nn kc no np nq nr ns paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><img src="../Images/808c298fa3993ff11fa215ddb8ccfd5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*lyRIekfVnWTv-vvWshtXOA.png"/></div></figure></div><p id="029d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这就是我们如何计算根哈希和其他。</p><h2 id="5a41" class="ms kk ht bd kl mx my mz kp na nb nc kt jb nd ne kx jf nf ng lb jj nh ni lf nj dt translated"><strong class="ak">检查功能</strong></h2><p id="96c6" class="pw-post-body-paragraph iq ir ht is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hm dt translated">让我们实现事务验证功能。假设我们想知道T₃(H₃).的真实性我们需要2个hashes(H₄，H₁-₂)来做这件事。我们将把这些元素存储在数组<code class="eh mk ml mm mn b">bytes32[] memory proof</code>中。</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff ln"><img src="../Images/0bbb456c6ce88b62deee7f52abdb98c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8FgELQs4h9EhSWxWaoKjgA.png"/></div></div></figure><p id="8b3c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">变量<code class="eh mk ml mm mn b">bytes32 hash = makeHash(transaction);</code>存储我们将要检查的事务的散列。<br/>接下来，我们编写一个for()循环来遍历证明数组。<br/>请注意，我们正在检查<em class="lm"> </em> <code class="eh mk ml mm mn b">element</code>(索引)的奇偶校验，因为如果元素是偶数(例如H₃)，我们必须将元素放在右边(H₄)，反之亦然，以构建总散列。</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff ln"><img src="../Images/1e933e45cd366caad66fbf87f657aa80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EwFb6XU5qFWa0xZRHrG1bQ.png"/></div></div></figure><p id="df43" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">根据元素的奇偶性，我们满足以下条件<em class="lm"> if-else </em>:</p><pre class="jy jz ka kb fq mo mn mp mq aw mr dt"><span id="385e" class="ms kk ht mn b fv mt mu l mv mw">function verify(...) public pure returns(bool) {      <br/>  bytes32 hash = makeHash(transaction);<br/>  for(uint i = 0; i &lt; proof.length; i++) {            <br/>    bytes32 element = proof[i];  <br/>    if(index % 2 == 0) {                <br/>      hash = keccak256(abi.encodePacked(hash, element));<br/>    } else {               <br/>      hash = keccak256(abi.encodePacked(element, hash));<br/>    }<br/>}</span></pre><p id="a4dc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">那我们就要上一级了。我们记得这将元素的数量减半，所以我们添加了<em class="lm"> </em> <code class="eh mk ml mm mn b">index = index / 2;</code>。最后，我们将原始的根哈希与我们统计的结果进行比较<code class="eh mk ml mm mn b">return hash == root;</code>。</p><h1 id="3047" class="kj kk ht bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">功能检查</h1><p id="0dfb" class="pw-post-body-paragraph iq ir ht is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn hm dt translated">转到<a class="ae nt" href="http://remix.ethereum.org" rel="noopener ugc nofollow" target="_blank"> Remix </a>，在<em class="lm"> /contracts </em>文件夹中创建一个新文件，并从这个<a class="ae nt" href="https://github.com/kumancev/study_algorithms/blob/main/MerkleTree/MerkleTree.sol" rel="noopener ugc nofollow" target="_blank">库</a>中复制/粘贴代码(别忘了放一个star⭐).<br/> <em class="lm"> 1)编制本合同。2)部署合同。<br/> 3)尝试检查交易</em></p><p id="9384" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我将使用索引2检查交易。部署之后，您可以从<strong class="is hu"> hashes </strong>按钮(您在输入中写入您想要的散列的索引)中获得散列。<br/>根哈希将是哈希数组中的最后一个元素。<br/>与2(H₃指数交易的证明数组)将包括H₄和H₁-₂.散列<br/>我得到以下数据:</p><pre class="jy jz ka kb fq mo mn mp mq aw mr dt"><span id="222d" class="ms kk ht mn b fv mt mu l mv mw">// transaction expm: "TX3: John -&gt; Mary"<br/>// index: 2<br/>// root: 0x4aebbc948c21be9df7ac8d63e2f1c6d9a58998d4edfba9b192a6f8d4d7d07958<br/>// H4: 0x69a40d72d1258df801a7ae1e36dd586717a112334f8d9ca4664a339168874ef5<br/>// H1-2: 0x83d2dbc9a1246936e38d7f1d4de7709616ac8c32e5159f4a79b5587800249d24</span></pre><p id="e0f8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果我将这些值放入<em class="lm">验证函数</em>调用，我会得到<strong class="is hu">真值</strong>。如果任何数据有哪怕是最轻微的变化，我们都会得到<strong class="is hu">假</strong>。</p><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div class="fe ff nu"><img src="../Images/ef7d59fb61b55d73f2259d341c360ca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*j4e2FcHNFwR1hCj71zw3zQ.png"/></div></figure><p id="dcd6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">唷，那真的很多，但是现在你明白了如何实现以及智能合同中的<strong class="is hu"> Merkle树</strong>如何工作。将来，我可能会使用Merkle的树来分解白名单(allowlist)的实现。</p><p id="ce79" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="lm">我期待你和comments✍的反应🏻</em></p><blockquote class="mc md me"><p id="c7c6" class="iq ir lm is b it iu iv iw ix iy iz ja mf jc jd je mg jg jh ji mh jk jl jm jn hm dt translated"><strong class="is hu">重要提示</strong>:这段代码不适合真实世界，如果你想为你的收藏创建空投/白名单，请阅读这篇<a class="ae nt" rel="noopener" href="/@kumancev1/nft-airdrop-whitelist-implementation-with-merkletree-1afbaf4c0935">文章</a></p></blockquote></div></div>    
</body>
</html>