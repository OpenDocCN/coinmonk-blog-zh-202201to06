<html>
<head>
<title>Solidity, contract conversion to and from address and its pitfall</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可靠性、合同与地址的转换及其缺陷</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-contract-conversion-to-and-from-address-and-its-pitfall-bffc533a96eb?source=collection_archive---------6-----------------------#2022-06-30">https://medium.com/coinmonks/solidity-contract-conversion-to-and-from-address-and-its-pitfall-bffc533a96eb?source=collection_archive---------6-----------------------#2022-06-30</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="0e72" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">众所周知，在Solidity中，我们可以将地址“强制转换”为契约，也可以将契约转换为地址(契约的地址)，我们可能会认为将地址转换为错误的契约会失败，但它可能不会失败，并且可能会发生意外的行为。</p><p id="7ea9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这篇文章中，我将简要解释在将一个假定的契约地址转换为其假定的契约时，我们可能会发现一些令人惊讶或意想不到的行为。</p><p id="6664" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，我们知道我们可以将当前契约转换到它的地址来对它做一些操作:</p><figure class="jo jp jq jr fq js"><div class="bz el l di"><div class="jt ju l"/></div></figure><p id="a593" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请注意我们是如何将关键字<code class="eh jv jw jx jy b">this</code>传递给address类型的(它引用了代码正在执行的当前契约),从而有效地将当前契约“转换”成它的地址，以获得它的余额。这是可以的。</p><p id="370f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，让我们假设在我们的契约中有一个契约<code class="eh jv jw jx jy b">A</code>和一个契约<code class="eh jv jw jx jy b">B</code>，并且那个契约<code class="eh jv jw jx jy b">B</code>有一个契约<code class="eh jv jw jx jy b">A a</code>的引用，我们可以用类似上面的语法得到契约<code class="eh jv jw jx jy b">a</code>的余额:</p><figure class="jo jp jq jr fq js"><div class="bz el l di"><div class="jt ju l"/></div></figure><p id="e2c6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">查看完整示例:</p><figure class="jo jp jq jr fq js"><div class="bz el l di"><div class="jt ju l"/></div></figure><p id="b82d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所有这一切都是有效的，运作良好。</p><p id="251c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，请注意，在上面的构造函数中，我们期望一个地址被传递给我们，具体来说，我们期望一个类型为<code class="eh jv jw jx jy b">A</code>的已部署契约的契约地址。但是，我们真的确定我们将被传递一个已部署的契约<code class="eh jv jw jx jy b">A</code>的契约地址，或者一个与契约<code class="eh jv jw jx jy b">A</code>无关的任何其他契约的地址吗？</p><p id="c6ca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果我们尝试将一个不同契约地址“强制转换”到<code class="eh jv jw jx jy b">A</code>契约，会失败吗？不，它不会失败，因为EVM没有办法知道传递的地址是否属于已经部署的<code class="eh jv jw jx jy b">A</code>契约实例。</p><p id="5f8a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果我们得到的是外部拥有的地址而不是合同地址，会失败吗？不，它也不会失败，因为契约地址和外部拥有的地址看起来完全一样，所以EVM将使用任何有效的以太坊地址将其转换为<code class="eh jv jw jx jy b">A</code>契约类型，并且不会抱怨它，直到我们尝试实际调用该契约上的函数，然后EVM将在运行时注意到这不是一个契约地址，或者被调用的契约不包含我们尝试调用的函数。</p><blockquote class="jz ka kb"><p id="3707" class="iq ir kc is b it iu iv iw ix iy iz ja kd jc jd je ke jg jh ji kf jk jl jm jn hm dt translated">交易新手？尝试<a class="ae kg" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae kg" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote><p id="d8af" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，如果我们出于某种原因传递了一个有效的契约地址，比如说，契约的<code class="eh jv jw jx jy b">C</code>地址，而<code class="eh jv jw jx jy b">C</code>契约具有我们想要在契约<code class="eh jv jw jx jy b">A</code>上调用的相同功能，会发生什么呢？嗯，EVM将调用契约<code class="eh jv jw jx jy b">C</code>上的那个函数，并且不会抱怨它。</p><p id="fa17" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了说明这一点，让我们看看这两个合同，<code class="eh jv jw jx jy b">Receiver</code>和<code class="eh jv jw jx jy b">Sender</code>。在两个合同中，我们将拥有完全相同的<code class="eh jv jw jx jy b">getBalance</code>功能。</p><p id="58e4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">契约<code class="eh jv jw jx jy b">Receiver</code>将能够通过<code class="eh jv jw jx jy b">receivePayment</code>接受ether，并将发送方的余额保存在一个余额映射中，并将有一个<code class="eh jv jw jx jy b">getBalance</code>函数来获取该契约的当前余额:</p><figure class="jo jp jq jr fq js"><div class="bz el l di"><div class="jt ju l"/></div></figure><p id="f5ac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">合同<code class="eh jv jw jx jy b">Sender</code>将导入<code class="eh jv jw jx jy b">Receiver</code>。发送方也具有与<code class="eh jv jw jx jy b">Receiver</code>合同相同的<code class="eh jv jw jx jy b">getBalance</code>功能，仅用于演示上述内容。</p><p id="84c9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">注意<code class="eh jv jw jx jy b">getReceiverBalance</code>函数是如何接收一个地址的，这个地址应该是一个已经部署的<code class="eh jv jw jx jy b">Receiver</code>契约地址，但是没有办法确定它是一个<code class="eh jv jw jx jy b">Receiver</code>契约地址还是任何其他有效的以太坊地址。</p><p id="1602" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，在将地址“强制转换”为一个<code class="eh jv jw jx jy b">Receiver</code>契约后，它通过<code class="eh jv jw jx jy b">Receiver receiver</code>引用调用<code class="eh jv jw jx jy b">getBalance</code>函数。</p><figure class="jo jp jq jr fq js"><div class="bz el l di"><div class="jt ju l"/></div></figure><p id="a095" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当调用<code class="eh jv jw jx jy b">receiver.getBalance</code>函数时，可能会发生一些事情:</p><ol class=""><li id="ada4" class="kh ki ht is b it iu ix iy jb kj jf kk jj kl jn km kn ko kp dt translated">如果<code class="eh jv jw jx jy b">receiverAddress</code>是一个合同，但它实际上不是一个<code class="eh jv jw jx jy b">Receiver</code>合同，并且不具有<code class="eh jv jw jx jy b">getBalance</code>功能，它将被恢复。</li><li id="b331" class="kh ki ht is b it kq ix kr jb ks jf kt jj ku jn km kn ko kp dt translated">如果<code class="eh jv jw jx jy b">receiverAddress</code>甚至不是一个契约，而是一个外部拥有的地址，显然，它没有<code class="eh jv jw jx jy b">getBalance</code>方法，它将恢复。</li><li id="3953" class="kh ki ht is b it kq ix kr jb ks jf kt jj ku jn km kn ko kp dt translated">如果<code class="eh jv jw jx jy b">receiverAddress</code>是一个契约，但它实际上不是一个<code class="eh jv jw jx jy b">Receiver</code>契约，但它有一个<code class="eh jv jw jx jy b">getBalance</code>函数，它将工作并返回一个值。</li><li id="036c" class="kh ki ht is b it kq ix kr jb ks jf kt jj ku jn km kn ko kp dt translated">如果<code class="eh jv jw jx jy b">receiverAddress</code>是一个<code class="eh jv jw jx jy b">Receiver</code>合约，它将按预期工作。</li></ol><p id="8ad0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于我们的示例，如果我们部署这两个契约，并将3个以太直接发送给<code class="eh jv jw jx jy b">Receiver</code>契约，并使用正确的<code class="eh jv jw jx jy b">Receiver</code>契约地址调用<code class="eh jv jw jx jy b">Sender</code>契约上的<code class="eh jv jw jx jy b">getReceiverBalance</code>，那么我们将得到发送给<code class="eh jv jw jx jy b">Receiver</code>契约的3个以太作为响应。</p><p id="7243" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">但是，如果我们使用<code class="eh jv jw jx jy b">Sender</code>契约自己的地址调用<code class="eh jv jw jx jy b">Sender.getReceiverBalance</code>函数，那么它会将这个其他契约地址“强制转换”为<code class="eh jv jw jx jy b">Receiver</code>引用，并且还会工作并返回我们在<code class="eh jv jw jx jy b">Sender.getBalance</code>函数中的硬编码值，因为<code class="eh jv jw jx jy b">Sender</code>契约具有与<code class="eh jv jw jx jy b">Receiver</code> abi相同的<code class="eh jv jw jx jy b">getBalance</code>函数。</p><p id="6b01" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们在混音中测试一下:</p><figure class="jo jp jq jr fq js fe ff paragraph-image"><div class="fe ff kv"><img src="../Images/04ce7ddb4df8f43aa1c422ae170571a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*2DpAVDPisH0mSWDqfh9Obw.png"/></div></figure><figure class="jo jp jq jr fq js fe ff paragraph-image"><div class="fe ff ky"><img src="../Images/49703941bdc950fab3d59045b08a2a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*28Yax-cd_lfKojq82uJu0w.png"/></div></figure><p id="0867" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">部署完<code class="eh jv jw jx jy b">Receiver</code>契约后，我使用<code class="eh jv jw jx jy b">receivePayment</code>函数发送了3 ether。</p><p id="4169" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是接收器合同地址:0x8a 7644191756 a 1122 a 63 c0ca 7238 a8f 15706 f 825</p><p id="e722" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，让我们部署<code class="eh jv jw jx jy b">Sender</code>合同:</p><figure class="jo jp jq jr fq js fe ff paragraph-image"><div class="fe ff kz"><img src="../Images/077c7c1bb1560ea99f6905d5f014ee27.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*TvzC_WwMpuwO7Oarq3sEBQ.png"/></div></figure><p id="23d2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在部署了<code class="eh jv jw jx jy b">Sender</code>契约并点击其<code class="eh jv jw jx jy b">getBalance</code>函数后，我们得到了该函数中的硬编码值。</p><p id="866e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">发送方合同地址为:0x 438 eacebf 3 F2 a1 C3 e 8560277345 e 83 ff 228355 be</p><p id="0d6f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，如果我们使用接收方合同地址，并将其放入发送方的<code class="eh jv jw jx jy b">getReceiverBalance</code>函数中，我们会得到:</p><figure class="jo jp jq jr fq js fe ff paragraph-image"><div class="fe ff la"><img src="../Images/19f69b8ead839318f124afadbd467769.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*nTp8OPCdOph6FX0hl7WTgQ.png"/></div></figure><p id="271e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">3乙醚(300000000000000000魏)如预期。</p><p id="5593" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，让我们将发送者的合同地址放入它自己的<code class="eh jv jw jx jy b">getReceiverBalance</code>函数中:</p><figure class="jo jp jq jr fq js fe ff paragraph-image"><div class="fe ff la"><img src="../Images/191879ab86e5f8be0297912c089c9791.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*LbXESaIUQhUIug_U8zELwA.png"/></div></figure><p id="81c8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">有趣的是，它在自己的<code class="eh jv jw jx jy b">getBalance</code>函数中返回了硬编码的值，即使是在将发送方的合同地址转换为<code class="eh jv jw jx jy b">Receiver</code>合同类型并通过<code class="eh jv jw jx jy b">Receiver</code> abi调用<code class="eh jv jw jx jy b">getBalance</code>函数之后。</p><p id="8e94" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们试着用一个没有<code class="eh jv jw jx jy b">getBalance</code>函数的契约调用它(0x DDB 68 EFA 4 FDC 889 CCA 414 c 0a 7 acad 3c 5 cc 08 A8 c 5):</p><figure class="jo jp jq jr fq js fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff lb"><img src="../Images/3ec3a8f38ce69603f41bf52f1833d7b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V2oneqpv6wFvGHyoYmq60Q.png"/></div></div></figure><p id="f67f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">不出所料，它恢复了原状。</p><p id="5311" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我们试着用一个外部拥有的地址(0x 6827 b 8 f 6 cc 60497d 9 BF 5210d 602 c 0 ecaf df 7 c 405)调用它:</p><figure class="jo jp jq jr fq js fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff lg"><img src="../Images/52a40f394cc27f378bdb2bbe809b169b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BvKsuf2pr7vBWxIqUu557g.png"/></div></div></figure><p id="6b91" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">不出所料，它也恢复了原状。</p><p id="864b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">结论</strong></p><p id="367b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在Solidity中，我们可以轻松地将契约转换为地址，将地址转换为契约，但是在契约和地址之间来回转换时，我们需要记住一些事情，因为在将地址转换为契约时，EVM无法在运行时检查地址是否确实属于该契约类型，并且只有在实际调用的契约没有所请求的函数或者它是外部拥有的地址时，才会在试图通过该契约调用函数时失败。</p></div></div>    
</body>
</html>