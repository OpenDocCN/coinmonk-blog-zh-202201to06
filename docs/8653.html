<html>
<head>
<title>ERC-20: building a fungible token smart contract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ERC-20:构建可替换的令牌智能合约</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/erc-20-building-a-fungible-token-smart-contract-936bf55e7ab?source=collection_archive---------4-----------------------#2022-06-14">https://medium.com/coinmonks/erc-20-building-a-fungible-token-smart-contract-936bf55e7ab?source=collection_archive---------4-----------------------#2022-06-14</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/958a4ca71e5d36e4289f6a141c428ba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*_YJL6pcPP9Ku_wVq.jpeg"/></div></figure><p id="52d6" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在我们上一篇<a class="ae jv" href="https://coinsbench.com/smart-contracts-the-hitchhikers-guide-to-the-protocols-f3857d351e4c" rel="noopener ugc nofollow" target="_blank">帖子</a>中，我们详细介绍了各种ERC协议的种类和用途。它们为我们提供了创建相互对话的契约的模式，帮助社区开发和使用区块链服务。</p><p id="4c59" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在本文中，我们将使用ERC-20协议构建一个用于可替换令牌的契约，使用<a class="ae jv" href="https://docs.soliditylang.org/en/v0.8.14/" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hu"> Solidity </strong> </a>作为我们的契约编程语言，使用开发工具<a class="ae jv" href="https://hardhat.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hu"> Hardhat </strong> </a>，一些<a class="ae jv" href="https://www.openzeppelin.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hu"> OpenZeppelin </strong> </a>库，<a class="ae jv" href="https://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hu"> Chai </strong> </a>进行测试，使用<a class="ae jv" href="https://coinmarketcap.com/api/" rel="noopener ugc nofollow" target="_blank"><strong class="iz hu">CoinMarketCap</strong></a>API检索真实的天然气成本估计</p></div><div class="ab cl jw jx hb jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hm hn ho hp hq"><h2 id="2122" class="kd ke ht bd kf kg kh ki kj kk kl km kn ji ko kp kq jm kr ks kt jq ku kv kw kx dt translated"><strong class="ak"> 1。配置</strong></h2><p id="abc9" class="pw-post-body-paragraph ix iy ht iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju hm dt translated">第一步是<a class="ae jv" href="https://docs.npmjs.com/downloading-and-installing-node-js-and-npm" rel="noopener ugc nofollow" target="_blank">在你的电脑上安装</a>(如果还没有安装)<a class="ae jv" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>和<a class="ae jv" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>。接下来，我们将打开一个终端窗口，创建我们的目录，启动一个新的npm项目，并在其中安装hardhat包。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="a753" class="kd ke ht li b fv lm ln l lo lp">mkdir erc20-fungible-token-contract<br/>cd erc20-fungible-token-contract/<br/>npm init --yes<br/>npm install hardhat</span></pre><p id="2f30" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在是时候用命令创建一个新的hardhat项目了</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="ef02" class="kd ke ht li b fv lm ln l lo lp">npx hardhat</span></pre><p id="c54e" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">它会提示一系列的选项，现在，让我们选择创建一个示例项目</p><figure class="ld le lf lg fq iu fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/d187241204f4d966dbf877282c0683bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4C7JE9I8eY97EqCd.png"/></div></figure><p id="620b" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">接下来我们将确认项目将被插入的目录，并在选项中选择“是”以添加一个<em class="lr">。gitignore </em>文件并安装项目的依赖项。</p><figure class="ld le lf lg fq iu fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/111070a5c31cd6331314b71b40f88f40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N0eMKySETJSJcjz8.png"/></div></figure><p id="74a3" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">用代码编辑器打开目录我们可以看到创建了一堆类似<strong class="iz hu"> <em class="lr">契约的文件。sol </em> </strong>，一个<strong class="iz hu"> <em class="lr">部署脚本</em> </strong>和一个<strong class="iz hu"> <em class="lr">测试脚本</em> </strong>。</p><figure class="ld le lf lg fq iu fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/c2fe2c02fcd0fba5eb933a4e94c7bace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DS1c0-nLp7MAi77j.png"/></div></figure><p id="1bf4" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">让我们首先将合同文件重命名(或删除它并创建一个新的)为<strong class="iz hu"> Token.sol </strong>，并在其中添加以下内容。</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="b1a5" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">对于一个兼容ERC-20协议的合同，我们至少需要具备<strong class="iz hu">转账</strong>、<strong class="iz hu">结算</strong>、<strong class="iz hu">总供</strong>、<strong class="iz hu">转账自</strong>、<strong class="iz hu">审批</strong>和<strong class="iz hu">津贴</strong>的功能。除了事件<strong class="iz hu">转移</strong>和<strong class="iz hu">审批</strong>之外。此时，我们可以简单地导入并使用<a class="ae jv" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol" rel="noopener ugc nofollow" target="_blank"> OpenZeppeling ERC20库</a>。但是由于这篇文章有教育目的，我们将卷起袖子自己写代码。让我们开始定义所需的变量、事件和契约构造函数。</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="6b13" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">首先，我们使用<strong class="iz hu"> <em class="lr"> _totalSupply </em> </strong>变量来存储可用的令牌数量，使用映射<strong class="iz hu"> <em class="lr"> _balances </em> </strong>和<strong class="iz hu"><em class="lr">_ allowments</em></strong>来存储每个地址拥有的令牌数量，以及第三方地址可以管理多少个属于某个地址的令牌。除此之外，我们还有事件<strong class="iz hu">传送</strong>和<strong class="iz hu">批准</strong>，它们必须在令牌传送发生时或所有者批准第三个地址管理其部分令牌时发出。最后，我们有我们的合同建筑商。<strong class="iz hu"> <em class="lr">构造函数</em> </strong>内的代码块在契约创建时只执行一次。在这种情况下，我们收到一个带有初始令牌数量的参数，我们更新存储该信息的变量，将该数量传输到执行合同创建的地址(<strong class="iz hu"> <em class="lr"> msg.sender </em> </strong>)，最后，我们发出一个事件，表明该数量的令牌已传输到该地址。接下来，我们将创建视图函数，这些函数不会改变存储在区块链上的数据的状态，它们只会返回该信息</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="ec5b" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">所以现在我们定义函数<strong class="iz hu"> totalSupply </strong>、<strong class="iz hu"> balanceOf </strong>和<strong class="iz hu"> allowance </strong>，它返回可用的令牌数量、一个地址拥有的令牌数量以及第三方地址可以从另一个地址管理的令牌数量。下一步将是定义内部函数(仅由契约本身调用),该函数执行令牌的传输和批准操作。然后我们将定义外部函数(可以被用户调用)来执行各自的功能。</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="372c" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">function _transfer允许将<strong class="iz hu"> <em class="lr">数量</em> </strong>的令牌从地址<strong class="iz hu"><em class="lr"/></strong>传送到地址<strong class="iz hu"> <em class="lr">接收者</em> </strong>并发出一个<strong class="iz hu">传送</strong>事件，表明操作已完成。<strong class="iz hu"> _approve </strong>功能允许地址<strong class="iz hu"> <em class="lr">所有者</em> </strong>授予地址<strong class="iz hu"> <em class="lr">消费者</em> </strong>管理其代币<strong class="iz hu"> <em class="lr">数量</em> </strong>的权限。最后，我们有外部函数<strong class="iz hu"> transfer </strong>、<strong class="iz hu"> approve </strong>和<strong class="iz hu"> transferFrom </strong>，用户可以执行这些函数，并使用带有正确参数的内部函数。</p><blockquote class="lu lv lw"><p id="7774" class="ix iy lr iz b ja jb jc jd je jf jg jh lx jj jk jl ly jn jo jp lz jr js jt ju hm dt translated"><strong class="iz hu">注</strong>:到目前为止，我们已经有了一份与ERC-20协议兼容的最低要求的合同！</p></blockquote><h2 id="fb74" class="kd ke ht bd kf kg kh ki kj kk kl km kn ji ko kp kq jm kr ks kt jq ku kv kw kx dt translated">2.用户化</h2><p id="296a" class="pw-post-body-paragraph ix iy ht iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju hm dt translated">现在是时候定制这个合同，并为我们的项目包括其他重要的功能。让我们从包括ERC-20协议的可选元数据扩展开始，它允许我们附加一个名称，一个符号，我们令牌的小数位数。</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="14ae" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我们在这里所做的是在合同创建时将定义值之外的变量<strong class="iz hu"> <em class="lr"> _decimals </em> </strong>，<strong class="iz hu"> <em class="lr"> _symbol </em> </strong>和<strong class="iz hu"> <em class="lr"> _name </em> </strong>包含到它们中。我们还包括视图函数<strong class="iz hu">小数</strong>、<strong class="iz hu">符号</strong>和<strong class="iz hu">名称</strong>，它们返回存储在这些变量上的值。现在让我们加入一些函数，允许我们用<strong class="iz hu"> mint </strong>函数创建新令牌，用<strong class="iz hu"> burn </strong>函数销毁现有令牌。这些功能是敏感的，我们需要包含一个逻辑，以便只有合同的所有者才能执行它们。为此，这一次，我们将使用OpenZeppelin访问控制库<a class="ae jv" href="https://docs.openzeppelin.com/contracts/2.x/access-control" rel="noopener ugc nofollow" target="_blank"> Ownable </a>。在其他特性中，这个库给了我们修饰符<strong class="iz hu"> <em class="lr"> onlyOwner </em> </strong>，它可以附加到任何函数上。具有此修饰符的功能只能由合同所有者执行。现在让我们用下面的命令安装OpenZeppelin包。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="5471" class="kd ke ht li b fv lm ln l lo lp">npm install <a class="ae jv" href="http://twitter.com/openzeppelin/contracts" rel="noopener ugc nofollow" target="_blank">@openzeppelin/contracts</a></span></pre><p id="92b8" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">要在契约文件中使用这个库，我们需要导入它，并在契约定义中包含它的继承，如下所示。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="44f5" class="kd ke ht li b fv lm ln l lo lp">import "@openzeppelin/contracts/access/Ownable.sol";</span><span id="028b" class="kd ke ht li b fv ma ln l lo lp">contract <em class="lr">Token</em> is <em class="lr">Ownable</em> {}</span></pre><p id="4f18" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在<strong class="iz hu">造币</strong>和<strong class="iz hu">刻录</strong>功能中，我们需要记住从<em class="lr"> _totalSupply </em>和参考地址余额中增加/减少要创建/销毁的令牌数量。并且还发出一个<strong class="iz hu">传输</strong>事件。</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="ls lt l"/></div></figure><blockquote class="lu lv lw"><p id="0bdf" class="ix iy lr iz b ja jb jc jd je jf jg jh lx jj jk jl ly jn jo jp lz jr js jt ju hm dt translated"><strong class="iz hu">注</strong>:可以看到公共函数<strong class="iz hu"> mint </strong>和<strong class="iz hu"> burn </strong>只有<strong class="iz hu"><em class="ht">owner</em></strong>修饰符。这样只有合同创建者(执行部署的<strong class="iz hu"> <em class="ht"> msg.sender </em> </strong>)可以执行。Ownable库还允许我们使用函数<strong class="iz hu"> transferOwnership </strong>更改合同所有者。</p></blockquote><h2 id="210f" class="kd ke ht bd kf kg kh ki kj kk kl km kn ji ko kp kq jm kr ks kt jq ku kv kw kx dt translated">3.试验</h2><p id="ca65" class="pw-post-body-paragraph ix iy ht iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju hm dt translated">现在，我们的代币合同写好了，让我们去测试吧！让我们使用<a class="ae jv" href="https://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank">柴</a>库来帮助我们完成这个过程。首先让我们重命名文件<strong class="iz hu"> test/sample-test.js </strong>并开始重写它。</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="d38b" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我们开始测试，确保一旦执行了部署，契约就有了正确的设置。首先，我们使用<a class="ae jv" href="https://docs.ethers.io/v5/" rel="noopener ugc nofollow" target="_blank"> ethers </a>库中的<a class="ae jv" href="https://docs.ethers.io/v5/api/signer/" rel="noopener ugc nofollow" target="_blank"> getSigners </a>函数，它返回给我们一个包含20个以太坊账户的数组。每当我们在与库交互时没有明确提到我们使用的是哪个帐户，就像在接下来的几行中我们使用<strong class="iz hu"> contractFactory </strong>并让契约<strong class="iz hu"> deploy </strong>时，库默认不理解位于0位置的帐户是谁在进行调用。因此，当0帐户调用deploy时，它将被视为我们测试中的合同所有者。</p><p id="e317" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在部署函数中，我们传递以下参数(<strong class="iz hu"> 5000000 </strong>、<strong class="iz hu"> "NiceToken" </strong>、<strong class="iz hu"> "NTKN" </strong>、<strong class="iz hu"> 18 </strong>)，它们分别是<strong class="iz hu"><em class="lr">token total supply</em></strong>、<em class="lr"/><strong class="iz hu"><em class="lr">token name</em></strong>、<em class="lr"/><strong class="iz hu"><em class="lr">token symbol</em>接下来，我们调用视图函数，并从Chai运行<strong class="iz hu"> assert </strong>函数，以确保它们是用正确的值定义的！此外，我们检查合同所有者的余额是否收到了所有创建的令牌。为了运行测试，我们使用以下命令:</strong></p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="2646" class="kd ke ht li b fv lm ln l lo lp">npx hardhat test</span></pre><figure class="ld le lf lg fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="fe ff mb"><img src="../Images/3b684226a063342a8741447be7a71bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/0*feJF9NC-w7YCuK4G.png"/></div></div></figure><p id="9925" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在，让我们通过测试来检查令牌传输功能是否正常工作。为了让我们的测试目录保持有序，让我们为这个特性的测试创建一个新文件。然后我们创建了<strong class="iz hu"> test/tokenTransfers.js </strong>文件。</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="3326" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我们已经包括了3个以上的测试。在第一个例子中，我们检查最初有5000000代币的合同是否可以将10000代币从Lucas转移到第二个帐户。接下来，我们测试当Lucas试图将15000个代币(多于他的余额)转移给joo时，合同是否返回错误。最后，Lucas是否可以成功地将5000(少于他的余额)转移给Carol。总是确认blanaces是否被正确更新。让我们再次运行tests命令，检查是否一切正常。</p><figure class="ld le lf lg fq iu fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/56a0020d0c7d2904416cc5b982d7c749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qrY7oRRWd2uwX0wO.png"/></div></figure><p id="c3de" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">让我们看看最后一个测试文件中的一些要点。当我们想使用不同于0账户(所有者账户)的账户执行合同中的某些功能时，我们可以使用<strong class="iz hu">连接</strong>功能。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="f1e5" class="kd ke ht li b fv lm ln l lo lp">await token.connect(lucas).transfer(await carol.getAddress(), 5000);</span></pre><p id="e118" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我们还以下面的方式使用Chai库中的expect函数来检查是否发出了错误。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="da03" class="kd ke ht li b fv lm ln l lo lp">await expect(token.connect(lucas).transfer(await joao.getAddress(), 15000)).to.be.revertedWith("Token: cannot transfer more than account owns");</span></pre><p id="b118" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">主要检查返回的错误消息是否与契约内<strong class="iz hu">trans snfer</strong>函数的<strong class="iz hu"> <em class="lr"> require </em> </strong>上定义的消息相同。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="9ee4" class="kd ke ht li b fv lm ln l lo lp">require(_balances[sender] &gt;= amount, "Token: cannot transfer more than account owns");</span></pre><p id="cabe" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">另一个要点是，如果我们从<strong class="iz hu">断言</strong>函数中改变一些参数，检查测试是否失败。让我们以下面的方式更改最后一个，并再次运行测试。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="97f9" class="kd ke ht li b fv lm ln l lo lp">assert.equal(carolBalance.toNumber(), 10000, "Carol balance was not updated correctly");</span></pre><p id="7317" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我们可以看到测试不出所料地失败了。</p><figure class="ld le lf lg fq iu fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/6ac7699e466ea1ac59320945ac46ad91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u_7x2U75GpBXSgJ4.png"/></div></figure><p id="0d84" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">下面的测试组将为我们检查允许一个地址可以管理其他令牌的特性。所以让我们从创建一个新文件开始，<strong class="iz hu">test/token allowments . js</strong>。</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="3f22" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在这个文件中，我们执行了3个测试。第一个批准地址以管理您的令牌数量的人。第二个用于检查当此地址尝试传输的令牌数量超过允许数量时是否返回错误。最后检查金额小于或等于允许总额的转账是否通过经理地址成功转账。现在让我们编写最后两个测试文件来检查令牌<strong class="iz hu"> mint </strong>和<strong class="iz hu"> burn </strong>特性。让我们创建<strong class="iz hu"> test/tokenMint.js </strong>和<strong class="iz hu"> test/tokenBurn.js </strong>文件。</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="ls lt l"/></div></figure><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="707d" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这两个文件各有两个测试。一个用于测试合同所有者是否成功执行了铸币/刻录，以及代币的可用数量和收到/丢失代币者的余额是否正确更新。第二个测试检查其他帐户(不是所有者)不能执行这些功能。现在我们已经对我们所有的特性进行了测试，我们可以检查它们是否如预期的那样通过了。</p><figure class="ld le lf lg fq iu fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/531ee7a4e660d5e7bf52081aad88e78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pCuPpsmJzJweHn1a.png"/></div></figure><p id="672f" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">测试中的另一个极其重要的点，对于将在生产中运行的项目更是如此，它包括了<strong class="iz hu"> <em class="lr"> gas reporter </em> </strong>来估计合同功能的实际成本。为此，让我们通过下面的命令安装软件包<a class="ae jv" href="https://www.npmjs.com/package/hardhat-gas-reporter" rel="noopener ugc nofollow" target="_blank"><em class="lr">hard hat-gas-reporter</em></a>。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="e513" class="kd ke ht li b fv lm ln l lo lp">npm install hardhat-gas-reporter --save-dev</span></pre><p id="1adc" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">接下来的步骤是将库导入包含在项目根目录上定义的hardhat配置文件hard hat<em class="lr"/><strong class="iz hu"><em class="lr">hard at . config . j</em>s</strong>中。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="649f" class="kd ke ht li b fv lm ln l lo lp">require("hardhat-gas-reporter");</span></pre><p id="d10b" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在我们可以看到，当我们在终端上运行该命令时，我们会收到一个摘要，其中显示了在测试中执行的每个函数的平均气体成本。</p><figure class="ld le lf lg fq iu fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/f31d70d8e7a5065dfba999e1a72fb28f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dby28tRkbQBf0AD0.png"/></div></figure><p id="caae" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">为了做得更好，我们可以使用<strong class="iz hu"><em class="lr">CoinMarketCap API</em></strong>来返回值，并自动计算每个函数在任何货币中的天然气成本及其当前市场价格。为此，我们需要在这个<a class="ae jv" href="https://pro.coinmarketcap.com/signup" rel="noopener ugc nofollow" target="_blank">站点</a>上创建一个帐户。验证电子邮件后，我们将有权访问该网站和我们的API密钥，我们将复制这些信息用于该项目。</p><figure class="ld le lf lg fq iu fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/a24a9bdc05becdb54ec233c1f9a9c9b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CYvxm8sh32-Jt60n.png"/></div></figure><p id="19c8" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">有了这个密钥，我们回到hardhat配置文件，并在文件<em class="lr"> export </em>中包含以下对象。</p><figure class="ld le lf lg fq iu fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/13c5139271f93a179bc8cd05e2a38d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/0*7sgchxLV1J4RXdO2.png"/></div></figure><p id="2066" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">其中<strong class="iz hu"> COINMARKETCAP_API_KEY </strong>是从站点复制的密钥。之后，我们还要选择汇总所用的货币。最终的配置文件应该如下所示。</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="a3eb" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在，如果我们在终端上运行tests命令，我们将得到以下摘要。</p><figure class="ld le lf lg fq iu fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/69e88765f11e1ae6143ddce0945c1cf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RV0I_Gsmp0XQ_NRo.png"/></div></figure><p id="0d29" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">所选货币的平均成本。如果我们在<strong class="iz hu"> <em class="lr">货币</em> </strong>参数中使用<strong class="iz hu"> BRL </strong>，我们就有了以巴西雷亚尔为单位的平均成本。</p><figure class="ld le lf lg fq iu fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/a46ce66610bd4ea922cce5a26b46177e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*acZVpNLDujmcaMiI.png"/></div></figure></div><div class="ab cl jw jx hb jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hm hn ho hp hq"><h2 id="144f" class="kd ke ht bd kf kg kh ki kj kk kl km kn ji ko kp kq jm kr ks kt jq ku kv kw kx dt translated">4.部署</h2><p id="b9b3" class="pw-post-body-paragraph ix iy ht iz b ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq lc js jt ju hm dt translated">现在，我们将编写脚本来部署我们的合同。部署完成后，我们实际上将合同从以太坊上传到Mainnet、Rinkeby和Goerli等网络，甚至从Polygon上传到Mainnet和Mumbai。</p><p id="9c4d" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在<strong class="iz hu"> scripts/ </strong>目录中，我们有一个<strong class="iz hu"> sample-script.js </strong>文件，它是在我们用hardhat启动一个项目时自动生成的。让我们删除这个文件并创建另一个名为<strong class="iz hu"> deploy.js </strong>的文件。最初，该文件将具有以下格式。</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="2db1" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">首先，我们将从irs配置库中导入hardhat <strong class="iz hu"> task </strong>函数，这允许我们设置一个可以用以下命令执行的动作</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="339a" class="kd ke ht li b fv lm ln l lo lp">npx hardhat deploy</span></pre><p id="5c4a" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">该命令的参数<strong class="iz hu"><em class="lr"/></strong>是在<strong class="iz hu">任务</strong>函数中定义的第一个参数。因此，如果我们将它设置为“<strong class="iz hu">口袋妖怪</strong>”，我们应该使用</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="774c" class="kd ke ht li b fv lm ln l lo lp">npx hardhat pokemon</span></pre><p id="20eb" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">去执行它。接下来，我们将包括合同部署所需的逻辑。</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="e250" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">这里要注意的第一点是，我们返回了一个<strong class="iz hu"> <em class="lr"> deployer </em> </strong>变量，该变量将在部署的后续步骤中使用。这个变量是在hardhat配置文件中定义的，我们将会进一步介绍。函数<strong class="iz hu"> getContractFactory </strong>的第一个参数是在<strong class="iz hu"> Token.sol </strong>内的合同类中定义的合同名称(“Token”)。</p><p id="ef24" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">另一个要点是，在我们部署我们的契约之前，我们需要<strong class="iz hu">编译</strong>它。上述函数将检查合同编译后生成的<strong class="iz hu">工件/ </strong>目录中的合同名称。我们可以使用以下命令运行编译:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="cdb9" class="kd ke ht li b fv lm ln l lo lp">npx hardhat compile</span></pre><p id="54e9" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">接下来，我们使用希望传递给契约构造函数的值来执行部署，并放置一个日志来标识已部署契约的地址(记住要复制这个值！).</p><p id="12aa" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">如果我们现在执行deploy命令，我们会发现它不起作用。这是因为我们仍然需要对我们的配置文件<strong class="iz hu"> hardhat.config.js </strong>进行一些修改。首先，我们删除默认的accounts任务，它与项目样例创建一起出现。在我们包含了创建的部署脚本的导入文件之后。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="b75c" class="kd ke ht li b fv lm ln l lo lp">require("./scripts/deploy.js");</span></pre><p id="d005" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我们还必须将对象<strong class="iz hu"> <em class="lr"> networks </em> </strong>添加到配置文件导出中，其中包含我们要进行部署的网络的信息。</p><figure class="ld le lf lg fq iu fe ff paragraph-image"><div class="fe ff mh"><img src="../Images/90b1b281c527d49461f5e44696becf03.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/0*Hx2H-rPOw6kuwdne.png"/></div></figure><p id="c12a" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">如果我们想将我们的契约部署到不同的网络，这个对象内部可以有多个对象。在这种情况下，我们将把它部署到<a class="ae jv" href="https://www.rinkeby.io/#stats" rel="noopener ugc nofollow" target="_blank"> Rinkeby </a>网络。我们可以在<a class="ae jv" href="https://hardhat.org/tutorial/deploying-to-a-live-network.html" rel="noopener ugc nofollow" target="_blank">安全帽文档</a>中看到这个物体的更多细节。变量<strong class="iz hu"> RINKEBY_URL </strong>必须填充所使用的区块链节点提供者的值。最著名的是<a class="ae jv" href="https://www.alchemy.com/" rel="noopener ugc nofollow" target="_blank">炼金术</a>和<a class="ae jv" href="https://infura.io/" rel="noopener ugc nofollow" target="_blank">因夫拉</a>。在本教程中，我们将使用炼金术。我们只需要在那里创建一个帐户，选择以太坊链，并在Rinkeby网络上创建一个新的应用程序。</p><figure class="ld le lf lg fq iu fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/a66771d2b0c38c18e43a769187c01667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C6Q50MsXwU4HXBL_.png"/></div></figure><p id="76d2" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在创建应用程序后，您只需复制HTTP格式的API密钥，并将其插入配置文件中的<strong class="iz hu"> <em class="lr"> url </em> </strong>参数。看，我们有另一个参数<strong class="iz hu"> <em class="lr">帐户</em> </strong>，它是一个数组，包含由部署脚本中的函数<strong class="iz hu"> getSigners </strong>返回的帐户。此变量必须具有用于部署合同的wallet的私钥。请记住，要正确地做到这一点，我们必须在你的钱包里有一些ETH。我推荐<a class="ae jv" href="https://metamask.io/" rel="noopener ugc nofollow" target="_blank"> Metamask </a>。复制您的私钥并粘贴到<strong class="iz hu"> DEV_PRIVATE_KEY </strong>的位置。最后，我们的配置文件必须具有以下格式:</p><figure class="ld le lf lg fq iu"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="3ab8" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">如前所述，要部署合同，我们需要在钱包中放入来自Rinkeby network的ETH(假ether)。我们可以通过使用可用的水龙头(<a class="ae jv" href="https://rinkebyfaucet.com/" rel="noopener ugc nofollow" target="_blank"> 1 </a>、<a class="ae jv" href="https://faucet.rinkeby.io/" rel="noopener ugc nofollow" target="_blank"> 2 </a>、<a class="ae jv" href="https://faucets.chain.link/rinkeby" rel="noopener ugc nofollow" target="_blank"> 3 </a>)来获得一些。现在我们只需要编译我们的契约，然后通过定义的网络运行deploy命令。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="9233" class="kd ke ht li b fv lm ln l lo lp">npx hardhat deploy --network rinkeby</span></pre><p id="6160" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我们可以看到，我们的合同已成功更新到Rinkeby网络，地址如下:</p><figure class="ld le lf lg fq iu fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/e3ddbb20c15be5c236ae39c4ab8212fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NB3RgqABDoCqOaBr.png"/></div></figure><p id="da37" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我们可以通过查看Rinkeby network的Etherscan页面上的地址来确认这一点！我们只需要把它粘贴到搜索框上。就这份合同而言，这里的<a class="ae jv" href="https://rinkeby.etherscan.io/address/0xebf32E65fEE74337BcCe37056BB8a0c386DD7679" rel="noopener ugc nofollow" target="_blank">是</a>。</p><figure class="ld le lf lg fq iu fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/93b7d49c2daa4ae943b7a362a91152b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*73QcHqg9sb-fsm3n.png"/></div></figure><p id="1f52" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在，此合同中执行的所有交易都可以在此页面上跟踪。</p></div><div class="ab cl jw jx hb jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hm hn ho hp hq"><p id="1c13" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">本教程到此结束。最终代码可以在我的<a class="ae jv" href="https://github.com/lucasvieira94/erc20-fungible-token-contract" rel="noopener ugc nofollow" target="_blank"> Github </a>中找到。</p><p id="6ef9" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">感谢您的关注，我希望这对正在阅读的您有用:)</p><blockquote class="mi"><p id="58c1" class="mj mk ht bd ml mm mn mo mp mq mr ju ek translated">加入Coinmonks <a class="ae jv" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jv" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="f937" class="ms ke ht bd kf mt mu mv kj mw mx my kn mz na nb kq nc nd ne kt nf ng nh kw ni dt translated">另外，阅读</h1><ul class=""><li id="a944" class="nj nk ht iz b ja ky je kz ji nl jm nm jq nn ju no np nq nr dt translated"><a class="ae jv" href="https://coincodecap.com/best-cryptocurrency-apis" rel="noopener ugc nofollow" target="_blank">面向开发者的8个最佳加密货币API</a></li><li id="db05" class="nj nk ht iz b ja ns je nt ji nu jm nv jq nw ju no np nq nr dt translated"><a class="ae jv" href="https://coincodecap.com/zero-fee-crypto-exchanges" rel="noopener ugc nofollow" target="_blank"> 7个最佳零费用加密交易平台</a></li><li id="e199" class="nj nk ht iz b ja ns je nt ji nu jm nv jq nw ju no np nq nr dt translated"><a class="ae jv" href="https://coincodecap.com/best-online-casinos" rel="noopener ugc nofollow" target="_blank">最佳网上赌场</a> | <a class="ae jv" rel="noopener" href="/coinmonks/futures-trading-bots-5a282ccee3f5">期货交易机器人</a></li><li id="29a7" class="nj nk ht iz b ja ns je nt ji nu jm nv jq nw ju no np nq nr dt translated"><a class="ae jv" href="https://coincodecap.com/what-are-decentralized-exchanges" rel="noopener ugc nofollow" target="_blank">分散交易所</a> | <a class="ae jv" href="https://coincodecap.com/bitbns-fip" rel="noopener ugc nofollow" target="_blank">比特恩斯FIP </a> | <a class="ae jv" href="https://coincodecap.com/bingbon-review" rel="noopener ugc nofollow" target="_blank">宾邦评论</a></li><li id="c0d4" class="nj nk ht iz b ja ns je nt ji nu jm nv jq nw ju no np nq nr dt translated"><a class="ae jv" href="https://coincodecap.com/buy-crypto-with-credit-card" rel="noopener ugc nofollow" target="_blank">用信用卡购买密码的10个最佳地点</a></li><li id="5992" class="nj nk ht iz b ja ns je nt ji nu jm nv jq nw ju no np nq nr dt translated"><a class="ae jv" href="https://coincodecap.com/5-best-crypto-trading-bots-in-canada" rel="noopener ugc nofollow" target="_blank">加拿大最佳加密交易机器人</a> | <a class="ae jv" href="https://coincodecap.com/bybit-binance-moonxbt" rel="noopener ugc nofollow" target="_blank"> Bybit vs币安</a></li><li id="72ce" class="nj nk ht iz b ja ns je nt ji nu jm nv jq nw ju no np nq nr dt translated"><a class="ae jv" href="https://coincodecap.com/best-crypto-exchanges-in-uae" rel="noopener ugc nofollow" target="_blank">阿联酋5大最佳加密交易所</a> | <a class="ae jv" href="https://coincodecap.com/simpleswap-review" rel="noopener ugc nofollow" target="_blank"> SimpleSwap评论</a></li></ul></div></div>    
</body>
</html>