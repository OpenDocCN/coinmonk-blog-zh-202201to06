<html>
<head>
<title>Solana Data Streaming at 310 tps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">310 tps的Solana数据流</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solana-data-streaming-at-310-tps-6f93f76a964e?source=collection_archive---------4-----------------------#2022-04-21">https://medium.com/coinmonks/solana-data-streaming-at-310-tps-6f93f76a964e?source=collection_archive---------4-----------------------#2022-04-21</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="1d1e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在我之前的<a class="ae jo" rel="noopener" href="/coinmonks/solana-blockchain-data-scraping-2cca0dc056aa">帖子</a>中，我创建了一个rust data scraper从索拉纳区块链网络中提取交易数据。由于Solana交易的数据量如此之大，我想进一步研究我以前的高吞吐量数据流系统。</p><p id="80f6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">数据流管道体系结构如下:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/28eaa06f4acecfd379322cd5d35701b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7-s1g86LxtdtNHzDQ6O_aQ.png"/></div></div></figure><p id="a60b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Rust Solana客户端线程会反复从Solana区块链网络获取最新的数据块。对于每一笔支付交易，它都会向Kafka主题发布一条消息。另一个线程池(Kafka consumers)将从Kafka代理中提取消息，然后将数据插入Neo4j数据库。</p><p id="27c3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">上面所有的蓝色组件都运行在我的个人Mac上的docker容器中，该Mac有6个CPU内核和8G内存。代码可以在我的Git <a class="ae jo" href="https://github.com/iwasnothing/solana_scraper" rel="noopener ugc nofollow" target="_blank">库</a>中找到。</p><p id="81bb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在达到吞吐量之前，我遇到了很多问题——平均每秒310个事务(tps)。在这里，我分享了我学到的经验教训。</p><ol class=""><li id="3efd" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj dt translated">数据库连接泄漏和生锈多线程编程</li></ol><p id="fb6e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我在使用neo4j rust客户端时犯了一个严重的错误。我错误地将GraphDB客户端设置放在消息拉线程的执行中。如果线程过早失败而没有回收客户机对象来关闭连接，这将导致数据库连接急剧增加。解决方案是在生成线程之前创建DB客户机连接。然而，这在Rust中并不是微不足道的，因为Rust中严格的变量所有权。基本上，客户端对象不能简单地通过全局变量引用在线程间共享。我们必须使用“<a class="ae jo" href="https://doc.rust-lang.org/std/sync/struct.Arc.html" rel="noopener ugc nofollow" target="_blank">原子引用计数</a>”(ARC)，这是一个线程安全的引用计数指针。根据Rust文档，Arc解释如下:</p><blockquote class="kk kl km"><p id="e46c" class="iq ir kn is b it iu iv iw ix iy iz ja ko jc jd je kp jg jh ji kq jk jl jm jn hm dt translated">类型<code class="eh kr ks kt ku b">Arc&lt;T&gt;</code>提供在堆中分配的类型<code class="eh kr ks kt ku b">T</code>的值的共享所有权。在<code class="eh kr ks kt ku b">Arc</code>上调用<code class="eh kr ks kt ku b"><a class="ae jo" href="https://doc.rust-lang.org/std/clone/trait.Clone.html#tymethod.clone" rel="noopener ugc nofollow" target="_blank">clone</a></code>会产生一个新的<code class="eh kr ks kt ku b">Arc</code>实例，它在堆上指向与源<code class="eh kr ks kt ku b">Arc</code>相同的分配，同时增加一个引用计数。当指向给定分配的最后一个<code class="eh kr ks kt ku b">Arc</code>指针被销毁时，存储在该分配中的值(通常称为“内部值”)也被丢弃。默认情况下，Rust中的共享引用不允许变异，<code class="eh kr ks kt ku b">Arc</code>也不例外:通常情况下，您不能获得对<code class="eh kr ks kt ku b">Arc</code>内部某个对象的可变引用。如果您需要通过<code class="eh kr ks kt ku b">Arc</code>进行变异，请使用<code class="eh kr ks kt ku b"><a class="ae jo" href="https://doc.rust-lang.org/std/sync/struct.Mutex.html" rel="noopener ugc nofollow" target="_blank">Mutex</a></code>、<code class="eh kr ks kt ku b"><a class="ae jo" href="https://doc.rust-lang.org/std/sync/struct.RwLock.html" rel="noopener ugc nofollow" target="_blank">RwLock</a></code>或<code class="eh kr ks kt ku b"><a class="ae jo" href="https://doc.rust-lang.org/std/sync/atomic/index.html" rel="noopener ugc nofollow" target="_blank">Atomic</a></code>类型之一。</p></blockquote><p id="7c84" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这意味着在我们的情况下，我们应该:</p><ol class=""><li id="e0b4" class="kb kc ht is b it iu ix iy jb kd jf ke jj kf jn kg kh ki kj dt translated">使用连接参数创建<code class="eh kr ks kt ku b">graph</code>客户端对象。</li><li id="0ffb" class="kb kc ht is b it kv ix kw jb kx jf ky jj kz jn kg kh ki kj dt translated">为其做圆弧参考:<code class="eh kr ks kt ku b">Arc::new(graph)</code>。</li><li id="7710" class="kb kc ht is b it kv ix kw jb kx jf ky jj kz jn kg kh ki kj dt translated">通过借用上下文将<code class="eh kr ks kt ku b">Arc</code>引用传递给衍生的线程，这可以通过在线程创建时添加关键字<code class="eh kr ks kt ku b">move</code>来完成。</li><li id="09ce" class="kb kc ht is b it kv ix kw jb kx jf ky jj kz jn kg kh ki kj dt translated">在执行任何图形查询之前，在线程内部传递对<code class="eh kr ks kt ku b">Arc::clone</code>的<code class="eh kr ks kt ku b">graph</code>引用。</li></ol><p id="4cca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">基本上，对于线程内部的代码访问父线程的变量，我们需要在线程执行时使用关键字<code class="eh kr ks kt ku b">move</code>(<code class="eh kr ks kt ku b">pool.execute(move||… </code>)，这样线程就可以借用父上下文。代码将是这样的:</p><pre class="jq jr js jt fq la ku lb lc aw ld dt"><span id="8b79" class="le lf ht ku b fv lg lh l li lj">let pool = ThreadPool::new(pool_size);<br/>let graph = Arc::new(Graph<!-- -->::new(&amp;uri, user, pass).await.unwrap());</span><span id="31ce" class="le lf ht ku b fv lk lh l li lj">pool.execute(move|| {<br/>     let g = Arc.clone(&amp;graph)<br/>     g.execute(query(......</span></pre><p id="8412" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">2.Neo4j数据库索引和约束。</p><p id="9930" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我发现当数据增长到一定程度后，Graph DB会崩溃。这是因为我们在密码查询中使用了<code class="eh kr ks kt ku b">MERGE</code>来避免账户重复。但是，这将导致每次创建帐户之前对现有帐户进行全表扫描。通过添加唯一性约束解决了这个问题，因为默认情况下将使用该约束创建索引。</p><pre class="jq jr js jt fq la ku lb lc aw ld dt"><span id="92ae" class="le lf ht ku b fv lg lh l li lj">CREATE CONSTRAINT unique_account_key FOR (a:Account) REQUIRE a.key IS UNIQUE</span></pre><p id="0af0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">3.数据库批量更新</p><p id="eb19" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Kafka的一个关键性能指标是消费者滞后。我发现消费者滞后现象持续增加。这表明瓶颈在数据库端。因此，我尝试将后续的数据插入合并到1 DB事务中，这样可以消除每次插入的开销。<code class="eh kr ks kt ku b">batch_size</code>大约是100–200。这可以提高DB插入吞吐量。消费滞后不会一直增加。</p><blockquote class="ll"><p id="6514" class="lm ln ht bd lo lp lq lr ls lt lu jn ek translated">加入Coinmonks <a class="ae jo" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jo" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="25b8" class="lv lf ht bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr dt translated">另外，阅读</h1><ul class=""><li id="4a0d" class="kb kc ht is b it ms ix mt jb mu jf mv jj mw jn mx kh ki kj dt translated"><a class="ae jo" href="https://coincodecap.com/ascendex-margin-trading" rel="noopener ugc nofollow" target="_blank"> AscendEx保证金交易</a> | <a class="ae jo" href="https://coincodecap.com/bitfinex-staking" rel="noopener ugc nofollow" target="_blank"> Bitfinex赌注</a></li><li id="6e60" class="kb kc ht is b it kv ix kw jb kx jf ky jj kz jn mx kh ki kj dt translated"><a class="ae jo" href="https://coincodecap.com/best-cardano-wallets" rel="noopener ugc nofollow" target="_blank">最好的卡达诺钱包</a> | <a class="ae jo" href="https://coincodecap.com/bingbon-copy-trading" rel="noopener ugc nofollow" target="_blank"> Bingbon副本交易</a></li><li id="796b" class="kb kc ht is b it kv ix kw jb kx jf ky jj kz jn mx kh ki kj dt translated"><a class="ae jo" href="https://coincodecap.com/p2p-crypto-exchanges-in-india" rel="noopener ugc nofollow" target="_blank">印度最佳P2P加密交易所</a> | <a class="ae jo" href="https://coincodecap.com/baby-shiba-inu-wallets" rel="noopener ugc nofollow" target="_blank">柴犬钱包</a></li><li id="eacf" class="kb kc ht is b it kv ix kw jb kx jf ky jj kz jn mx kh ki kj dt translated"><a class="ae jo" href="https://coincodecap.com/crypto-affiliate-programs" rel="noopener ugc nofollow" target="_blank">8大加密附属计划</a> | <a class="ae jo" href="https://coincodecap.com/etoro-vs-coinbase" rel="noopener ugc nofollow" target="_blank"> eToro vs比特币基地</a></li><li id="9287" class="kb kc ht is b it kv ix kw jb kx jf ky jj kz jn mx kh ki kj dt translated"><a class="ae jo" href="https://coincodecap.com/best-ethereum-wallets" rel="noopener ugc nofollow" target="_blank">最佳以太坊钱包</a> | <a class="ae jo" href="https://coincodecap.com/telegram-crypto-bots" rel="noopener ugc nofollow" target="_blank">电报上的加密货币机器人</a></li></ul></div></div>    
</body>
</html>